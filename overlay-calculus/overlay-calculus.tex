\AtBeginDocument{%
\providecommand\BibTeX{{Bib\TeX}}}

%% Disable ACM-specific metadata for submission
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

\usepackage{mathtools}

%% Conditional citation: hide self-citations under anonymous review.
%% Use \@firstoftwo / \@secondoftwo so the unchosen branch is never
%% expanded---preventing \cite from writing to the .aux file.
\makeatletter
\if@ACM@anonymous
\newcommand{\selfcite}[2]{#2}%
\else
\newcommand{\selfcite}[2]{#1}%
\fi
\makeatother

\newcommand{\Path}{\mathtt{Path}}
\newcommand{\dom}{\mathtt{dom}}
\newcommand{\properties}{\mathtt{properties}}
\newcommand{\overlays}{\mathtt{overlays}}
\newcommand{\supers}{\mathtt{supers}}
\newcommand{\inherits}{\mathtt{inherits}}
\newcommand{\defines}{\mathtt{defines}}
\newcommand{\bases}{\mathtt{bases}}
\newcommand{\resolve}{\mathtt{resolve}}
\newcommand{\this}{\mathtt{this}}
\newcommand{\snoc}{\mathbin{\triangleright}}
\newcommand{\init}{\mathtt{init}}
\newcommand{\last}{\mathtt{last}}
\newcommand{\qualifiedthis}[1]{#1.\mathbf{this}}
\newcommand{\dbi}[1]{\uparrow^{\!#1}}

\begin{document}

\title{A Calculus of Overlays}

\author{Bo Yang}
\affiliation{%
  \institution{Figure AI Inc.}
  \city{San Jose}
  \state{California}
  \country{USA}
}
\email{yang-bo@yang-bo.com}
\thanks{This work was conducted independently prior to the author's employment at Figure AI.}

\begin{abstract}
  Just as the $\lambda$-calculus uses three primitives (abstraction,
  application, variable) as the foundation of functional programming,
  Overlay-Calculus uses three primitives (record, definition, inheritance)
  as the foundation of declarative programming.
  It trivially embeds the $\lambda$-calculus, although the entire
  semantics rests solely on naive set theory;
  as a consequence, all constructs including inheritance are
  inherently commutative, idempotent, and associative; the
  linearization problem of multiple inheritance
  does not arise.
  This induces a fully abstract semantics of the lazy
  $\lambda$-calculus with respect to B\"ohm tree
  equivalence.
  Overlay-Calculus is distilled from the Overlay language, a
  practical implementation in which we observed further emergent
  phenomena: the Expression Problem dissolves, programs are
  function color blind~\cite{nystrom2015color}, ordinary arithmetic
  yields the relational semantics of logic programming,
  and self-reference resolves to multiple targets.
  These properties suggest applications to configuration languages,
  dependency injection, object-oriented programming, composable
  effect systems, modular software architectures,
  file-system-as-compiler, general-purpose programming,
  and no-code development.
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>100</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010128</concept_id>
  <concept_desc>Theory of computation~Object oriented constructs</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010127</concept_id>
  <concept_desc>Theory of computation~Functional constructs</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010129</concept_id>
  <concept_desc>Theory of computation~Program schemes</concept_desc>
  <concept_significance>100</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011039</concept_id>
  <concept_desc>Software and its engineering~Formal language definitions</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
  <concept_desc>Software and its engineering~Extensible languages</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
  <concept_desc>Software and its engineering~Object oriented languages</concept_desc>
  <concept_significance>100</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[100]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Theory of computation~Object oriented constructs}
\ccsdesc[300]{Theory of computation~Functional constructs}
\ccsdesc[100]{Theory of computation~Program schemes}
\ccsdesc[500]{Software and its engineering~Formal language definitions}
\ccsdesc[500]{Software and its engineering~Extensible languages}
\ccsdesc[100]{Software and its engineering~Object oriented languages}

\keywords{declarative programming, inheritance, denotational semantics,
  self-referential records, expression problem,
  \texorpdfstring{$\lambda$-calculus}{lambda-calculus},
\texorpdfstring{B\"ohm trees}{Bohm trees}, configuration languages}

\maketitle

\section{Introduction}
\label{sec:introduction}

Declarative and configuration languages are ubiquitous in modern software
engineering. Systems such as NixOS modules~\cite{dolstra2010nixos,nixosmodules},
Jsonnet~\cite{jsonnet}, Hydra~\cite{hydra2023}, CUE~\cite{cue2019}, Dhall~\cite{dhall2017},
Kustomize~\cite{kustomize}, and JSON Patch~\cite{rfc6902} all provide mechanisms for composing
structured data through inheritance or overlay. Among these, the NixOS
module system stands out: its recursive attribute set merging with
fixed-point semantics and deferred modules~\cite{nixosmodules} achieves
considerable expressiveness in practice, and the mechanism has been adopted well beyond NixOS itself: Home
Manager~\cite{homemanager}, nix-darwin~\cite{nixdarwin},
disko~\cite{disko}, flake-parts~\cite{flakeparts},
dream2nix~\cite{dream2nix}, devenv~\cite{devenv},
KubeNix~\cite{kubenix}, and nixidy~\cite{nixidy} use it to manage
user environments, macOS configuration, disk partitioning, flake
structure, multi-language packaging, developer environments, and
Kubernetes clusters respectively. Yet no computational
theory explains \emph{why} this mechanism is so expressive.

The $\lambda$-calculus serves as the foundational computational model for
functional programming. No analogous calculus exists for declarative
programming. This gap matters because the two paradigms differ in
fundamental ways. Configuration languages are inherently declarative:
their values are \emph{immutable} and they have \emph{no first-class
functions}. At first glance, Turing completeness appears incompatible
with these constraints. The three classical models of computation each
violate at least one of them:

\begin{center}
  \begin{tabular}{lccc}
    \textbf{Model} & \textbf{Turing complete} & \textbf{Immutable} & \textbf{No $\lambda$} \\
    \hline
    Turing Machine     & $\checkmark$ & $\times$     & $\checkmark$ \\
    $\lambda$-calculus & $\checkmark$ & $\checkmark$ & $\times$ \\
    RAM Machine        & $\checkmark$ & $\times$     & $\checkmark$ \\
  \end{tabular}
\end{center}

\noindent
The Turing Machine and RAM Machine require mutable state;
the $\lambda$-calculus requires first-class functions.
A computational model that is Turing complete, immutable, and
function-free would sit in the empty cell of this table.
The NixOS module system already suggests that such a model exists:
its inheritance-based composition over recursive records, without
explicit functions, is expressive enough to configure entire operating
systems.

Conventionally, the value domain of configuration languages is assumed
to consist of finite, well-founded structures, that is, initial algebras in the
sense of universal algebra. We challenge this assumption: configuration
values are better understood as lazily observable, possibly infinite
structures, in the spirit of F-coalgebras~\cite{rutten2000universal}, where
semantics is determined by the observer and a finite prefix suffices
for any finite observation. This is not merely a theoretical
distinction: the \texttt{nixpkgs} package
collection~\cite{dolstra2006purely} (over 100{,}000
packages) behaves as a lazily observed structure in practice, allowing any
single package to be evaluated without materializing the entire set.
Guided by this observation, we set out to reduce the
NixOS module system to a minimal set of primitives.
Through iterative refinement (beginning with
an early version implemented in Nix), the system evolved into the Overlay
language\selfcite{~\cite{mixin2025}}{~(included as supplementary
material)}, now implemented in Python: a declarative programming
language with only three constructs (record literals, properties,
and inheritance) and no functions or let-bindings.

In developing real programs in the Overlay language, including boolean logic and
natural number arithmetic (Section~\ref{sec:case-study}) and a web application
(Section~\ref{sec:practical-function-color}), we found that the
linearization problem of mixin-based
systems~\cite{bracha1990mixin,c3linearization} is structurally absent:
because records are sets, inheritance is inherently commutative,
idempotent, and associative (Section~\ref{sec:overlay-trees}).
Self-reference naturally resolves to \emph{multiple objects} rather than
one; prior systems assume single-object resolution and reject the
multi-path situation (Scala, NixOS module system).
Self-referential records require no fixed-point combinator---the
inheritance tree \emph{is} the call stack, and qualified this resolution
is a first-order set-theoretic query, not a fixed-point construction.
We also found that boolean logic and arithmetic, implemented as separate
overlay files, extend in both dimensions of the Expression
Problem~\cite{wadler1998expression} without any dedicated mechanism;
that Church-encoded values automatically form trie structures; and
that operations on tries automatically become Cartesian products, so that
adding $\{1,2\}$ to $\{3,4\}$ yields $\{4,5,6\}$, which
is the relational semantics of logic programming
(Section~\ref{sec:case-study}); and that the same web
application overlay file runs under both Python asyncio and synchronous
execution without modification, an instance of function color
blindness~\cite{nystrom2015color}, equivalently CPS-agnostic behavior
(Section~\ref{sec:practical-function-color}).

This paper distills these observations into \textbf{Overlay-Calculus},
a minimal computational model for declarative programming.
\emph{Function application translates directly into inheritance}:
a $\lambda$-abstraction corresponds to a record with an
$\mathrm{argument}$ slot and a $\mathrm{result}$ slot, and function
application corresponds to inheriting from the function record and a record
that supplies the argument. Since the $\lambda$-calculus embeds into
Overlay-Calculus, Overlay-Calculus is Turing complete.
The translation reveals an \emph{asymmetry}:
while embedding the $\lambda$-calculus into Overlay-Calculus is trivial,
the reverse is non-trivial because Overlay-Calculus provides primitive
operations, namely self-referential records, open recursion, and symmetric
inheritance, that have no direct counterparts in the $\lambda$-calculus.
This asymmetry suggests that Overlay-Calculus is not merely a
syntactic variant of the $\lambda$-calculus but captures
different computational patterns.

Just as the $\lambda$-calculus uses three primitives (abstraction,
application, variable) to serve as the foundation of functional
programming, Overlay-Calculus uses three primitives (record, definition,
inheritance) to serve as the foundation of declarative programming.

All constructions in this paper have been implemented and tested in
the Overlay language,
\selfcite{available as open source~\cite{mixin2025}}{included as supplementary material},
with a test suite covering every example.%
\footnote{The Overlay language is statically typed and therefore
stricter than the untyped Overlay-Calculus.
All examples in this paper are ported from the Overlay language
and conform to both semantics.
Elements added to satisfy the type checker are harmless
for the algorithms presented here and may aid readability.}
All tests are mechanically verified against expected output snapshots.

\paragraph{Contributions}
\begin{itemize}
  \item We present Overlay-Calculus, a minimal computational model for
    declarative programming that contains only overlay constructs (record,
    definition, inheritance) and no functions or scalar types.
  \item Inheritance operates at the \emph{tree level}:
    a record is a set of elements, both definitions and
    inheritance sources, so inheriting from two overlays that share a label
    recursively merges their subtrees (deep merge), rather
    than overriding at the method level as in mixin and trait calculi.
    Since records are sets, inheritance is inherently commutative,
    idempotent, and associative.
    The linearization problem inherent in prior mixin and trait
    calculi does not arise.
  \item The semantics is purely \emph{observational}: there are no
    reduction rules, no evaluation order, and no notion of a result
    that a term reduces to.  The observer drives computation by
    querying paths in a lazily constructed tree.
  \item Self-referential records require no fixed-point combinator.
    The $\lambda$-calculus translation maps each application to a
    inheritance; the resulting inheritance tree \emph{is} the call stack.
    The $\this$ function of Section~\ref{sec:overlay-trees} resolves
    self-references by walking this tree: a first-order set-theoretic
    query, not a fixed-point construction.
  \item Self-reference resolves to \emph{multiple objects}, not one.
    Path-dependent types with inheritance naturally produce this
    situation; prior systems assume single-object resolution and
    reject it (Scala and the NixOS module system,
    Appendix~\ref{app:scala-multi-path}).
    Since inheritance is idempotent, all objects contribute
    equally; no disambiguation is needed.
  \item The $\lambda$-calculus (in A-normal form) translates into
    Overlay-Calculus in five rules (Section~\ref{sec:translation}).
    The translation is fully abstract with respect to
    B\"ohm tree equivalence (Section~\ref{sec:bohm-tree}),
    yielding a semantics of the lazy $\lambda$-calculus that
    requires no domain theory.
  \item We observe further properties: extensibility in the sense of the
    Expression Problem~\cite{wadler1998expression}
    (Section~\ref{sec:expression-problem}), relational semantics of logic
    programming from ordinary arithmetic
    (Section~\ref{sec:case-study}), and function color
    blindness~\cite{nystrom2015color}
    (Section~\ref{sec:practical-function-color}).
\end{itemize}

Section~\ref{sec:case-study} demonstrates these properties
through a case study of the Expression Problem.

\section{Syntax}
\label{sec:syntax}

Let $e$ denote an expression.
Let $\ell$ denote a label (property name).
Let $k$ denote a non-negative integer (path length).

\begin{align*}
  e \quad ::= \quad & \{c_1,\; \ldots,\; c_m\}
  && \text{(} m \ge 0 \text{)} \\
  \mid\quad & c
  && \text{(sugar for } \{c\} \text{)} \\[6pt]
  c \quad ::= \quad & \ell \mapsto e
  && \text{(definition)} \\
  \mid\quad & [\qualifiedthis{\ell_{\mathrm{up}}}. \mid \dbi{n}.]\;\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}
  && \text{(inheritance, } k \ge 0 \text{ with qualifier,} \\
  &&& k \ge 1 \text{ without)}
\end{align*}

An expression is a \emph{set} of elements enclosed in braces.
Each element is either a definition $\ell \mapsto e$ or
an inheritance source.
Because expressions are sets, element order is irrelevant and
duplicates have no effect; inheritance is inherently commutative,
idempotent, and associative.

The $\mapsto$ in $\ell \mapsto e$ defines a property, not a let-binding.
There is no variable binding in Overlay-Calculus.
The Overlay language also provides scalar types through a
foreign-function interface (FFI); Overlay-Calculus is what remains
after removing the FFI.
None of the examples in this paper uses the FFI; scalars
did not arise.

\paragraph{Inheritance}
An inheritance is written as a reference
that navigates the scope hierarchy upward and then projects
properties downward. The upward navigation admits two equivalent
notations:
\begin{itemize}
  \item \emph{Named form}:
    $\qualifiedthis{\ell_{\mathrm{up}}}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$,
    analogous to Java's \texttt{Outer.this.field}.
    Each $\{\ldots\}$ record has a label in its enclosing scope;
    $\ell_{\mathrm{up}}$ names the target enclosing scope.
  \item \emph{Indexed form}:
    $\dbi{n}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$,
    where $n \ge 0$ is a de~Bruijn index~\cite{debruijn1972lambda}:
    $n = 0$ refers to the reference's enclosing scope,
    and each increment of $n$ moves one scope level further out.
\end{itemize}
Both forms retrieve the target scope, that is, the fully inherited record
after all inheritance has been applied, and then project properties
$\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$ from it.
The named form desugars to the indexed form during parsing
(Section~\ref{sec:overlay-trees}).

A new scope level is created at each $\{\ldots\}$ (record literal).
The scope contains all properties of that overlay, including those
inherited via inheritance sources.
For example, $\{a \mapsto \{\},\; b \mapsto \{\}\}$ is a single overlay whose scope
contains both $a$ and $b$; so is $\{r,\; a \mapsto \{\}\}$ where $r$
is a reference to a record containing $b$.
Inheritance sources do not create additional scope levels.

\begin{itemize}
  \item $\qualifiedthis{\mathrm{Foo}}$ (equivalently, $\dbi{n}$ where
    $\mathrm{Foo}$ is $n$ steps above the enclosing scope)
    retrieves the record named $\mathrm{Foo}$.
  \item $\qualifiedthis{\mathrm{Foo}}.\ell$ (equivalently, $\dbi{n}.\ell$)
    projects property $\ell$ from $\mathrm{Foo}$.
  \item When $k = 0$, the reference inherits the entire
    enclosing scope, which may produce an infinitely deep tree.
\end{itemize}

When the qualifier is unambiguous, it may be omitted:
the shorthand
$\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}$ ($k \ge 1$)
resolves $\ell_{\mathrm{down},1}$ against the innermost enclosing
scope whose $\defines$ contains it,
and desugars to the corresponding indexed form.
Since this uses $\defines$, the shorthand can only access
properties defined in record literals, not those inherited through
inheritance; one of the two qualified forms is required for
inherited properties or to bypass variable shadowing.

\section{Overlay Trees}
\label{sec:overlay-trees}

Given an AST, what are the \emph{properties} visible at
each position in the tree? This section answers the question by
defining a collection of mutually recursive functions over paths.

Unlike the $\lambda$-calculus, which requires reduction rules
($\beta$-reduction) to specify how terms compute, Overlay-Calculus has
\emph{no reduction steps}. There is no rewriting of terms, no
evaluation order, and no notion of a ``result'' that a term reduces to.
Instead, the semantics is purely \emph{observational}: one queries
whether a label $\ell$ is a property at a path $p$ in the inheritance
tree. The mutually recursive functions defined below, namely $\properties$,
$\supers$, $\overlays$, $\bases$, $\resolve$, and $\this$, constitute the
\emph{entire} semantics. This is the observational perspective
introduced in Section~\ref{sec:introduction}: like an
F-coalgebra~\cite{rutten2000universal}, an overlay tree's behavior is
determined by observation (property presence), not by reduction.

Most of these functions have direct analogues in object-oriented languages:
$\Path$ identifies a position in the tree,
$\init$ and $\last$ navigate paths,
$\defines$ extracts the locally defined members from the AST,
$\inherits$ extracts the inheritance declarations from the AST,
$\properties$ computes all visible members at a path including both locally defined and inherited ones,
$\supers$ computes the transitive inheritance closure,
and $\bases$ collects the direct base classes.
One function has no object-oriented analogue:
$\overlays$ collects the identity-sharing paths that arise
when inheritance introduces multiple definitions
of the same label at the same scope level.
Two functions, the reference resolution function $\resolve$
and the qualified this resolution function $\this$,
have object-oriented analogues whose semantics differ significantly;
they are discussed in detail below.

All functions are pure and may be cached (memoised) without
changing semantics.

\paragraph{Path}
A $\Path$ is a sequence of labels
$(\ell_1, \ell_2, \ldots, \ell_n)$ that identifies a position in
the tree.%
\footnote{Since paths are referentially transparent,
  an implementation may \emph{intern} paths so that
structural equality reduces to pointer equality.}
We write $p$ for a path.
The \emph{root path} is the empty sequence $()$.
Given a path $p$ and a label $\ell$,
$p \snoc \ell$ is the sequence $p$ extended with $\ell$.
For a non-root path, the parent path $\init(p)$ is $p$ with
its last element removed,
and the final label $\last(p)$ is the last element of $p$.
For convenience, we sometimes write $\ell$ for $\last(p)$
when the path is clear from context.
With paths in hand, we can state what the AST provides
at each path.

\paragraph{AST}
An expression $e$ (Section~\ref{sec:syntax}) is parsed into an AST.
The AST provides two primitive functions at each path $p$:
\begin{itemize}
  \item $\defines(p)$: the set of labels
    that have subtrees at $p$.
  \item $\inherits(p)$: the set of reference pairs
    $(n,\; \ell_{\mathrm{down},*})$,
    where $n$ is the de~Bruijn index
    and $\ell_{\mathrm{down},*}$ is the list of downward projections.
\end{itemize}

During parsing, all three syntactic forms are resolved to
de~Bruijn index pairs $(n,\; \ell_{\mathrm{down},*})$.
The \emph{indexed form}
$\dbi{n}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$
already carries the de~Bruijn index $n$ directly;
no resolution is needed.
A \emph{named reference}
$\qualifiedthis{\ell_{\mathrm{up}}}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$
at path $p$ is resolved by finding the last occurrence of
$\ell_{\mathrm{up}}$ among the labels of $p$.
Let $p_{\mathrm{target}}$ be the prefix of $p$ up to and including
that occurrence.
The de~Bruijn index is $n = |p| - |p_{\mathrm{target}}| - 1$
and the projections are
$\ell_{\mathrm{down},*} = (\ell_{\mathrm{down},1}, \ldots, \ell_{\mathrm{down},k})$.
A \emph{lexical reference} $\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}$ at path $p$
is resolved by finding the nearest prefix $p'$ of $p$
such that $\ell_{\mathrm{down},1} \in \defines(p')$.
The de~Bruijn index is $n = |p| - |p'| - 1$ and the projections are
$\ell_{\mathrm{down},*} = (\ell_{\mathrm{down},1}, \ldots, \ell_{\mathrm{down},k})$.
All three forms produce the same representation; the semantic functions
below operate only on de~Bruijn index pairs.

Parsing populates $\defines$ and $\inherits$ from each
element of a record.
A definition $\ell \mapsto e$
contributes $\ell$ to $\defines(p)$.
A reference contributes $(n,\; \ell_{\mathrm{down},*})$ to $\inherits(p)$.
Since records are sets, the order of elements is irrelevant and
duplicate elements have no effect.
Both $\defines$ and $\inherits$ are pure data; they are not functions
of runtime state.
Given these two primitives, we can now answer the question
posed at the beginning of this section.

\paragraph{Properties}
The properties of a path are its own properties together with
those inherited from all supers:
\begin{equation}\label{eq:properties}
  \properties(p) =
  \bigl\{\; \ell \;\big|\;
    (\_,\; p_{\mathrm{overlay}}) \in \supers(p),\;
    \ell \in \defines(p_{\mathrm{overlay}})
  \;\bigr\}
\end{equation}
The remainder of this section defines $\supers$,
the transitive inheritance closure,
and its dependencies.

\paragraph{Supers}
Intuitively, $\supers(p)$ collects every path that $p$ inherits from:
the identity-sharing paths $\overlays$ of $p$ itself,
plus the $\overlays$ of each
direct base $\bases$ of $p$, and so on transitively.
Each result is paired with the inheritance-site context
$\init(p_{\mathrm{base}})$ through which it is reached.
This provenance is needed by qualified this resolution, i.e.\ the $\this$ function defined below,
to map a definition-site overlay back to
the inheritance-site paths that incorporate it:
\begin{equation}\label{eq:supers}
  \supers(p) =
  \bigl\{\; (\init(p_{\mathrm{base}}),\; p_{\mathrm{overlay}}) \;\big|\;
    p_{\mathrm{base}} \in \bases^*(p),\;
    p_{\mathrm{overlay}} \in \overlays(p_{\mathrm{base}})
  \;\bigr\}
\end{equation}
Here $\bases^*$ denotes the reflexive-transitive closure of $\bases$.
The $\supers$ formula depends on two functions:
the identity-sharing paths $\overlays$ and the one-hop reference targets $\bases$.
We define $\overlays$ first.

\paragraph{Overlays}
Intuitively, inheritance can introduce multiple
definitions of the same label at the same scope level;
$\overlays(p)$ collects all such paths that share the
\emph{same identity} as $p$, so that their definitions
merge rather than shadow each other, enabling deep merge.
Concretely, the overlays of $p$ include $p$ itself
and $p_{\mathrm{branch}} \snoc \last(p)$ for every
branch $p_{\mathrm{branch}}$ of $\init(p)$ that also defines $\last(p)$:
\begin{equation}\label{eq:overlays}
  \overlays(p) =
  \begin{cases}
    \{p\} & \text{if } p = ()  \\[6pt]
    \{p\}
    \;\cup\;
    \left\{\; p_{\mathrm{branch}} \snoc \last(p) \;\left|\;
      \begin{aligned}
        &(\_,\; p_{\mathrm{branch}}) \in \supers(\init(p)), \\
        &\text{s.t.}\; \last(p) \in \defines(p_{\mathrm{branch}})
      \end{aligned}
    \right.\right\}
    & \text{if } p \neq ()
  \end{cases}
\end{equation}
It remains to define $\bases$, the other dependency of $\supers$.

\paragraph{Bases}
Intuitively, $\bases(p)$ are the paths that $p$ directly
inherits from via references, analogous to the direct base
classes in object-oriented languages.
Concretely, $\bases$ resolves every reference in
$p$'s $\overlays$ one step:
\begin{equation}\label{eq:bases}
  \bases(p) =
  \left\{\; p_{\mathrm{target}} \;\left|\;
    \begin{aligned}
      &p_{\mathrm{overlay}} \in \overlays(p), \\
      &(n,\; \ell_{\mathrm{down},*}) \in \inherits(p_{\mathrm{overlay}}), \\
      &p_{\mathrm{target}} \in \resolve(\init(p),\; p_{\mathrm{overlay}},\; n,\; \ell_{\mathrm{down},*})
    \end{aligned}
  \right.\right\}
\end{equation}
The $\bases$ formula calls the reference resolution function $\resolve$, which we define next.

\paragraph{Reference resolution}
Intuitively, $\resolve$ turns a syntactic reference into the
set of paths it points to in the fully inherited tree.
It takes an inheritance-site path $p_{\mathrm{site}}$,
a definition-site path $p_{\mathrm{def}}$,
a de~Bruijn index $n$,
and downward projections $\ell_{\mathrm{down},*}$.
Resolution proceeds in two phases:
$\this$ performs $n$ upward steps
starting from the enclosing scope $\init(p_{\mathrm{def}})$,
mapping the definition-site path to inheritance-site paths;
then the downward projections $\ell_{\mathrm{down},*}$ are appended:
\begin{multline}\label{eq:resolve}
  \resolve(p_{\mathrm{site}},\; p_{\mathrm{def}},\; n,\; \ell_{\mathrm{down},*})
  = \\
  \bigl\{\;
    p_{\mathrm{current}} \snoc \ell_{\mathrm{down},1} \snoc \cdots \snoc \ell_{\mathrm{down},k}
    \;\big|\;
    p_{\mathrm{current}} \in
    \this(\{p_{\mathrm{site}}\},\; \init(p_{\mathrm{def}}),\; n)
  \;\bigr\}
\end{multline}
When multiple routes exist (due to multi-path inheritance),
they may yield different target paths; all are collected.
We now define $\this$.

\paragraph{Qualified this resolution}
$\this$ answers the question:
``in the fully inherited tree, where does
the definition-site scope $p_{\mathrm{def}}$ actually live?''
Each step finds, among the supers of every path in the
frontier $S$, those whose overlay component matches
$p_{\mathrm{def}}$, and collects the corresponding
inheritance-site paths as the new frontier.
After $n$ steps the frontier contains the answer:
{\small
\begin{equation}\label{eq:this}
  \this(S,\; p_{\mathrm{def}},\; n) =
  \begin{cases}
    S & \text{if } n = 0 \\[6pt]
    \this\!\left(
      \left\{\; p_{\mathrm{site}} \;\left|\;
        \begin{aligned}
          &p_{\mathrm{current}} \in S, \\
          &(p_{\mathrm{site}},\; p_{\mathrm{overlay}})
          \in \supers(p_{\mathrm{current}}), \\
          &\text{s.t.}\; p_{\mathrm{overlay}} = p_{\mathrm{def}}
        \end{aligned}
      \right.\right\},\;
      \init(p_{\mathrm{def}}),\;
      n - 1
    \right)
    & \text{if } n > 0
  \end{cases}
\end{equation}}%
At each step $\init$ shortens $p_{\mathrm{def}}$ by one label
and $n$ decreases by one.
Since $n$ is a non-negative integer, the recursion terminates.

This completes the chain of definitions needed to compute $\properties(p)$.

\paragraph{Observational semantics without reduction}
The definitions above constitute the complete semantics of
Overlay-Calculus. There are no reduction rules, no evaluation contexts,
and no small-step or big-step judgments. In the $\lambda$-calculus, a term such as
$(\lambda x.\, x)\; y$ must be \emph{reduced} to $y$ before its
meaning is apparent; the operational semantics specifies how and in what
order reductions occur. In Overlay-Calculus, an inheritance tree such as
$\{a \mapsto \{\},\; b \mapsto \{\}\}$ does not reduce to
anything: it \emph{is} the value. The functions $\properties$,
$\supers$, etc.\ determine what is observable at each path, and that is
all. Computation arises not from rewriting terms but from querying an
inductively deeper path in a lazily constructed tree: the observer
drives the computation by choosing which path to inspect, and the
mutually recursive definitions unfold on demand.
Formally, the mutually recursive equations
(\ref{eq:properties})--(\ref{eq:this}) define set membership
\emph{inductively}: $\ell \in \properties(p)$ holds if and only if
it can be established by a finite chain of applications of these
equations.  The corresponding operator on the product lattice of
path sets is monotone, and its least fixed point
exists by the Knaster--Tarski theorem~\cite{tarski1955lattice}.
The detailed well-definedness argument (identifying the lattice,
verifying positivity of each equation, and handling the transitive
closure $\bases^*$) is given in Appendix~\ref{app:well-definedness}.
When no finite derivation exists for a given query, the
membership is not in this least fixed point and the semantics is
undefined at that point, analogous to divergence in the
$\lambda$-calculus, and the expected consequence of Turing
completeness.
This observation model
is inspired by F-coalgebras~\cite{rutten2000universal}, where
identity is determined by observable behavior rather than by internal
structure.

\section{Embedding the $\lambda$-Calculus}
\label{sec:translation}

The following translation maps the $\lambda$-calculus in
A-normal form (ANF)~\cite{flanagan1993essence} to Overlay-Calculus.
In ANF, every intermediate result is bound to a name and each
expression contains at most one application:
\[
  \begin{array}{r@{\;::=\;}l}
    M & \mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M
    \mid V_1\; V_2
    \mid V \\
    V & x \mid \lambda x.\, M
  \end{array}
\]
Every $\lambda$-term can be mechanically converted to ANF by
naming intermediate results, and every ANF term is a
$\lambda$-term, so ANF is neither a restriction nor an
extension of the $\lambda$-calculus.
The ANF structure matches Overlay-Calculus naturally: each
$\mathbf{let}$-binding becomes a named record property, and
each application is wrapped and projected via
$.\mathrm{result}$.

Let $\mathcal{T}$ denote the translation function.
Each $\lambda$-abstraction introduces one scope level
in the translated overlay tree.

\medskip
\begin{center}
  \begin{tabular}{l@{\qquad$\longrightarrow$\qquad}l}
    $x$ \text{\small($\lambda$-bound, index $n$)} &
    $\dbi{n}.\mathrm{argument}$ \\[4pt]
    $x$ \text{\small(let-bound)} &
    $x.\mathrm{result}$ \\[4pt]
    $\lambda x.\, M$ &
    $\{\mathrm{argument} \mapsto \{\},\;
    \mathrm{result} \mapsto \mathcal{T}(M)\}$ \\[4pt]
    $\mathbf{let}\; x = V_1\; V_2
    \;\mathbf{in}\; M$ &
    $\{x \mapsto \{\mathcal{T}(V_1),\;
      \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto \mathcal{T}(M)\}$ \\[4pt]
    $V_1\; V_2$ \text{\small(tail call)} &
    $\{\_\mathrm{tail} \mapsto \{\mathcal{T}(V_1),\;
      \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto \_\mathrm{tail}.\mathrm{result}\}$
  \end{tabular}
\end{center}
\medskip

A $\lambda$-bound variable $x$ with de~Bruijn index $n$
(the number of enclosing $\lambda$s between
the reference and its binder) becomes
$\dbi{n}.\mathrm{argument}$,
which reaches the abstraction that binds $x$ and
accesses its $\mathrm{argument}$ slot.
A let-bound variable $x$ becomes the lexical reference
$x.\mathrm{result}$, projecting the application result
from the sibling property $x$ in the enclosing record.

An abstraction $\lambda x.\, M$ translates to a record with own
properties $\{\mathrm{argument}, \mathrm{result}\}$; we call this
the \emph{abstraction shape}.
In the $\mathbf{let}$-binding rule, the name $x$ binds to the
inherited record $\{\mathcal{T}(V_1),\;
\mathrm{argument} \mapsto \mathcal{T}(V_2)\}$, and
$\mathcal{T}(M)$ may reference $x.\mathrm{result}$ to obtain
the value of the application.
In the tail-call rule, the fresh label $\_\mathrm{tail}$ serves
the same purpose, and $\mathrm{result}$ projects the answer.
In both cases the inheritance that performs the application is
\emph{encapsulated} behind a named property, so its internal
structure (the $\mathrm{argument}$ and $\mathrm{result}$ labels
of the callee) does not leak to the enclosing scope.

The five rules above are a complete translation from the
$\lambda$-calculus (via ANF) to Overlay-Calculus: every ANF
term has an image, and the construction is compositional.
Since the $\lambda$-calculus is Turing complete, so is
Overlay-Calculus.

\paragraph{An elementary semantics of the $\lambda$-calculus}
Composing the translation $\mathcal{T}$ with the semantic
functions of Section~\ref{sec:overlay-trees} induces a semantics
on the $\lambda$-calculus itself.
Given a $\lambda$-term $M$, one translates it to
$\mathcal{T}(M)$ and then determines convergence behavior by
querying $\ell \in \properties(p)$ via
equations~(\ref{eq:properties})--(\ref{eq:this}), following the
$\mathrm{result}$ chain until the abstraction shape appears or
the fixed point yields the empty set.

This induced semantics is more elementary than traditional
approaches in the mathematical machinery it requires:
\begin{itemize}
  \item \emph{No function spaces.}
    Scott's denotational semantics~\cite{scott1976data} constructs a
    reflexive domain $D$ satisfying $D \cong [D \to D]$ via an
    inverse limit in a category of continuous lattices.
    Here, the semantic domain is a product of powerset
    lattices, with no function spaces, no continuity conditions,
    and no inverse limits.
    The only fixed-point construction is Knaster--Tarski on
    powerset lattices
    (Appendix~\ref{app:well-definedness}), which requires
    only set-theoretic monotonicity, which is strictly weaker than
    Scott continuity.
  \item \emph{No substitution.}
    Operational semantics defines $\beta$-reduction via
    capture-avoiding substitution, a mechanism whose subtleties
    motivated de~Bruijn indices~\cite{debruijn1972lambda} and
    explicit substitution calculi.
    Here, variable references are resolved by the $\this$
    function walking the inheritance tree; no substitution
    occurs at any point.
  \item \emph{No reduction rules.}
    There are no $\beta$-reduction steps, no evaluation
    contexts, and no choice between call-by-name and
    call-by-value~\cite{plotkin1975callbyname}.
    The semantics is observational: one queries path
    membership, and the mutually recursive equations unfold
    on demand.
\end{itemize}
The key step is that function application is
encoded as record inheritance, and the resulting record is
observed through path queries rather than applied as a function;
no function spaces are required.
Section~\ref{sec:bohm-tree} shows that the convergence behavior
of the translated overlay tree corresponds exactly to the
B\"ohm tree~\cite{barendregt1984lambda} of the original term:
the translation is adequate (a term converges iff it has a head
normal form) and fully abstract (two terms are
  overlay-contextually equivalent iff they have the same B\"ohm
tree).

Combining these two facts, elementary machinery and full
abstraction, yields a noteworthy consequence:
\emph{the lazy $\lambda$-calculus admits a fully abstract
semantics that lives entirely in naive set theory.}
The only mathematical prerequisites are powerset lattices,
set-theoretic monotonicity, and the Knaster--Tarski
fixed-point theorem.
No continuous lattices, no inverse limits, no Scott topology,
no game-theoretic machinery.
Scott's $D_\infty$ model~\cite{scott1976data} uses heavier
machinery yet is only adequate, not fully
abstract~\cite{plotkin1975callbyname};
Abramsky and McCusker's game semantics~\cite{abramsky1995games} achieves
full abstraction but at the cost of even greater
mathematical complexity.
The overlay tree semantics achieves full abstraction with
strictly simpler foundations than either.

The reverse direction is non-trivial, as we discuss next.

\subsection{Expressive Asymmetry}
\label{sec:asymmetry}

The translation above consists of five rules; the full computational
power of the $\lambda$-calculus embeds into Overlay-Calculus with no
additional machinery.

The reverse direction, encoding Overlay-Calculus in pure
$\lambda$-calculus, is non-trivial.
Defining the meaning of Overlay-Calculus requires machinery for
lazy allocation, recursive data structures, and set-valued
resolution that have no direct counterparts in the $\lambda$-calculus.
This sophistication is not accidental; it reflects three features:

\begin{enumerate}
  \item \textbf{Self-referential records with lazy evaluation.}
    An overlay's properties can reference other properties and enclosing scopes
    through qualified this without explicit binding.
    In the $\lambda$-calculus, encoding such self-referential
    structures requires explicit allocation of mutable or lazy
    references (e.g., Haskell-style thunks or ML-style \texttt{ref}
    cells), obscuring the declarative intent.

  \item \textbf{Open recursion with symmetric inheritance.}
    Inheritance merges definitions from independent sources,
    all sharing the same inherited overlay tree. Encoding this in
    the $\lambda$-calculus requires maintaining an extensible dictionary
    of methods that can be merged from multiple directions. Cook's
    denotational semantics of inheritance~\cite{cook1989denotational}
    devoted an entire dissertation to formalizing this pattern in a
    functional setting.

  \item \textbf{Commutative, idempotent merge.}
    Inheritance in Overlay-Calculus is symmetric:
    a record's elements form a set, so reordering them produces
    the same observable result. In the $\lambda$-calculus, function composition
    $(f \circ g)$ is neither commutative nor idempotent, and simulating
    these properties requires additional machinery.
\end{enumerate}

\noindent
Overlay-Calculus is not the $\lambda$-calculus in disguise:
it provides primitive operations for computational patterns that are
\emph{derivable but complex} in the $\lambda$-calculus.

The reverse asymmetry also exists: nested expressions such as
$f\;(g\;x)$ are primitive in the $\lambda$-calculus but require
manual A-normal form conversion in Overlay-Calculus, since the
intermediate result $g\;x$ must be given an explicit name.
However, ANF conversion is a mechanical
transformation~\cite{flanagan1993essence}; a surface language built
on Overlay-Calculus can support nested expressions as syntactic
sugar without extending the calculus itself.

\subsection{B\"ohm Tree Correspondence}
\label{sec:bohm-tree}

The translation $\mathcal{T}$ induces a semantics on the $\lambda$-calculus
via the overlay tree equations~(\ref{eq:properties})--(\ref{eq:this}).
We show that the induced semantics corresponds precisely to the
B\"ohm tree~\cite{barendregt1984lambda} of the original $\lambda$-term.

An overlay tree $T$ \emph{converges}, written $T{\Downarrow}$,
if following finitely many $\mathrm{result}$ projections from
the root reaches a node with both $\mathrm{argument}$ and
$\mathrm{result}$ among its properties, that is, the \emph{abstraction shape}
produced by $\mathcal{T}(\lambda x.\, M)$.
We write $T{\Uparrow}$ if no such depth exists.

\begin{definition}[Overlay-convergence]\label{def:convergence}
  An overlay tree $T$ \emph{converges}, written $T{\Downarrow}$,
  if there exists $n \ge 0$ such that:
  \[
    \{\mathrm{argument},\, \mathrm{result}\}
    \;\subseteq\;
    \properties\!\bigl(\,
      \underbrace{\text{root} \snoc \mathrm{result}
      \snoc \cdots \snoc \mathrm{result}}_{n}
    \,\bigr)
  \]
  in the least fixed point of
  Section~\ref{sec:overlay-trees}.
\end{definition}

\begin{theorem}[Adequacy]\label{thm:adequacy}
  A closed ANF $\lambda$-term $M$ has a head normal form if and
  only if $\mathcal{T}(M){\Downarrow}$.
\end{theorem}

\begin{theorem}[Full Abstraction]\label{thm:full-abstraction}
  For closed $\lambda$-terms $M$ and $N$, define
  $\mathcal{T}(M) \approx \mathcal{T}(N)$ iff for every
  closing context $C[\cdot]$,
  $\mathcal{T}(C[M]){\Downarrow} \Leftrightarrow
  \mathcal{T}(C[N]){\Downarrow}$.
  Then:
  \[
    \mathcal{T}(M) \approx \mathcal{T}(N)
    \quad\Longleftrightarrow\quad
    \mathrm{BT}(M) = \mathrm{BT}(N)
  \]
\end{theorem}

\noindent
Together, Adequacy and Full Abstraction establish that
the overlay tree semantics is a computation mechanism for
B\"ohm trees~\cite{barendregt1984lambda}, the canonical fully
abstract model of the lazy $\lambda$-calculus, using only
powerset lattices and the Knaster--Tarski fixed-point theorem,
without the topological infrastructure of domain theory.
This is stronger than Scott's denotational
semantics~\cite{scott1976data,wadsworth1976semantics}, which is
adequate but not fully abstract, as it identifies terms that
observational equivalence
distinguishes~\cite{plotkin1975callbyname}.
The full proof, including the Single-Path Lemma,
Substitution Lemma, and Convergence Preservation, is given
in Appendix~\ref{app:bohm-tree-proofs}.

\section{Case Study: Nat Arithmetic}
\label{sec:case-study}
\label{sec:expression-problem}

We implemented boolean logic and natural number arithmetic (both unary
and binary) as overlay
files\selfcite{~\cite{mixin2025}}{~(supplementary material)}.
This section traces the unary Nat case in detail.
The implementation follows a declarative object-oriented style:
each concern is one file;
UpperCamelCase names are constructors and operations;
lowerCamelCase names are fields and parameters;
and since there are no methods, all names are nouns or adjectives: $\mathrm{Plus}$
is a structure, not an action.
Operations expose their result through a projection field (e.g., $\mathrm{sum}$).

\paragraph{NatData.}
Following the Church-encoding
convention\selfcite{~\cite{mixin2025}}{~(supplementary material)},
we define a factory containing the abstract product type and its two
constructors.
A $\mathrm{Zero}$ value inherits $\mathrm{Product}$;
a $\mathrm{Successor}$ value inherits $\mathrm{Product}$ and
exposes a $\mathrm{predecessor}$ field.
The file name $\mathrm{NatData}$ is itself the top-level scope:
\begin{align*}
  \mathrm{NatData} \mapsto \{\;&
    \mathrm{NatFactory} \mapsto \{
      \mathrm{Product} \mapsto \{\},\\
    &\quad
      \mathrm{Zero} \mapsto \{\mathrm{Product}\},\\
    &\quad
      \mathrm{Successor} \mapsto \{
        \mathrm{Product},\;
        \mathrm{predecessor} \mapsto \{\mathrm{Product}\}\}\},\\
    &\mathrm{Nat} \mapsto \{\mathrm{NatFactory},\;
      \mathrm{NatFactory}.\mathrm{Product}\}\}
\end{align*}

\paragraph{NatPlus.}
Addition is a separate overlay file that inherits $\mathrm{NatData}$
and extends each constructor with a $\mathrm{Plus}$ operation
exposing a $\mathrm{sum}$ field.
The base case is $0 + m = m$; the recursive case reduces
$\mathrm{S}(n_0) + m$ to $n_0 + \mathrm{S}(m)$
by delegating to $n_0$'s $\mathrm{Plus}$ with an incremented addend:
\begin{align*}
  \mathrm{NatPlus} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{NatFactory} \mapsto \{\\
    &\quad \mathrm{Product} \mapsto \{\mathrm{Plus} \mapsto \{
      \mathrm{sum} \mapsto \{\mathrm{Product}\}\}\},\\[2pt]
    &\quad \mathrm{Zero} \mapsto \{\mathrm{Plus} \mapsto \{
      \mathrm{addend} \mapsto \{\mathrm{Product}\},\;
      \mathrm{sum} \mapsto \{\mathrm{addend}\}\}\},\\[2pt]
    &\quad \mathrm{Successor} \mapsto \{\mathrm{Plus} \mapsto \{
      \mathrm{addend} \mapsto \{\mathrm{Product}\},\\
    &\qquad
      \mathrm{\_increasedAddend} \mapsto \{
        \mathrm{Successor},\;
        \mathrm{predecessor} \mapsto \{\mathrm{addend}\}\},\\
    &\qquad
      \mathrm{\_recursiveAddition} \mapsto \{
        \qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}.\mathrm{Plus},\\
    &\qquad\quad
        \mathrm{addend} \mapsto \{\mathrm{\_increasedAddend}\}\},\\
    &\qquad
      \mathrm{sum} \mapsto \{
        \mathrm{\_recursiveAddition}.\mathrm{sum}\}\}\}\}\}
\end{align*}

\paragraph{NatEquality.}
To test that $2 + 3 = 5$, we needed equality on Nat values.
Equality requires case analysis on the constructor; we use the
Visitor pattern.
$\mathrm{NatVisitor}$ adds a $\mathrm{Visitor}$ operation to each constructor,
with a $\mathrm{Visit}$ field that delegates to the appropriate
$\mathrm{VisitZero}$ or $\mathrm{VisitSuccessor}$ branch:
\begin{align*}
  \mathrm{NatVisitor} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{NatFactory} \mapsto \{\\
    &\quad \mathrm{Product} \mapsto \{\mathrm{Visitor} \mapsto \{
      \mathrm{Visit} \mapsto \{\}\}\},\\[2pt]
    &\quad \mathrm{Zero} \mapsto \{\mathrm{Visitor} \mapsto \{
      \mathrm{VisitZero} \mapsto \{\},\;
      \mathrm{Visit} \mapsto \{\mathrm{VisitZero}\}\}\},\\[2pt]
    &\quad \mathrm{Successor} \mapsto \{\mathrm{Visitor} \mapsto \{
      \mathrm{VisitSuccessor} \mapsto \{\},\;
      \mathrm{Visit} \mapsto \{\mathrm{VisitSuccessor}\}\}\}\}\}
\end{align*}
$\mathrm{BooleanData}$ defines the output sort:
\begin{align*}
  \mathrm{BooleanData} \mapsto \{\;&
    \mathrm{BooleanFactory} \mapsto \{
      \mathrm{Product} \mapsto \{\},\;
      \mathrm{True} \mapsto \{\mathrm{Product}\},\;
      \mathrm{False} \mapsto \{\mathrm{Product}\}\},\\
    &\mathrm{Boolean} \mapsto \{\mathrm{BooleanFactory},\;
      \mathrm{BooleanFactory}.\mathrm{Product}\}\}
\end{align*}
$\mathrm{NatEquality}$ inherits $\mathrm{NatVisitor}$ and $\mathrm{BooleanData}$,
and adds an $\mathrm{Equal}$ operation to each constructor.
$\mathrm{Zero}$ is equal only to another $\mathrm{Zero}$;
$\mathrm{Successor}$ is equal only to another $\mathrm{Successor}$
with an equal predecessor.
Case analysis on $\mathrm{other}$ is done via its $\mathrm{Visitor}$:
{\small
\begin{align*}
  \mathrm{NatEquality} \mapsto \{\;&
    \mathrm{NatVisitor},\; \mathrm{BooleanData},\\
    &\mathrm{NatFactory} \mapsto \{\\
    &\quad \mathrm{Product} \mapsto \{\mathrm{Equal} \mapsto \{
      \mathrm{other} \mapsto \{\mathrm{Product}\},\\
    &\qquad
      \mathrm{equal} \mapsto \{
        \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\[2pt]
    &\quad \mathrm{Zero} \mapsto \{\mathrm{Equal} \mapsto \{
      \mathrm{other} \mapsto \{\mathrm{Product}\},\\
    &\qquad
      \mathrm{OtherVisitor} \mapsto \{
        \mathrm{other}.\mathrm{Visitor},\\
    &\qquad\;
        \mathrm{VisitZero} \mapsto \{
          \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{True}\}\},\\
    &\qquad\;
        \mathrm{VisitSuccessor} \mapsto \{
          \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{False}\}\},\\
    &\qquad\;
        \mathrm{Visit} \mapsto \{
          \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\
    &\qquad
      \mathrm{equal} \mapsto \{
        \mathrm{OtherVisitor}.\mathrm{Visit}.\mathrm{equal}\}\}\},\\[2pt]
    &\quad \mathrm{Successor} \mapsto \{\mathrm{Equal} \mapsto \{
      \mathrm{other} \mapsto \{
        \mathrm{Product},\;
        \mathrm{predecessor} \mapsto \{\mathrm{Product}\}\},\\
    &\qquad
      \mathrm{RecursiveEquality} \mapsto \{
        \qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}.\mathrm{Equal},\\
    &\qquad\;
        \mathrm{other} \mapsto \{
          \qualifiedthis{\mathrm{Equal}}.\mathrm{other}.\mathrm{predecessor}\}\},\\
    &\qquad
      \mathrm{OtherVisitor} \mapsto \{
        \mathrm{other}.\mathrm{Visitor},\\
    &\qquad\;
        \mathrm{VisitZero} \mapsto \{
          \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{False}\}\},\\
    &\qquad\;
        \mathrm{VisitSuccessor} \mapsto \{
          \mathrm{equal} \mapsto \{
            \mathrm{RecursiveEquality}.\mathrm{equal}\}\},\\
    &\qquad\;
        \mathrm{Visit} \mapsto \{
          \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\
    &\qquad
      \mathrm{equal} \mapsto \{
        \mathrm{OtherVisitor}.\mathrm{Visit}.\mathrm{equal}\}\}\}\}\}
\end{align*}}
Composing $\mathrm{NatPlus}$ with $\mathrm{NatEquality}$ by
inheriting both, with no modifications to either file, gives the
resulting Nat values both $\mathrm{Plus}$ and $\mathrm{Equal}$
automatically.
The concrete numerals live in a shared file that inherits only $\mathrm{NatData}$:
\begin{align*}
  \mathrm{NatConstants} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{One} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
    &\quad\quad
      \mathrm{predecessor} \mapsto \{
        \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Zero}\}\},\\
    &\mathrm{Two} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
    &\quad\quad
      \mathrm{predecessor} \mapsto \{\mathrm{One}\}\},\\
    &\mathrm{Three} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
    &\quad\quad
      \mathrm{predecessor} \mapsto \{\mathrm{Two}\}\},\\
    &\mathrm{Four} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
    &\quad\quad
      \mathrm{predecessor} \mapsto \{\mathrm{Three}\}\},\\
    &\mathrm{Five} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
    &\quad\quad
      \mathrm{predecessor} \mapsto \{\mathrm{Four}\}\}\}
\end{align*}
The arithmetic test inherits $\mathrm{NatConstants}$ together with the operations it needs:
\begin{align*}
  \mathrm{Test} \mapsto \{\;&
    \mathrm{NatConstants},\; \mathrm{NatPlus},\; \mathrm{NatEquality},\\
    &\mathrm{Addition} \mapsto \{
      \qualifiedthis{\mathrm{Test}}.\mathrm{Two}.\mathrm{Plus},\;
      \mathrm{addend} \mapsto \{\qualifiedthis{\mathrm{Test}}.\mathrm{Three}\}\},\\
    &\mathrm{Test2plus3} \mapsto \{
      \qualifiedthis{\mathrm{Test}}.\mathrm{Five}.\mathrm{Equal},\;
      \mathrm{other} \mapsto \{\mathrm{Addition}.\mathrm{sum}\}\}\}
\end{align*}
Querying $\mathrm{Test}.\mathrm{Test2plus3}.\mathrm{equal}$ via the host-language API
returns $\mathrm{True}$.
No existing file was modified.
$\mathrm{NatEquality}$ (a new operation) and $\mathrm{Boolean}$
(a new data type) each required only a new file: extensibility in both
dimensions of the Expression Problem~\cite{wadler1998expression}.

\paragraph{Tree-level inheritance and return types.}
\label{sec:discussion-expression-problem}
Each operation is an independent overlay that extends a factory's
subtree.
Inheritance recursively merges subtrees that share a label,
so every entity in the factory acquires all operations from all
inherited overlays.
Crucially, this applies to return types: $\mathrm{NatPlus}$ returns
values from $\mathrm{NatFactory}$, and $\mathrm{NatEquality}$
independently adds $\mathrm{Equal}$ to the same factory.
Inheriting both causes the values returned by $\mathrm{Plus}$ to
carry $\mathrm{Equal}$ automatically, without modifying either file.
In object algebras~\cite{oliveira2012extensibility} and finally
tagless interpreters~\cite{carette2009finally}, independently defined
operations do not automatically enrich each other's return types;
additional boilerplate or type-class machinery is required.

Multi-path qualified this (equation~\ref{eq:this}) is essential.
In the test file above, $\mathrm{NatPlus}.\mathrm{Successor}$ and
$\mathrm{NatEquality}.\mathrm{Successor}$ both inherit
$\mathrm{NatData}.\mathrm{Successor}$.
When the two operations are composed, the resulting
$\mathrm{Successor}$ inherits the $\mathrm{NatData}$ schema
through two independent routes.
The reference
$\qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}$
inside each operation resolves through both routes, and since
inheritance is idempotent, all routes contribute the same
properties.
In Scala, the same pattern, where two independently defined inner
classes extend the same outer class's trait, triggers a
``conflicting base types'' rejection
(Appendix~\ref{app:scala-multi-path}), because DOT's self variable
is single-valued and cannot resolve through multiple inheritance
routes simultaneously.
The Expression Problem can still be \emph{solved} in Scala using
object algebras or similar patterns, but composing independently
defined operations inherently produces multi-path inheritance to
shared schemas, which DOT's single-valued self variable cannot
accommodate.

\paragraph{Church-encoded Nats are tries.}
A Church-encoded Nat is a record whose structure mirrors the
constructor path used to build it: $\mathrm{Zero}$ is a flat record;
$\mathrm{S}(\mathrm{Zero})$ is a record with a $\mathrm{predecessor}$
field pointing to a $\mathrm{Zero}$ record; and so on.
This is exactly the shape of a trie.
A scope that simultaneously inherits two Nat values is a trie union.
The following test applies $\mathrm{Plus}$ to a trie union of $\{1,2\}$
with addend a trie union of $\{3,4\}$, then compares the result to itself
with $\mathrm{Equal}$:
\begin{align*}
  \mathrm{CartesianTest} \mapsto \{\;&
    \mathrm{NatConstants},\; \mathrm{NatPlus},\; \mathrm{NatEquality},\\
    &\mathrm{OneOrTwo} \mapsto \{
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{One},\;
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Two}\},\\
    &\mathrm{ThreeOrFour} \mapsto \{
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Three},\;
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Four}\},\\
    &\mathrm{Result} \mapsto \{
      \mathrm{OneOrTwo}.\mathrm{Plus},\;
      \mathrm{addend} \mapsto \{\mathrm{ThreeOrFour}\}\},\\
    &\mathrm{Check} \mapsto \{
      \mathrm{Result}.\mathrm{sum}.\mathrm{Equal},\;
      \mathrm{other} \mapsto \{\mathrm{Result}.\mathrm{sum}\}\}\}
\end{align*}
$\mathrm{Result}.\mathrm{sum}$ evaluates to the trie $\{4,5,6\}$, the set of all pairwise sums.
$\mathrm{Equal}$ then applies to every pair drawn from $\{4,5,6\} \times \{4,5,6\}$;
querying $\mathrm{CartesianTest}.\mathrm{Check}.\mathrm{equal}$ via the host-language API
returns $\{\mathrm{True}, \mathrm{False}\}$.
The same $\mathrm{Plus}$ and $\mathrm{Equal}$ files that operate on
single values produce, without modification, the Cartesian-product
semantics of relational programming (Datalog, Prolog):
$\overlays$ and $\supers$ collect all inheritance paths, and
every operation distributes over them.

\section{Discussion}

\subsection{Classification of Semantic Variants}
\label{sec:semantic-variants}

The goals of declarative programming rule out
several properties of the model:
separate primitives for methods, classes, types, and objects;
mutable reference cells;
domain-theoretic approximation;
and asymmetric override.
Ruling these out leaves a minimal syntax of three constructs:
records, definitions, and inheritance.

Two degrees of freedom remain.
These dimensions are independent, and each combination yields a coherent semantics.
They arise in any system whose definitions form a tree of named
scopes, where each node is a path and references are
path-dependent, even in systems ruled out above, such as Scala,
which has separate primitives for methods, classes, objects, and types.

Existing designs occupy several of the resulting cells:

\begin{center}
\begin{tabular}{lll}
  & \textbf{No deep merge} & \textbf{Deep merge} \\
  \hline
  \textbf{Early binding}
  & ---
  & CUE~\cite{cue2019} \\
  \textbf{Dynamic scope}
  & ---
  & union file systems, Jsonnet~\cite{jsonnet} \\
  \textbf{Lexical scope}
  & Scala~\cite{odersky2004overview}
  & NixOS modules~\cite{nixosmodules} \\
  \textbf{Multi-target} $\this$
  & ---
  & Overlay-Calculus \\
\end{tabular}
\end{center}

\paragraph{Early binding}
With early binding, references resolve at definition time to a
fixed path, independently of how the record is later inherited.
CUE~\cite{cue2019} exemplifies this: field references are
statically resolved, and a field in a nested record cannot refer
back to properties of its enclosing context contributed by later
composition.
Early binding combined with deep merge is coherent and
practically useful, but cross-overlay cooperation requires
explicit wiring rather than inheritance: a definition cannot
observe properties contributed by overlays composed after it.

\paragraph{Dynamic scope}
With dynamic scope, references resolve against the context at
the point of use rather than the definition site.
Early Lisp implementations used dynamic scope~\cite{mccarthy1978history},
where variable references are resolved against the run-time call stack.
Union file systems exhibit the same property at the file-system
level: a symbolic link's relative path resolves against the mount
context at dereference time, not against the layer that defined
the link.
Jsonnet~\cite{jsonnet} follows this approach: \texttt{self} always
refers to the final merged object, not the object at the definition
site.
When the Scala multi-path example (Appendix~\ref{app:scala-multi-path})
is translated to Jsonnet, it does not error, but \texttt{outer}
resolves to the merged \texttt{MyObjectA} rather than to
\texttt{Object1} or \texttt{Object2} separately, silently discarding
the distinction between the two inheritance routes.
Dynamic scope is flexible but loses the ability to track
which inheritance route a reference came from.

\paragraph{Deep merge}
Without the second case of equation~(\ref{eq:overlays}),
$\overlays(p)$ would always return $\{p\}$, a single
element.
When two independently authored overlays both define a label
with the same name at the same scope level, only the
definition at the literal path~$p$ would contribute to
$\supers$ and hence to $\properties$; the other definitions
would be silently invisible.
This is the situation in most composition systems:
pytest permits at most one fixture per name per scope;
trait systems~\cite{scharli2003traits} flag same-name
methods as conflicts.
Under any of these rules, two independently authored overlays
that both extend an entity with the same name, which is the situation
that arises naturally when solving the Expression
Problem~\cite{wadler1998expression}, cannot be composed.
The non-trivial case of equation~(\ref{eq:overlays}) removes
this limitation: it collects all paths that share the same
label and merges their definitions rather than shadowing each other.
This is the record-level counterpart of method override in
object-oriented languages, and the mechanism by which the calculus
admits extensibility in both dimensions of the Expression
Problem~\cite{wadler1998expression}
(Section~\ref{sec:expression-problem}).

\paragraph{Multi-target qualified this}
The qualified this reference $\this$ answers the question:
``in the fully inherited tree, where does
the definition-site scope $p_{\mathrm{def}}$ actually live?''
Scheme~\cite{sussman1975scheme} introduced lexical scope,
where a de~Bruijn index resolves in a single step by indexing
into the statically determined environment;
this is predictable but rigid.
Scala~\cite{odersky2004overview} and the NixOS module
system~\cite{nixosmodules} follow the lexical approach:
each \texttt{this} reference is bound to a single
statically known path.
When inheritance introduces multiple inheritance routes
to the same scope, Scala rejects the ambiguity at compile time
(Appendix~\ref{app:scala-multi-path})
and the NixOS module system rejects the duplicate option
declaration (Appendix~\ref{app:scala-multi-path}); neither
can express that all routes are equally valid.

Overlay-Calculus combines the predictability of lexical scope
with the flexibility of dynamic scope.
The reference itself is lexically determined at the definition site
as a de~Bruijn index, so what $\this$ looks up is predictable.
But because inheritance interleaves scopes from
different overlays, the result depends on the inherited tree
structure: $\this$ walks upward one scope level at a time,
consulting $\supers$ at each level, and naturally tracks a
\emph{set} of inheritance-site paths rather than a single one.
All routes contribute equally to the inherited result, and since
inheritance is idempotent, duplicated contributions are harmless.
The only observable is property presence, making
multi-path resolution well-defined without disambiguation.

Our first three implementations of the Overlay language used
standard techniques for self-reference resolution: closure-based
fixed points following Cook~\cite{cook1989denotational}, and
stack-based environment lookup using de~Bruijn
indices~\cite{debruijn1972lambda}.
All three produced subtle bugs when inheritance introduced
multiple routes to the same enclosing scope.
The difficulty was structural, not incidental:
a closure captures a single environment, so a fixed-point
combinator solves for a single self-reference; a stack-based
environment is a linear chain where each scope level has one
parent.
Both data structures embed a single-valued assumption
incompatible with the multi-path situation that multiple
inheritance naturally produces
(Appendix~\ref{app:scala-multi-path}).
Equation~(\ref{eq:this}) emerged from abandoning this
assumption: it tracks a \emph{frontier set}~$S$ rather than a
single current scope.
If the equations were restricted to single-target resolution
(as in DOT's single-valued self
variable~\cite{amin2016dot}), they would need to reject
structurally legitimate cases, adding complexity rather than
removing it.

\paragraph{Consequences of the alternative choices}
Choosing differently in any dimension requires
introducing machinery that is absent from the equations
of Section~\ref{sec:overlay-trees}.
With early binding, the equations must freeze reference targets
at definition time, so a definition cannot observe properties
contributed by later-composed overlays.
With dynamic scope, the equations must resolve references
against a runtime context rather than the definition-site
structure, losing the ability to distinguish inheritance routes.
Restricting $\overlays(p)$ to $\{p\}$ means same-label
definitions from different inheritance sources no longer
share identity, requiring either a method resolution order
(MRO)~\cite{c3linearization} to linearize them or a
shadowing rule to select one and discard the rest, which is
why systems without deep merge rarely support
path-dependent multiple inheritance in practice.
Restricting $\this$ to a single path requires a mechanism to
select among inheritance routes (Scala rejects the ambiguity
at compile time; the NixOS module system raises a
duplicate-declaration error), and loses contributions from
all non-selected routes.
These mechanisms, including early-binding freezing, runtime context
threading, MRO, shadowing, route selection, and error
reporting, are more artificial than their absence.
The equations of Section~\ref{sec:overlay-trees} contain
none of them.

\subsection{Relationship to Practical Systems}

Several classes of declarative systems that have emerged independently
in practice turn out to be instances of Overlay-Calculus.

\subsubsection{Configuration and Object-Oriented Languages}
\label{sec:practical-config}
The NixOS module system~\cite{dolstra2010nixos,nixosmodules}, whose
recursive attribute merging motivated this work, can be understood as an
implementation of Overlay-Calculus with additional features (type checking,
error reporting, FFI to the Nix language).
Detailed comparisons with CUE, Jsonnet, Dhall, with mixin and
trait calculi, and with the NixOS module system's lazy evaluation
limitations under multiple inheritance routes are given in
Section~\ref{sec:related-work}.

\subsubsection{Function Color Blindness}
\label{sec:practical-function-color}
We implemented a web application as overlay
files\selfcite{~\cite{mixin2025}}{~(supplementary material)},
initially targeting Python's synchronous \texttt{sqlite3} and
\texttt{http.server} modules.
The business logic overlay file contained no async-specific code.
Later, we replaced the FFI layer with one built on
\texttt{aiosqlite} and \texttt{starlette}; the business logic
overlay file did not change.
This is an instance of function color
blindness~\cite{nystrom2015color}: async and sync functions are
distinct types in the host language, yet the overlay file is
agnostic to the distinction because its empty property slots
are filled at assembly time, with coroutine handlers under
\texttt{asyncio}, or with direct implementations under
synchronous execution.
More generally, empty slots can be filled with effect
handlers~\cite{plotkin2003algebraic,pretnar2015introduction}
(CPS interpretation) or direct implementations (direct-style
interpretation), without explicit monad machinery.

\subsubsection{Modular Software Architectures}
\label{sec:practical-modular}
Plugin systems, component frameworks, and dependency injection frameworks
enable software extensibility through declarative inheritance. The
symmetric, associative nature of inheritance (Section~\ref{sec:overlay-trees}) explains why such
systems work: components can be inherited in any order without changing
behavior. These systems implement Overlay-Calculus patterns ad hoc.

\subsubsection{Union File Systems}
\label{sec:practical-union-fs}
Union file systems (UnionFS, OverlayFS, AUFS) layer multiple directory
hierarchies to present a unified view. Their semantics resembles
Overlay-Calculus in that later layers override earlier layers and files from all
layers remain accessible, but without a formal foundation these systems
resort to ad-hoc choices: asymmetric inheritance, non-commutative
conflict resolution for scalar files, and no late-binding or dynamic
dispatch across layers.
We implemented Overlay-Calculus directly as a union file
system\selfcite{~\cite{ratarmount2025}}{~(included as supplementary material)},
obtaining late-binding semantics and dynamic dispatch for file lookups
with no additional mechanism beyond the three primitives.
In package managers, build systems, and OS distributions,
external toolchains transform configuration into file trees;
here, the file system serves as configuration to itself,
and the transformation is inheritance: a
\emph{file-system-as-compiler} in which the directory tree is
both the source program and the compilation target.

\section{Related Work}
\label{sec:related-work}

\paragraph{Minimal Turing-complete models}
Sch\"onfinkel~\cite{schonfinkel1924} and
Curry~\cite{curry1958combinatory} showed that the
$\lambda$-calculus reduces to three combinators $S$, $K$, $I$
($I$ is redundant: $I = SKK$).
The bracket abstraction that compiles $\lambda$-terms to SKI
is mechanical but incurs exponential blow-up in term size;
no new computational patterns emerge beyond those already
present in the $\lambda$-calculus.
Dolan~\cite{dolan2013mov} showed that the x86 \texttt{mov}
instruction alone is Turing complete by exploiting
addressing modes as implicit arithmetic on mutable memory;
the resulting programs are correct but provide no
abstraction mechanisms beyond those of the RAM Machine.
The Turing Machine itself, while universal, lacks random
access: reading a cell at distance~$d$ requires $d$
sequential tape movements.
Each of these models achieves Turing completeness by
\emph{removing} structure from an existing model:
fewer abstractions, worse ergonomics, no new expressiveness.
None of these reductions exhibits emergent phenomena
absent from the model it reduces.

\paragraph{Denotational semantics of inheritance}
Cook~\cite{cook1989denotational} gave the first denotational
semantics of inheritance, modeling objects as recursive records and
inheritance as composition of \emph{generators} (functions from self
to complete object) and \emph{wrappers} (functions that modify
generators), solved by a fixed-point construction.
Cook's key insight, that inheritance is a general mechanism
applicable to any form of recursive definition and not only
object-oriented methods, is one of the starting points of the
present work.
The model has four primitives (records, functions, generators,
wrappers) and requires a fixed-point combinator; composition is
asymmetric (a wrapper modifies a generator, not vice versa).

\paragraph{Mixin-based inheritance}
Bracha and Cook~\cite{bracha1990mixin} formalized mixins as
abstract subclasses, that is, functions from a superclass parameter to a
subclass, unifying the inheritance mechanisms of Smalltalk, Beta,
and CLOS under a single model.
Because mixin application is function composition, it is
\emph{neither commutative nor idempotent}: applying the same
mixin twice may produce different results, and applying two
mixins in different orders may yield different linearizations.
The C3 linearization algorithm~\cite{c3linearization} was later
developed to impose a deterministic order;
whether linearization is inherent to inheritance or an artifact of
non-commutativity had not been established.
Mixin composition operates at the \emph{method level}: applying a
mixin replaces or extends individual methods in a flat namespace.
There is no recursive merging of nested structure: composing two
mixins that define the same method name results in an override, not
deep merge.
Finally, mixins presuppose the $\lambda$-calculus as their
computational foundation: method bodies are functions, and mixin
application is function composition.
Mixins organize and compose functions but cannot replace
them; without the underlying $\lambda$-calculus, there is nothing
to compose.  The mixin mechanism itself is not Turing complete.

\paragraph{Traits}
Sch\"arli et al.~\cite{scharli2003traits} introduced traits as
composable units of behavior. Trait composition is symmetric and
commutative: the sum of two traits is order-independent, which is
a departure from mixin ordering.
However, when two traits provide methods with the
same name, a \emph{conflict} arises and must be explicitly resolved
by the programmer through exclusion or aliasing.
Ducasse et al.~\cite{ducasse2006traits} extended the model with a
\emph{flattening property}: the semantics of a class is independent
of whether its methods originate from traits or are defined directly.
Like mixins, trait composition is \emph{flat}: it operates on
individual method names, not on nested structures, so same-name
definitions are conflicts rather than recursive merges.
And like mixins, traits presuppose the $\lambda$-calculus: trait
methods are functions, and the computational power resides in those
functions, not in the trait mechanism itself.

\paragraph{Family polymorphism and virtual classes}
Ernst~\cite{ernst2001family} introduced family polymorphism, where
families of mutually dependent classes can be refined together in
subclasses. Ernst, Ostermann, and Cook~\cite{ernst2006virtual}
formalized this in the virtual class calculus, where classes are
class-valued attributes of objects, accessed via path expressions of
the form \texttt{this.out.C}.
The path \texttt{this.out} navigates to an enclosing scope, analogous
to qualified this ($\qualifiedthis{\ell_{\mathrm{up}}}$) in this paper.
A notable restriction is that each such path resolves to a
\emph{single} class in a \emph{single} enclosing object.
When multiple inheritance routes lead to the same scope, a common
situation under inheritance, single-valued resolution must choose
one route and discard the others, losing information.
The framework provides no mechanism for set-valued resolution.

\paragraph{Object calculi}
Abadi and Cardelli~\cite{abadi1996theory} developed a comprehensive
theory of objects, treating objects rather than classes as the
primitive notion. Their calculi include method update and
self-referential objects, but methods are fundamentally functions
(taking self as a parameter), and object extension is asymmetric
(method override replaces the previous definition).
Boudol~\cite{boudol2004recursive} studied the recursive record
semantics of objects in a call-by-value setting, showing that
self-referential records require an unsafe fixed-point operator.
Whether self-reference can be handled without a fixed-point operator
in the object language, for instance through coalgebraic
observation rather than reduction, was not explored in these calculi.

\paragraph{Record calculi}
Harper and Pierce~\cite{harper1991record} presented a record
calculus based on symmetric concatenation with a type system that
tracks the absence of fields.
When two records define the same label, concatenation
is undefined (a type error); the calculus leaves same-label
composition undefined.
Cardelli~\cite{cardelli1992extensible}
studied extensible records with subtyping;
R\'emy~\cite{remy1989type} gave a type system for records and
variants in ML.
These calculi operate on \emph{flat} records (no nesting) and
treat records as \emph{data} (initial algebras): a record is a
finite map from labels to values, fully determined at construction
time.  Nested records, self-reference, and lazy observation, which are the
properties needed for records to serve as a computational
substrate, are outside their scope.

\paragraph{DOT calculus}
Amin et al.~\cite{amin2016dot} formalized path-dependent types in
the DOT calculus, the theoretical foundation of Scala's type system.
DOT paths navigate through objects to reach nested type members,
providing a rich dependent type structure.
DOT's self variable in the object constructor $\nu(x : T)\, d$
binds $x$ to a single object; when multiple inheritance routes
lead to the same enclosing scope, the resulting intersection type
is unrealizable and Scala rejects it at compile time
(Appendix~\ref{app:scala-multi-path}).
DOT stratifies its syntax into terms and types, with types further
divided into abstract type members (bounded by $L..U$) and concrete
definitions; each stratum requires its own subtyping rules.
Whether these three roles could be unified under a single construct
remains an open question in the DOT line of work.
DOT includes the $\lambda$-calculus as a sub-language; removing it
while retaining path-dependent types would yield a calculus closer
to pure overlay inheritance
(see Section~\ref{sec:future-work}).

\paragraph{Configuration languages}
CUE~\cite{cue2019} unifies types and values in a single lattice
where unification (\texttt{\&}) is commutative, associative, and
idempotent.
CUE's design was motivated by Google's Borg Configuration
Language (GCL), which used graph unification.
CUE's lattice includes scalar types with a conflict
semantics (unifying incompatible scalars yields $\bot$); whether
scalars are necessary for a configuration language, or whether
tree structure alone suffices, is an interesting design question.
Jsonnet~\cite{jsonnet} provides object inheritance via the
\texttt{+} operator with mixin semantics: composition is
\emph{not} commutative (the right-hand side wins on scalar
conflicts), and deep merging requires explicit opt-in (\texttt{+:}
syntax) on a per-field basis, so deep merge is
available but not the default.
Dhall~\cite{dhall2017} takes a functional approach: it is a typed
$\lambda$-calculus with records, where composition is a record merge
operator, not an inheritance mechanism.

\paragraph{Module systems and deep merge}
The NixOS module system~\cite{dolstra2010nixos,nixosmodules}
composes modules by \emph{recursively merging nested attribute sets},
not by linearization or method-level override, which is the same overlay
semantics that distinguishes tree-level inheritance from mixin and
trait composition.
When two modules define the same nested path, their subtrees are
merged rather than overridden.
The NixOS module system incorporates deep merge,
recursive self-reference, deferred evaluation of modules, and a
rich type-checking layer on top.
The same mechanism powers
NixOS system configuration, Home
Manager~\cite{homemanager}, nix-darwin~\cite{nixdarwin},
flake-parts~\cite{flakeparts}, and dozens of other ecosystems,
collectively managing configurations of arbitrary complexity.
The one aspect that appears not to have been fully addressed is the
semantics of self-reference under multiple inheritance.
When two independent modules that inherit from the same
deferred module are composed, each import introduces its own
declaration of the shared options; the module system's
\texttt{merge\-Option\-Decls} rejects duplicate declarations
with a static error (Appendix~\ref{app:scala-multi-path}).
The module system cannot express that both routes contribute
equally to the same option, that is, the multi-path situation that
recursive merging naturally gives rise to, which motivated the
coalgebraic semantics of Section~\ref{sec:overlay-trees}.

\section{Future Work}
\label{sec:future-work}

\selfcite{The Overlay language~\cite{mixin2025}}{The supplementary
implementation} is an executable implementation of Overlay-Calculus
that already goes beyond the untyped calculus presented here:
it includes compile-time checking that all references resolve to
valid paths in the inheritance, and a foreign-function interface (FFI)
that introduces scalar values from the host language.
The future work described below concerns the distance between this
implementation and a fully practical language, spanning both
theoretical foundations and library-level encodings.

\paragraph{Type system}
The Overlay language's existing compile-time checks verify that every
reference path resolves to a property that exists in the inherited
result. Formalizing the soundness of these checks, that is, proving that
well-typed programs do not produce dangling references at
runtime, is one direction of future work.
Such a formalization would relate to the DOT
calculus~\cite{amin2016dot} in a manner analogous to how
Overlay-Calculus relates to the $\lambda$-calculus: a Typed
Overlay-Calculus can be viewed as DOT without $\lambda$, retaining
path-dependent types while replacing functions with
overlay inheritance.
A formal type system would be amenable to mechanization in proof
assistants (Coq, Agda) for verifying type safety, progress, and
preservation properties.

Beyond soundness of the existing checks, additional type system
features would strengthen the language.
A key example is \emph{totality checking}: verifying that a
inheritance provides implementations for all required slots, not
merely that references resolve.
In untyped Overlay-Calculus, writing $\mathrm{magnitude} \mapsto \{\}$
is purely documentary: it defines a structural slot but imposes no
constraint on what must fill it.
Totality checking would enforce such declarations statically,
rejecting inheritances that leave required slots unfilled.

\paragraph{Standard library}
The remaining items concern the \emph{standard library}: they require
no extensions to the calculus or type system, but involve nontrivial
encodings within the existing framework.

Overlay-Calculus is \emph{open by default}: inheritance
can freely merge any two overlays, and a value may simultaneously
inhabit multiple constructors (e.g.,
$\{\mathrm{Zero},\; \mathrm{Odd},\; \mathrm{half} \mapsto \mathrm{Zero}\}$).
This is not a defect; it is the natural trie semantics of the
calculus, and the basis for solving the expression problem
(Section~\ref{sec:asymmetry}).
However, many operations (e.g., equality testing) assume that values
are \emph{linear}, inhabiting exactly one constructor.
The observer pattern (Section~\ref{sec:case-study}) does not enforce
this: applied to a multi-constructor value, all callbacks fire and
their results are inherited.

\emph{Schema validation} can be implemented at the library level
using existing primitives.
An observer can test whether a particular constructor is present,
returning a Boolean; a second Boolean dispatch then branches on the
result.
By chaining such tests, a factory can validate that a value matches
exactly one constructor and carries the required fields.
This does not restrict inheritance itself, which remains
unconstrained, but provides a way to detect invariant violations
before they propagate.

The same technique, an observer returning Boolean followed by Boolean
dispatch, yields \emph{closed pattern matching}.
The observer pattern of Section~\ref{sec:case-study} is inherently
\emph{open}: new constructor cases can be added through inheritance.
Closed matching, where exactly one branch is taken, can be encoded as
a \emph{visitor chain}: a linked list of if-then-else nodes, each
testing one constructor and falling through on mismatch.
This is analogous to GHC.Generics' $\mathrm{(:+:)}$ sum
representation~\cite{magalhaes2010generic}, where each link
corresponds to one summand.
An important consequence is that such chains do \emph{not}
commute, as they have a fixed order, and therefore cannot be extended
through open inheritance, which is the correct semantics for closed
dispatch.

\section{Conclusion}

The goals of declarative programming forced the semantics
of Overlay-Calculus upon us.
The emergent phenomena suggest that
it is a more expressive computational
foundation than the $\lambda$-calculus.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\appendix


\section{Multi-Path Self-Reference in Other Systems}
\label{app:scala-multi-path}

This appendix demonstrates that two representative systems, Scala~3
and the NixOS module system, reject the multi-path self-reference
pattern that Overlay-Calculus handles naturally.

\subsection*{Scala~3}

Consider two objects that independently extend an outer class,
each providing its own copy of an inner trait:

\begin{verbatim}
class MyOuter:
  trait MyInner:
    def outer = MyOuter.this

object Object1 extends MyOuter
object Object2 extends MyOuter
object MyObjectA extends Object1.MyInner
                     with Object2.MyInner
\end{verbatim}

\noindent
Scala~3 rejects \texttt{MyObjectA} with the error:

\begin{verbatim}
trait MyInner is extended twice
object MyObjectA cannot be instantiated since
  it has conflicting base types
  Object1.MyInner and Object2.MyInner
\end{verbatim}

\noindent
The rejection is not a surface-level restriction but a consequence
of DOT's type-theoretic foundations~\cite{amin2016dot}.
In DOT, an object is constructed as $\nu(x : T)\, d$, where the
self variable~$x$ binds to a \emph{single} object.
\texttt{Object1.MyInner} and \texttt{Object2.MyInner} are distinct
path-dependent types, each constraining the outer self-reference
to a different object.
Their intersection requires \texttt{outer} to simultaneously
return \texttt{Object1} and \texttt{Object2}, but DOT's self
variable is single-valued, making this intersection unrealizable.

The equivalent Overlay-Calculus definition is:
\begin{align*}
\{ \quad \mathrm{MyOuter} &\mapsto \{
    \mathrm{MyInner} \mapsto \{
  \mathrm{outer} \mapsto \qualifiedthis{\mathrm{MyOuter}}\}\}, \\
  \mathrm{Object1} &\mapsto \{\mathrm{MyOuter}\}, \\
  \mathrm{Object2} &\mapsto \{\mathrm{MyOuter}\}, \\
  \mathrm{MyObjectA} &\mapsto \{
    \mathrm{Object1}.\mathrm{MyInner},\;
  \mathrm{Object2}.\mathrm{MyInner}\}
\quad \}
\end{align*}
This is well-defined in Overlay-Calculus.
The reference
$\qualifiedthis{\mathrm{MyOuter}}$ inside $\mathrm{outer}$
has de~Bruijn index $n = 1$:
starting from $\mathrm{outer}$'s enclosing scope
$\mathrm{MyInner}$, one $\this$ step reaches
$\mathrm{MyOuter}$.
When $\mathrm{MyObjectA}$ inherits from both
$\mathrm{Object1}.\mathrm{MyInner}$ and
$\mathrm{Object2}.\mathrm{MyInner}$,
the $\this$ function (equation~\ref{eq:this}) resolves
$\qualifiedthis{\mathrm{MyOuter}}$ by searching through
$\supers(\mathrm{MyObjectA})$ for overlay paths matching
$\mathrm{MyInner}$'s definition site.
It finds two inheritance-site paths, one through
$\mathrm{Object1}$ and one through $\mathrm{Object2}$, and
returns both.
Both paths lead to records that inherit from the same
$\mathrm{MyOuter}$, so querying
$\mathrm{MyObjectA}.\mathrm{outer}$ yields the
$\properties$ of $\mathrm{MyOuter}$ regardless of which
route is taken.
Since inheritance is idempotent, the two routes contribute the
same properties and no disambiguation is needed.

\subsection*{NixOS Module System}

The NixOS module system rejects the same pattern with a static error.
The translation uses the module system's own abstractions:
\texttt{deferredModule} for traits (unevaluated module values imported
into other fixpoints) and \texttt{submoduleWith} for objects (evaluated
in their own fixpoints).

\begin{verbatim}
let
  lib = (import <nixpkgs> { }).lib;
  result = lib.evalModules {
    modules = [
      (toplevel@{ config, ... }: {
        # class MyOuter { trait MyInner {
        #   def outer = MyOuter.this } }
        options.MyOuter = lib.mkOption {
          default = { };
          type = lib.types.deferredModuleWith {
            staticModules = [
              (MyOuter: {
                options.MyInner = lib.mkOption {
                  default = { };
                  type = lib.types.deferredModuleWith {
                    staticModules = [
                      (MyInner: {
                        options.outer = lib.mkOption {
                          default = { };
                          type =
                            lib.types.deferredModuleWith {
                              staticModules =
                                [ toplevel.config.MyOuter ];
                            };
                        };
                      })
                    ];
                  };
                };
              })
            ];
          };
        };
        # object Object1 extends MyOuter
        options.Object1 = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [ toplevel.config.MyOuter ];
          };
        };
        # object Object2 extends MyOuter
        options.Object2 = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [ toplevel.config.MyOuter ];
          };
        };
        # object MyObjectA extends
        #   Object1.MyInner with Object2.MyInner
        options.MyObjectA = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [
            toplevel.config.Object1.MyInner
            toplevel.config.Object2.MyInner
          ];
          };
        };
      })
    ];
  };
in
  builtins.attrNames result.config.MyObjectA.outer
\end{verbatim}

\noindent
The NixOS module system rejects this with:

\begin{verbatim}
error: The option `MyObjectA.outer'
  in `<unknown-file>'
  is already declared
  in `<unknown-file>'.
\end{verbatim}

\noindent
The rejection occurs because
\texttt{Object1.\allowbreak{}My\-Inner} and
\texttt{Object2.\allowbreak{}My\-Inner} each carry the full
\texttt{static\-Modules} of the \texttt{My\-Inner} deferred
module, including the declaration
\texttt{options.\allowbreak{}outer}.
When \texttt{My\-ObjectA} imports both, the module system's
\texttt{merge\-Option\-Decls} encounters two declarations of the
same option and raises a static error; it cannot express that
both declarations originate from the same trait and should be
unified.

The rejection is analogous to Scala's ``conflicting base types''
error above: both systems assume that each option (or type member)
has a single declaration site, and reject the multi-path situation
where two inheritance routes introduce the same declaration
independently.
In Overlay-Calculus, the same pattern is well-defined because
$\overlays$ (equation~\ref{eq:overlays}) recognizes that both
routes lead to the same definition, and $\supers$
(equation~\ref{eq:supers}) collects both inheritance-site
contexts without duplication.

\section{Well-Definedness of the Semantic Functions}
\label{app:well-definedness}

This appendix proves that the mutually recursive equations
(\ref{eq:properties})--(\ref{eq:this}) have a unique least
fixed point, and therefore the semantics of
Section~\ref{sec:overlay-trees} is well-defined.

\subsection{The Product Lattice}

Fix an AST with its primitive functions $\defines$ and
$\inherits$.
Let $\mathcal{L}$ denote the set of all labels and
$\mathcal{P}$ the set of all paths (finite sequences of labels).
Define the following domains, one for each semantic function:
\begin{align*}
D_{\properties} &= \mathcal{P} \to \mathcal{P}(\mathcal{L})
& &\text{(sets of labels)} \\
D_{\supers} &= \mathcal{P} \to \mathcal{P}(\mathcal{P} \times \mathcal{P})
& &\text{(sets of site--overlay pairs)} \\
D_{\overlays} &= \mathcal{P} \to \mathcal{P}(\mathcal{P})
& &\text{(sets of paths)} \\
D_{\bases} &= \mathcal{P} \to \mathcal{P}(\mathcal{P})
& &\text{(sets of paths)} \\
D_{\resolve} &= (\mathcal{P} \times \mathcal{P} \times \mathbb{N}
\times \mathcal{L}^*) \to \mathcal{P}(\mathcal{P})
& &\text{(sets of paths)} \\
D_{\this} &= (\mathcal{P}(\mathcal{P}) \times \mathcal{P} \times \mathbb{N})
\to \mathcal{P}(\mathcal{P})
& &\text{(sets of paths)}
\end{align*}
Each $D_i$ is a complete lattice under the pointwise subset
ordering: $f \sqsubseteq g$ iff $f(x) \subseteq g(x)$ for all $x$.
The product
$D = D_{\properties} \times D_{\supers} \times D_{\overlays}
\times D_{\bases} \times D_{\resolve} \times D_{\this}$
is a complete lattice under the componentwise ordering, with
bottom element $\bot = (\lambda x.\,\varnothing, \ldots,
\lambda x.\,\varnothing)$.

\subsection{The Operator}

Equations~(\ref{eq:properties})--(\ref{eq:this}) define a
function
$F : D \to D$
that takes a tuple of candidate interpretations
$(\properties, \supers, \overlays, \bases, \resolve, \this)$
and produces a new tuple by evaluating the right-hand side of
each equation.
The transitive closure $\bases^*$ appearing in
equation~(\ref{eq:supers}) is derived from $\bases$: for
any fixed $\bases$, the set $\bases^*(p)$ is defined as the
least fixed point of the monotone operator
$X \mapsto \{p\} \cup \bigcup_{q \in X} \bases(q)$
on $\mathcal{P}(\mathcal{P})$.
If $\bases \sqsubseteq \bases'$ (pointwise), then
$\bases^* \sqsubseteq \bases'^*$ (pointwise), since enlarging the
one-step relation can only enlarge the transitive closure.

The $\this$ function involves a recursion on the de~Bruijn
index~$n$.
Since $n$ decreases by one at each step and is a non-negative
integer, this recursion terminates for any fixed interpretation
of $\supers$.
The result of $\this(S, p_{\mathrm{def}}, n)$ for all valid
$(S, p_{\mathrm{def}}, n)$ is therefore well-defined as a
function of $\supers$, and it remains to show that it is monotone
in $\supers$.

\subsection{Monotonicity}

\begin{proposition}\label{prop:monotone}
The operator $F$ is monotone:
if $\vec{d} \sqsubseteq \vec{d}'$ in $D$,
then $F(\vec{d}) \sqsubseteq F(\vec{d}')$.
\end{proposition}

\begin{proof}
It suffices to show that each component of $F$ is monotone in every
argument, i.e., that enlarging any of the input interpretations
(in the $\subseteq$ ordering) can only enlarge the output.
We verify this by inspecting the right-hand side of each equation
and confirming that every occurrence of a mutually defined function
appears in a \emph{positive} position---%
as the domain of an existential quantifier in a set
comprehension~\cite{aczel1977inductive}.

\paragraph{Equation~(\ref{eq:properties}): $\properties$}
\[
  \properties(p) =
  \bigl\{\, \ell \bigm|
    (\_, p_{\mathrm{overlay}}) \in \supers(p),\;
    \ell \in \defines(p_{\mathrm{overlay}})
  \,\bigr\}.
\]
The function $\supers$ appears as the set being iterated
over ($\in \supers(p)$).
The predicate $\ell \in \defines(\cdot)$ involves only
the AST primitive $\defines$, not any mutually defined
function.
Enlarging $\supers(p)$ can only add pairs, hence can only add
labels to the result.
\emph{Positive in $\supers$.}

\paragraph{Equation~(\ref{eq:supers}): $\supers$}
$\supers(p) =
\bigl\{\, (\init(p_{\mathrm{base}}), p_{\mathrm{overlay}}) \bigm|
  p_{\mathrm{base}} \in \bases^*(p),\;
  p_{\mathrm{overlay}} \in \overlays(p_{\mathrm{base}})
\,\bigr\}$.
Both $\bases^*$ and $\overlays$ appear as sets being iterated
over.
As noted above, $\bases^*$ is monotone in $\bases$.
Enlarging either $\bases$ or $\overlays$ can only add elements to the
result.
\emph{Positive in $\bases$ and $\overlays$.}

\paragraph{Equation~(\ref{eq:overlays}): $\overlays$}
For $p \neq ()$:
\begin{multline*}
  \overlays(p) = \{p\} \cup
  \bigl\{\, p_{\mathrm{branch}} \snoc \last(p) \bigm| {} \\
    (\_, p_{\mathrm{branch}}) \in \supers(\init(p)),\;
    \last(p) \in \defines(p_{\mathrm{branch}})
  \,\bigr\}.
\end{multline*}
The function $\supers$ appears as the set being iterated over.
The filtering condition $\last(p) \in \defines(\cdot)$
involves only the AST primitive.
Enlarging $\supers$ can only add branches, hence can only add paths
to the result.
\emph{Positive in $\supers$.}

\paragraph{Equation~(\ref{eq:bases}): $\bases$}
\begin{multline*}
  \bases(p) =
  \bigl\{\, p_{\mathrm{target}} \bigm|
    p_{\mathrm{overlay}} \in \overlays(p),\\
    (n, \ell_{\mathrm{down},*}) \in \inherits(p_{\mathrm{overlay}}),\;
    p_{\mathrm{target}} \in \resolve(\ldots)
  \,\bigr\}.
\end{multline*}
Both $\overlays$ and $\resolve$ appear as sets being iterated
over.
The function $\inherits$ is an AST primitive.
Enlarging either $\overlays$ or $\resolve$ can only add targets to
the result.
\emph{Positive in $\overlays$ and $\resolve$.}

\paragraph{Equation~(\ref{eq:resolve}): $\resolve$}
\[
  \resolve(\ldots) =
  \bigl\{\,
    p_{\mathrm{current}} \snoc \ell_{\mathrm{down},1} \snoc \cdots
    \bigm|
    p_{\mathrm{current}} \in
    \this(\{p_{\mathrm{site}}\}, \init(p_{\mathrm{def}}), n)
  \,\bigr\}.
\]
The function $\this$ appears as the set being iterated over.
Enlarging $\this$ can only add paths to the result.
\emph{Positive in $\this$.}

\paragraph{Equation~(\ref{eq:this}): $\this$}
For $n > 0$:
$\this(S, p_{\mathrm{def}}, n) =
\this(S', \init(p_{\mathrm{def}}), n - 1)$
where
$S' = \bigl\{\, p_{\mathrm{site}} \bigm|
  p_{\mathrm{current}} \in S,\;
  (p_{\mathrm{site}}, p_{\mathrm{overlay}}) \in
  \supers(p_{\mathrm{current}}),\;
  p_{\mathrm{overlay}} = p_{\mathrm{def}}
\,\bigr\}$.
The function $\supers$ appears as the set being iterated over.
The filtering condition $p_{\mathrm{overlay}} = p_{\mathrm{def}}$
is an equality test on path data, not involving any mutually
defined function.
Enlarging $\supers$ can only enlarge $S'$, and by induction on~$n$
(the base case $n = 0$ returns $S$ unchanged), the recursive call
is monotone in $S'$.
\emph{Positive in $\supers$.}

\medskip\noindent
In summary, every mutually defined function appears on the
right-hand side of every equation only inside the pattern
$x \in f(\ldots)$ within a set comprehension, i.e., as the
domain of an existential quantifier.
No complement, set difference, or negated membership test
appears in any equation.
Therefore $F$ is a monotone operator on the complete lattice $D$.
\end{proof}

\subsection{Existence of the Least Fixed Point}

\begin{theorem}\label{thm:well-defined}
The semantic functions
$\properties$, $\supers$, $\overlays$, $\bases$, $\resolve$,
$\this$ are well-defined as the least fixed point of~$F$.
\end{theorem}

\begin{proof}
By Proposition~\ref{prop:monotone}, $F$ is monotone on the
complete lattice~$D$.
By the Knaster--Tarski theorem~\cite{tarski1955lattice}, $F$ has
a least fixed point $\vec{d}^* = \bigsqcup_{n \ge 0} F^n(\bot)$,
where $\bot$ assigns the empty set to every input.
The components of $\vec{d}^*$ are the semantic functions of
Section~\ref{sec:overlay-trees}.

Concretely, the least fixed point is the union of the finite
approximation chain:
$\bot \sqsubseteq F(\bot) \sqsubseteq F^2(\bot) \sqsubseteq \cdots$.
A membership $\ell \in \properties(p)$ holds in $\vec{d}^*$
if and only if it appears at some finite stage $F^k(\bot)$,
which corresponds to a finite derivation tree using the
equations.
When no finite derivation exists, the membership is absent from
the least fixed point and the query is undefined, the
analogue of divergence.
\end{proof}

\section{B\"ohm Tree Correspondence: Proofs}
\label{app:bohm-tree-proofs}

This appendix contains the full proofs of Adequacy
(Theorem~\ref{thm:adequacy}) and Full Abstraction
(Theorem~\ref{thm:full-abstraction}) stated in
Section~\ref{sec:bohm-tree}.

\subsection{B\"ohm Trees}

We briefly recall the definition of B\"ohm
trees~\cite{barendregt1984lambda}.
A \emph{head reduction} $M \to_h M'$ contracts
the outermost $\beta$-redex only: if $M$ has the form
$(\lambda x.\, e)\; v\; M_1 \cdots M_k$, then
$M \to_h e[v/x]\; M_1 \cdots M_k$.
A term $M$ is in \emph{head normal form} (HNF) if it has no
head redex, i.e., $M = \lambda x_1 \ldots x_m.\;
y\; M_1 \cdots M_k$ where $y$ is a variable.

The \emph{B\"ohm tree} $\mathrm{BT}(M)$ of a $\lambda$-term $M$
is an infinite labeled tree defined by:
\[
\mathrm{BT}(M) =
\begin{cases}
  \bot & \text{if } M \text{ has no HNF} \\[6pt]
  \lambda x_1 \ldots x_m.\;
  y\bigl(\mathrm{BT}(M_1),\; \ldots,\; \mathrm{BT}(M_k)\bigr)
  & \begin{aligned}[t]
    &\text{if } M \to^*_h \\[-2pt]
    &\lambda x_1 \ldots x_m.\; y\; M_1 \cdots M_k
  \end{aligned}
\end{cases}
\]
B\"ohm tree equivalence $\mathrm{BT}(M) = \mathrm{BT}(N)$ is the
standard observational equivalence of the lazy
$\lambda$-calculus~\cite{barendregt1984lambda,abramsky1993lazy}.

\subsection{Path Encoding}

We define a correspondence between positions in the B\"ohm tree
and paths in the overlay tree.
When the translation $\mathcal{T}$ is applied to an ANF
$\lambda$-term, the resulting overlay tree has a specific shape:
\begin{itemize}
\item An abstraction $\lambda x.\, M$ translates to a record
  with own properties $\{\mathrm{argument}, \mathrm{result}\}$
  (the \emph{abstraction shape}).
\item A $\mathbf{let}$-binding
  $\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M$ translates
  to a record with own properties $\{x, \mathrm{result}\}$,
  where $x$ holds the encapsulated application
  $\{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
  \mathcal{T}(V_2)\}$.
\item A tail call $V_1\; V_2$ translates to a record with own
  properties $\{\_\mathrm{tail}, \mathrm{result}\}$, where
  $\_\mathrm{tail}$ holds the encapsulated application and
  $\mathrm{result}$ projects
  $\_\mathrm{tail}.\mathrm{result}$.
\item A variable $x$ with de~Bruijn index $n$ translates to
  an indexed reference $\dbi{n}.\mathrm{argument}$.
\end{itemize}

\noindent
Each B\"ohm tree position is a sequence of navigation steps from
the root.
In the B\"ohm tree, the possible steps at a node
$\lambda x_1 \ldots x_m.\; y\; M_1 \cdots M_k$ are:
entering the body (peeling off one abstraction layer) and
entering the $i$-th argument $M_i$ of the head variable.
In the overlay tree, these correspond to following the
$\mathrm{result}$ label (for entering the body) and the
$\mathrm{argument}$ label after $\this$ resolution (for
entering an argument position).

Rather than comparing absolute paths across different overlay
trees (which would be sensitive to internal structure), we
observe only the \emph{convergence} behavior accessible via
the $\mathrm{result}$ projection.
Recall the definition of overlay-convergence
(Definition~\ref{def:convergence}).
Each $\mathrm{result}$-following step corresponds to one head
reduction step in the $\lambda$-calculus: a tail call's
$\mathrm{result}$ projects through the encapsulated
application, and a $\mathbf{let}$-binding's $\mathrm{result}$
enters the continuation.
The abstraction shape at the end signals that a weak head
normal form has been reached.

\subsection{Single-Path Lemma}

The $\this$ function (equation~\ref{eq:this}) is designed for the
general case of multi-path overlay inheritance.
For translated $\lambda$-terms, we show it degenerates to
single-path resolution.

\begin{lemma}[Single Path]\label{lem:single-path}
For any closed ANF $\lambda$-term $M$, at every invocation of
$\this(S,\; p_{\mathrm{def}},\; n)$ during evaluation of
$\mathcal{T}(M)$, the frontier set $S$ contains exactly one
path.
\end{lemma}

\begin{proof}
By induction on the structure of the ANF term.

\paragraph{Case $\mathcal{T}(\lambda x.\, M)
  = \{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M)\}$}
This is a record literal with
$\defines = \{\mathrm{argument}, \mathrm{result}\}$ and
no inheritance sources, so $\inherits = \varnothing$.
At the root path $p$, we have $\overlays(p) = \{p\}$ (a single
path) since there are no inheritance sources to introduce
additional branches.
Inside $\mathcal{T}(M)$, any reference to $x$ is
$\dbi{n}.\mathrm{argument}$ where $n$ is the de~Bruijn index
pointing to this scope level.
Since $\mathcal{T}(\lambda x.\, M)$ introduces exactly one
scope level, there is exactly one
overlay at that level, hence $\this$ finds exactly one matching
pair $(p_{\mathrm{site}},\; p_{\mathrm{overlay}})$ in $\supers$.

\paragraph{Case
  $\mathcal{T}(\mathbf{let}\; x = V_1\; V_2
  \;\mathbf{in}\; M)
  = \{x \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
\mathrm{result} \mapsto \mathcal{T}(M)\}$}
The outer record has own properties $\{x, \mathrm{result}\}$
and no inheritance sources at the outer level
($\inherits = \varnothing$), so $\overlays(\text{root})
= \{\text{root}\}$.
Inside the $x$ subtree, the inheritance
$\{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
\mathcal{T}(V_2)\}$ has exactly one inheritance source
($\mathcal{T}(V_1)$), creating exactly one $\bases$ entry.
By induction on $V_1$, the single-path property holds inside
$\mathcal{T}(V_1)$.
Inside $\mathcal{T}(M)$, the induction hypothesis applies
directly.

\paragraph{Case $\mathcal{T}(V_1\; V_2) =
  \{\_\mathrm{tail} \mapsto
    \{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
    \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto
\_\mathrm{tail}.\mathrm{result}\}$}
Identical to the $\mathbf{let}$-binding case: the outer record
has own properties $\{\_\mathrm{tail}, \mathrm{result}\}$
with no inheritance sources at the outer level, and the
$\_\mathrm{tail}$ subtree contains exactly one inheritance
source.

\paragraph{Case $\mathcal{T}(x)
= \dbi{n}.\mathrm{argument}$}
This is a reference, not a record.
The $\this$ function walks up $n$ steps from the enclosing scope.
By the inductive hypothesis on the enclosing translations,
each step of $\this$ encounters exactly one matching pair in
$\supers$.

\medskip\noindent
The key structural invariant is that the translation
$\mathcal{T}$ never produces two independent inheritance sources
at the same scope level that both define the same label.
In every case, application inheritances are \emph{encapsulated}
inside a named property ($x$ or $\_\mathrm{tail}$), and each
such encapsulated inheritance has exactly one inheritance
source.
This prevents diamond inheritance and ensures single-path
resolution throughout.
\end{proof}

\subsection{Substitution Lemma}

The core mechanism of the translation is that inheritance with
$\mathrm{argument} \mapsto \mathcal{T}(V)$ plays the role of
substitution.  We make this precise.

\begin{lemma}[Substitution]\label{lem:substitution}
Let $M$ be an ANF term in which $x$ may occur free,
and let $V$ be a closed value.
Define the \emph{inherited tree}
$C = \{\mathcal{T}(\lambda x.\, M),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$.
Then for every path $p$ under $C \snoc \mathrm{result}$ and
every label $\ell$:
\[
  \ell \in \properties(p)
  \text{ in } C \snoc \mathrm{result}
  \quad\Longleftrightarrow\quad
  \ell \in \properties(p)
  \text{ in } \mathcal{T}(M[V/x])
\]
where $M[V/x]$ is the usual capture-avoiding substitution.
\end{lemma}

\begin{proof}
By structural induction on $M$.

\paragraph{Base case: $M = x$}
Then $\mathcal{T}(x) =
\dbi{n}.\mathrm{argument}$ (where $n$ is the de~Bruijn index
of $x$), and
$C \snoc \mathrm{result}$ contains this reference.
In the inherited tree $C$, $\resolve$ and $\this$ resolve the reference by
navigating from the reference's enclosing scope up $n$ steps
to the binding $\lambda$, where the inheritance
$\{\mathcal{T}(\lambda x.\, x),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$ overlays the
$\mathrm{argument}$ slot with $\mathcal{T}(V)$.
Since $C$ is the $\_\mathrm{tail}$ subtree of
$\mathcal{T}\bigl((\lambda x.\, M)\; V\bigr)$, which is a
closed ANF term, Lemma~\ref{lem:single-path} applies and
$\this$ finds exactly one path,
so $\resolve$ returns $\mathcal{T}(V)$'s subtree.
Since $M[V/x] = V$, we have
$\mathcal{T}(M[V/x]) = \mathcal{T}(V)$, and the properties
coincide.

\paragraph{Base case: $M = y$ where $y \neq x$}
Then $\dbi{m}.\mathrm{argument}$ (where $m$ is the de~Bruijn
index of $y$, $m \neq n$) walks up to a different scope level,
so the inheritance with
$\mathrm{argument} \mapsto \mathcal{T}(V)$ at the
binding scope of $x$ has no effect.
Since $M[V/x] = y$, the properties are identical.

\paragraph{Inductive case: $M = \lambda y.\, M'$}
Then $\mathcal{T}(M) =
\{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M')\}$.
The subtree at $C \snoc \mathrm{result}$ is another
abstraction-shaped record.
References to $x$ inside $\mathcal{T}(M')$ resolve through
$\this$ in exactly the same way (with one additional scope
level from the inner $\lambda$), and by induction on $M'$, the
properties under
$C \snoc \mathrm{result} \snoc \mathrm{result}$
coincide with those of
$\mathcal{T}(M'[V/x])$.
Since
$(\lambda y.\, M')[V/x] = \lambda y.\, (M'[V/x])$
(assuming $y$ is fresh), the result follows.

\paragraph{Inductive case:
  $M = \mathbf{let}\; z = V_1\; V_2$
$\mathbf{in}\; M'$}
Then
\[
  \mathcal{T}(M) =
  \{z \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
  \mathrm{result} \mapsto \mathcal{T}(M')\}.
\]
The substitution distributes:
$M[V/x] =
\mathbf{let}\; z = V_1[V/x]\; V_2[V/x]
\;\mathbf{in}\; M'[V/x]$.
By induction on $V_1$, $V_2$, and $M'$, the properties under
each subtree ($z$ and $\mathrm{result}$) coincide,
since references to $x$ inside each subtree resolve to
$\mathcal{T}(V)$ via the same $\this$ mechanism.

\paragraph{Inductive case: $M = V_1\; V_2$ (tail call)}
Analogous to the $\mathbf{let}$-binding case with
$\_\mathrm{tail}$ in place of $z$.
\end{proof}

\subsection{Convergence Preservation}

The convergence criterion (Definition~\ref{def:convergence})
follows the $\mathrm{result}$ chain from the root.
Each step in this chain corresponds to one head reduction step
in the $\lambda$-calculus.
We make this precise.

\begin{lemma}[Result-step]\label{lem:result-step}
Let $(\lambda x.\, M)\; V$ be a tail call (a $\beta$-redex).
Then for every path $p$ and label $\ell$:
\[
  \ell \in \properties\!\bigl(\,
  \text{root} \snoc \mathrm{result} \snoc p\,\bigr)
  \text{ in } \mathcal{T}\bigl((\lambda x.\, M)\; V\bigr)
  \;\Longleftrightarrow\;
  \ell \in \properties\!\bigl(\,
  \text{root} \snoc p\,\bigr)
  \text{ in } \mathcal{T}(M[V/x])
\]
That is, following one $\mathrm{result}$ projection in the
tail call's overlay tree yields the same properties as the
root of the reduct's overlay tree.
\end{lemma}

\begin{proof}
The translation gives:
\[
  \mathcal{T}\bigl((\lambda x.\, M)\; V\bigr) =
  \{\_\mathrm{tail} \mapsto
    \{\mathcal{T}(\lambda x.\, M),\;
    \mathrm{argument} \mapsto \mathcal{T}(V)\},\;
    \mathrm{result} \mapsto
  \_\mathrm{tail}.\mathrm{result}\}
\]
The $\mathrm{result}$ label at the root is defined as
$\_\mathrm{tail}.\mathrm{result}$, so
$\text{root} \snoc \mathrm{result}$ resolves to the
$\mathrm{result}$ path inside the inheritance
$\_\mathrm{tail} = \{\mathcal{T}(\lambda x.\, M),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$.
This inheritance is exactly the inherited tree $C$ of
Lemma~\ref{lem:substitution}, and
$\_\mathrm{tail} \snoc \mathrm{result}$ is
$C \snoc \mathrm{result}$.
By Lemma~\ref{lem:substitution}, the properties under
$C \snoc \mathrm{result}$ coincide with those of
$\mathcal{T}(M[V/x])$.

\medskip\noindent
\emph{Let-binding variant.}
An analogous result holds for
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'$
where $V_1 = \lambda y.\, M''$.
The translation gives:
\[
  \mathcal{T}\bigl(\mathbf{let}\; x = V_1\; V_2
  \;\mathbf{in}\; M'\bigr) =
  \{x \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
  \mathrm{result} \mapsto \mathcal{T}(M')\}
\]
Since $\mathrm{result} \mapsto \mathcal{T}(M')$ is a property
definition, the subtree at
$\text{root} \snoc \mathrm{result}$ is $\mathcal{T}(M')$.
Inside $\mathcal{T}(M')$, each reference to $x$ is
$x.\mathrm{result}$, which resolves to the $\mathrm{result}$
path inside the $x$ subtree
$\{\mathcal{T}(\lambda y.\, M''),\;
\mathrm{argument} \mapsto \mathcal{T}(V_2)\}$.
This is the inherited tree $C$ of
Lemma~\ref{lem:substitution}, so
$x.\mathrm{result}$ has the same properties as
$\mathcal{T}(M''[V_2/y])$.
In the $\lambda$-calculus,
$M = (\lambda x.\, M')(V_1\; V_2)$, and the head reduct is
$N = M'[(V_1\; V_2)/x]$.
In $\mathcal{T}(N)$, each occurrence of $x$ is replaced by
$(V_1\; V_2)$, whose result, by the tail-call variant above,
also yields $\mathcal{T}(M''[V_2/y])$.
Therefore the properties at
$\text{root} \snoc \mathrm{result} \snoc p$ in
$\mathcal{T}(M)$ coincide with those at
$\text{root} \snoc p$ in $\mathcal{T}(N)$ for all $p$.
\end{proof}

\begin{theorem}[Convergence preservation]%
\label{thm:convergence-preservation}
If $M \to_h N$ (head reduction), then
$\mathcal{T}(M){\Downarrow}$ if and only if
$\mathcal{T}(N){\Downarrow}$.
\end{theorem}

\begin{proof}
A head reduction step in ANF takes one of two forms:
a tail call $(\lambda x.\, M')\; V \to_h M'[V/x]$,
or a $\mathbf{let}$-binding
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'
\to_h M'[(V_1\; V_2)/x]$
(since $\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M' =
(\lambda x.\, M')(V_1\; V_2)$ in the $\lambda$-calculus).
In both cases, Lemma~\ref{lem:result-step} (tail-call and
let-binding variants respectively) shows that
the properties at $\text{root} \snoc \mathrm{result}^n$ in
$\mathcal{T}(M)$ coincide with the properties at
$\text{root} \snoc \mathrm{result}^{n-1}$ in
$\mathcal{T}(N)$ for all $n \ge 1$, where $N$ is the
head reduct.
Hence the abstraction shape appears at depth $n$ in the
pre-reduct if and only if it appears at depth $n - 1$ in
the post-reduct.
\end{proof}

\subsection{Adequacy}

A closed ANF term at the top level is either an abstraction
(a value) or a computation (a $\mathbf{let}$-binding or tail
call).
An abstraction translates to a record whose root immediately
has the abstraction shape; a computation's root has the form
$\{x, \mathrm{result}\}$ or
$\{\_\mathrm{tail}, \mathrm{result}\}$, and one must follow
the $\mathrm{result}$ chain to find the eventual value.

\begin{proof}[Proof of Theorem~\ref{thm:adequacy}]
($\Rightarrow$)
Suppose $M \to^*_h \lambda x.\, M'$ in $k$ head reduction
steps.
We show $\mathcal{T}(M)$ converges at depth $\le k$ by
induction on $k$.

\emph{Base case} ($k = 0$): $M$ is already an abstraction
$\lambda x.\, M'$.
Then $\mathcal{T}(M) =
\{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M')\}$,
whose root has
$\defines = \{\mathrm{argument}, \mathrm{result}\}$.
These labels appear at stage $F^1(\bot)$ of the approximation
chain, so $\mathcal{T}(M)$ converges at depth $n = 0$.

\emph{Inductive step} ($k \ge 1$): $M$ is not an abstraction,
so $M$ is either a tail call or a $\mathbf{let}$-binding,
both of which are $\beta$-redexes.
Let $N$ be the head reduct, so
$M \to_h N \to^{k-1}_h \lambda x.\, M'$.
By Lemma~\ref{lem:result-step} (tail-call or
let-binding variant), the properties at
$\text{root} \snoc \mathrm{result} \snoc p$
in $\mathcal{T}(M)$ coincide with those at
$\text{root} \snoc p$ in $\mathcal{T}(N)$.
By the induction hypothesis, $\mathcal{T}(N)$
converges at depth $\le k - 1$, so $\mathcal{T}(M)$
converges at depth $\le k$.

\medskip\noindent
($\Leftarrow$)
Suppose $\mathcal{T}(M){\Downarrow}$ at depth $n$.
We show $M$ has a head normal form by induction on $n$.

\emph{Base case} ($n = 0$): the root of $\mathcal{T}(M)$ has
abstraction shape
$\{\mathrm{argument}, \mathrm{result}\}$.
Only the abstraction rule $\mathcal{T}(\lambda x.\, M')$
produces a root with own property $\mathrm{argument}$.
(For tail calls and $\mathbf{let}$-bindings, the root has
  $\defines = \{\_\mathrm{tail}, \mathrm{result}\}$
  or $\{x, \mathrm{result}\}$, and $\mathrm{argument}$ cannot
  appear via $\supers$ because
  $\inherits = \varnothing$ at the root, giving
$\bases(\text{root}) = \varnothing$.)
Therefore $M$ is an abstraction, hence already in head normal
form.

\emph{Inductive step} ($n \ge 1$): the abstraction shape
appears at depth $n$ but not at depth $0$.
By the base case argument, $M$ is not an abstraction, so $M$
is either a tail call $V_1\; V_2$ or a $\mathbf{let}$-binding
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'$.
In both cases, $M$ is a $\beta$-redex
(since $V_1 = \lambda x.\, M'$ or
  $V_1 = \lambda y.\, M''$ respectively, the only closed
ANF value).
By Lemma~\ref{lem:result-step} (tail-call or
let-binding variant respectively), the properties at depth
$n - 1$ in $\mathcal{T}(N)$ match those at depth $n$
in $\mathcal{T}(M)$, where $N$ is the head reduct.
So $\mathcal{T}(N)$ converges at depth $n - 1$.
By the induction hypothesis, $N$ has a head normal
form, and since $M \to_h N$, so does $M$.
\end{proof}

\subsection{Full Abstraction}

Adequacy relates a single term's head normal form to its
overlay-convergence.
Full abstraction lifts this to an equivalence between terms:
the translation $\mathcal{T}$ preserves and reflects
observational equivalence.

\begin{definition}[Overlay-contextual equivalence]%
\label{def:ctx-equiv}
For closed $\lambda$-terms $M$ and $N$, write
$\mathcal{T}(M) \approx \mathcal{T}(N)$ if for every
closing $\lambda$-calculus context $C[\cdot]$:
\[
  \mathcal{T}(C[M]){\Downarrow}
  \;\Longleftrightarrow\;
  \mathcal{T}(C[N]){\Downarrow}
\]
\end{definition}

\noindent
This definition observes only convergence (a single bit), but
quantifying over all contexts makes it a fine-grained
equivalence: different contexts can supply different arguments
and project different results, probing every aspect of the
term's behavior.

\begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
The translation $\mathcal{T}$ is compositional: for every
$\lambda$-calculus context $C[\cdot]$, the overlay tree
$\mathcal{T}(C[M])$ is determined by the overlay tree
$\mathcal{T}(M)$ and the translation of the context.
This means $\mathcal{T}$ preserves the context structure
needed for the argument.

\medskip\noindent
($\Leftarrow$)
Suppose $\mathrm{BT}(M) = \mathrm{BT}(N)$.
B\"ohm tree equivalence is a congruence~\cite{barendregt1984lambda},
so for every context $C[\cdot]$,
$\mathrm{BT}(C[M]) = \mathrm{BT}(C[N])$.
In particular, $C[M]$ has a head normal form iff $C[N]$ does.
By Theorem~\ref{thm:adequacy},
$\mathcal{T}(C[M]){\Downarrow}$ iff
$\mathcal{T}(C[N]){\Downarrow}$.
Hence $\mathcal{T}(M) \approx \mathcal{T}(N)$.

\medskip\noindent
($\Rightarrow$)
Suppose $\mathrm{BT}(M) \neq \mathrm{BT}(N)$.
B\"ohm tree equivalence coincides with observational
equivalence for the lazy
$\lambda$-calculus~\cite{barendregt1984lambda,abramsky1993lazy}:
there exists a context $C[\cdot]$ such that $C[M]$ converges
and $C[N]$ diverges (or vice versa).
By Theorem~\ref{thm:adequacy},
$\mathcal{T}(C[M]){\Downarrow}$ and
$\mathcal{T}(C[N]){\Uparrow}$.
Hence $\mathcal{T}(M) \not\approx \mathcal{T}(N)$.
\end{proof}

\noindent
The proof rests on two pillars: Adequacy
(Theorem~\ref{thm:adequacy}), which is our contribution, and
the classical result that B\"ohm tree equivalence equals
observational equivalence for the lazy
$\lambda$-calculus~\cite{barendregt1984lambda,abramsky1993lazy}.
The overlay tree semantics inherits full abstraction from the
$\lambda$-calculus without needing to define or compare
absolute paths inside overlay trees.

\end{document}

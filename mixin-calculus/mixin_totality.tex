\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}

% Code listing style
\lstdefinestyle{yaml}{
  language=,
  basicstyle=\ttfamily\small,
  breaklines=true,
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  showstringspaces=false,
  frame=single,
  backgroundcolor=\color{gray!10}
}

\lstdefinestyle{haskell}{
  language=Haskell,
  basicstyle=\ttfamily\small,
  breaklines=true,
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  showstringspaces=false,
  frame=single,
  backgroundcolor=\color{gray!10}
}

\title{Overlay Language: A Total Language with Lazy Evaluation and Automatic Termination}
\author{}
\date{}

\begin{document}

\maketitle

\begin{abstract}
We present Overlay Language, a programming language that achieves a unique combination of properties: compile-time Turing completeness, runtime totality (weak totality/productivity), support for circular references, and lazy evaluation. Unlike existing total languages that require manual termination proofs, Overlay Language uses a simple naming convention combined with compile-time checks to automatically guarantee productivity. This makes Overlay Language the first total language accessible to programmers without formal verification expertise.
\end{abstract}

\section{Introduction}

\subsection{What is Totality?}

Totality has two levels of guarantees:

\begin{itemize}
  \item \textbf{Strong Totality (Termination)}: All data structures are finite, and all computations eventually halt.
  \item \textbf{Weak Totality (Productivity)}: Data structures may be conceptually infinite, but every finite access terminates and produces a well-defined result.
\end{itemize}

\textbf{Overlay Language guarantees weak totality:}
\begin{itemize}
  \item Every finite-depth access to any value terminates
  \item Programs may have conceptually infinite structures (via recursive instantiation)
  \item This is similar to Haskell's infinite lists or Coq's coinductive types
\end{itemize}

Totality is desirable because total programs never get stuck, never produce runtime errors due to non-termination, and their behavior at any finite depth is always well-defined.

\subsection{The Challenge}

Most programming languages are \textbf{non-total}. For example:
\begin{itemize}
  \item Haskell allows infinite loops: \texttt{let x = x in x}
  \item Python allows unbounded recursion without guarantees
  \item C/C++ programs can diverge or crash
\end{itemize}

Total languages exist (Coq, Agda, Idris), but they require programmers to \textbf{manually prove} termination or productivity, which requires expertise in type theory and formal verification.

\subsection{Overlay Language's Innovation}

Overlay Language achieves totality \textbf{automatically} through a simple naming convention:
\begin{itemize}
  \item \textbf{PascalCase} (e.g., \texttt{Nat}, \texttt{Succ}) → scopes (types/constructors)
  \item \textbf{lowercase} (e.g., \texttt{predecessor}, \texttt{sum}) → resources (values/computations)
  \item All values are \textbf{lazily evaluated}, enabling circular references while maintaining totality
\end{itemize}

This naming convention, combined with Overlay Language's tree-based symbol structure, guarantees totality without any manual proofs.

\section{Key Concepts}

\subsection{Symbol Tree}

Every Overlay Language program's symbols form a \textbf{tree structure}:

\begin{itemize}
  \item Each symbol has exactly one parent (except the root)
  \item Symbols can reference:
    \begin{itemize}
      \item Their own fields (children)
      \item Fields of their parent (via lexical scoping)
      \item Fields of sibling scopes
    \end{itemize}
  \item Symbols \textbf{cannot} reference the root from within nested scopes
\end{itemize}

\textbf{Example tree structure:}
\begin{verbatim}
Root (Nat)
├── Zero
│   └── Addition
│       ├── addend (extern)
│       └── sum
└── Succ
    ├── predecessor (extern)
    └── Addition
        ├── addend (extern)
        ├── _increased_addend
        ├── _recursive_addition
        └── sum
\end{verbatim}

\subsection{Structural Recursion and Instantiation}

\textbf{Structural recursion} means recursive calls are made only on \textbf{structurally smaller} values.

In Overlay Language:
\begin{itemize}
  \item The entire symbol tree, constructed at compile time, defines the static structure
  \item Overlay Language prohibits referencing the root from within nested scopes
  \item At runtime, scopes can be \textbf{instantiated} (e.g., \texttt{[Succ, predecessor: value]})
  \item Instantiation creates new runtime instances, enabling conceptually infinite paths
\end{itemize}

\textbf{Example of infinite path:}

Consider \texttt{Nat.Succ.Addition.\_increased\_addend}, which instantiates a new \texttt{Succ}. That instance also has \texttt{Addition.\_increased\_addend}, creating an infinite chain:

\[
\texttt{Succ.Addition.\_increased\_addend.Addition.\_increased\_addend.Addition.\_increased\_addend...}
\]

\textbf{Key insight:}
\begin{itemize}
  \item The \textbf{symbol tree is finite} (compile-time)
  \item Runtime \textbf{paths can be infinite} (via recursive instantiation)
  \item But every \textbf{finite-depth access terminates} (weak totality)
\end{itemize}

\subsection{Lazy Evaluation}

\textbf{Lazy evaluation} (also called call-by-need) means:
\begin{itemize}
  \item Values are not computed until they are accessed
  \item Each value is computed at most once (memoized)
  \item Enables conceptually infinite structures (via recursive instantiation)
  \item Breaks circular dependencies by delaying computation
\end{itemize}

\textbf{Example in Haskell:}
\begin{lstlisting}[style=haskell]
ones :: [Int]
ones = 1 : ones  -- Infinite list of 1s

take 5 ones  -- [1,1,1,1,1] - terminates!
\end{lstlisting}

In Overlay Language, lazy evaluation ensures that accessing any finite depth terminates, even when the conceptual structure is infinite.

\subsection{Instantiation Levels}

To ensure weak totality, Overlay Language uses a concept similar to \textbf{universe levels} in type theory.

\textbf{Instantiation level} is a partial order:
\begin{itemize}
  \item \textbf{Level 0}: Static symbol tree nodes (compile-time)
  \item \textbf{Level $n+1$}: Runtime instances created via scope instantiation (e.g., \texttt{[Succ, ...]})
  \item Higher levels can reference lower levels (structural recursion)
  \item References across instantiation boundaries are safe
\end{itemize}

\textbf{Example:}
\begin{verbatim}
Succ.Addition._increased_addend  -- Level 0 → Level 1
  .Addition._increased_addend    -- Level 1 → Level 2
    .Addition._increased_addend  -- Level 2 → Level 3
      ...
\end{verbatim}

Each instantiation creates a new level, and references across levels are guaranteed to be structural recursion (accessing subtrees of the original symbol tree).

\subsection{Same-Level DAG Check}

\textbf{The key compile-time check}: Within each scope, all resource dependencies at the \textbf{same instantiation level} must form a DAG (Directed Acyclic Graph).

\textbf{Why this matters:}
\begin{itemize}
  \item Resources at the same level can reference each other
  \item If these references form a cycle, runtime evaluation may not terminate
  \item By enforcing DAG, we prevent same-level circular dependencies
\end{itemize}

\textbf{Example - Illegal (cycle at Level 0):}
\begin{lstlisting}[style=yaml]
A:
  x: [B, y]  # Level 0 resource
B:
  y: [A, x]  # Level 0 resource
# Error: Cycle detected at Level 0!
\end{lstlisting}

\textbf{Example - Legal (cross-level references):}
\begin{lstlisting}[style=yaml]
Succ:
  Addition:
    _increased_addend: [Succ, ...]     # Level 0 → Level 1
    sum: [_increased_addend, Addition] # Level 0 → Level 1
# OK: Cross-level references are not cycles
\end{lstlisting}

\textbf{Compile-time algorithm:}
\begin{enumerate}
  \item For each scope, identify all resources
  \item Build dependency graph considering only \textbf{same-level} references (ignore instantiation)
  \item Check if the graph is a DAG
  \item Reject if cycles detected
\end{enumerate}

This check, combined with instantiation levels and lazy evaluation, guarantees weak totality.

\subsection{Guardedness and Corecursion}

\textbf{Guardedness} (used in Coq/Agda/Idris) means:
\begin{itemize}
  \item Infinite structures must be guarded by constructors
  \item The compiler checks that every recursive call is \textbf{productive}
  \item Requires explicit constructor guards in the syntax
\end{itemize}

\textbf{Corecursion} is dual to recursion:
\begin{itemize}
  \item Recursion \textbf{consumes} finite data (must terminate)
  \item Corecursion \textbf{produces} infinite data (must be productive)
\end{itemize}

Overlay Language uses lazy evaluation instead of explicit guardedness, achieving the same totality guarantee with simpler syntax.

\section{Overlay Language's Four Properties}

\subsection{Property 1: Compile-Time Turing Complete}

The symbol tree construction during compilation can express arbitrary computations:
\begin{itemize}
  \item Symbols can be parameterized (via inheritance and mixins)
  \item Complex types can be computed at compile time
  \item The compilation process itself is Turing complete
\end{itemize}

This is similar to:
\begin{itemize}
  \item C++ template metaprogramming
  \item Dependent types in Agda/Coq/Idris
  \item Haskell's type-level computation
\end{itemize}

\subsection{Property 2: Runtime Total (Weak Totality)}

After compilation (AOT - Ahead-Of-Time), all runtime programs are \textbf{weakly total} (productive):
\begin{itemize}
  \item Every finite-depth access to any value terminates
  \item Conceptually infinite structures are allowed (via recursive instantiation)
  \item Similar to Haskell's \texttt{take n infiniteList} or Coq's coinductive types
\end{itemize}

This is achieved through:
\begin{enumerate}
  \item \textbf{Compile-time check}: Symbol tree must be finite
  \item \textbf{Same-level DAG check}: Resources at the same instantiation level must not form cycles
  \item \textbf{Naming convention}: Lowercase → resource → lazy evaluation
  \item \textbf{Instantiation levels}: Cross-level references are structural recursion
\end{enumerate}

\subsection{Property 3: Circular References}

With lazy evaluation, resources can form cycles while remaining total.

\textbf{Example:}
\begin{lstlisting}[style=yaml]
Tuple1:
  _1: []

foo:
  - [Tuple1]
  - _1: [bar]

bar:
  - [Tuple1]
  - _1: foo
\end{lstlisting}

This creates a cycle: $\texttt{foo.\_1} \to \texttt{bar.\_1} \to \texttt{foo}$

But accessing any finite depth terminates:
\begin{align*}
\texttt{foo.\_1} &= \texttt{bar} \quad \checkmark \\
\texttt{foo.\_1.\_1} &= \texttt{foo} \quad \checkmark \\
\texttt{foo.\_1.\_1.\_1} &= \texttt{bar} \quad \checkmark
\end{align*}

\subsection{Property 4: Lazy Evaluation}

Resources (lowercase names) are evaluated lazily:
\begin{itemize}
  \item Computation is delayed until the value is accessed
  \item Enables infinite structures (streams, infinite trees)
  \item Breaks circular dependencies naturally
\end{itemize}

\textbf{Key difference from Agda/Coq/Idris:}
\begin{itemize}
  \item Agda/Coq/Idris use \textbf{strict evaluation + guardedness}
  \item Overlay Language uses \textbf{lazy evaluation + automatic guards}
\end{itemize}

\section{Example: Church Numerals}

\subsection{Definition}

Church numerals encode natural numbers using the successor function:
\begin{itemize}
  \item $\texttt{Zero}$ represents 0
  \item $\texttt{Succ}(n)$ represents $n + 1$
\end{itemize}

\textbf{Overlay Language encoding:}
\begin{lstlisting}[style=yaml]
Nat:
  Zero:
    Addition:
      addend: []
      sum: [addend]  # 0 + m = m

  Succ:
    predecessor: []  # The n in Succ(n)
    Addition:
      addend: []
      _increased_addend:
        - [Succ]
        - predecessor: [addend]
      _recursive_addition:
        - [predecessor, Addition]
        - addend: [_increased_addend]
      sum: [_recursive_addition, sum]
\end{lstlisting}

\subsection{Addition Algorithm}

The addition is defined by:
\begin{align}
\texttt{Zero} + m &= m \\
\texttt{Succ}(n) + m &= n + \texttt{Succ}(m)
\end{align}

This is \textbf{structurally recursive} because:
\begin{itemize}
  \item The recursive call is on \texttt{predecessor} (which is $n$)
  \item $n$ is structurally smaller than $\texttt{Succ}(n)$
  \item The tree structure ensures $n$ is a child of $\texttt{Succ}(n)$
\end{itemize}

\subsection{Weak Totality Analysis}

\textbf{Symbol tree (finite):}

The static symbol tree has finite nodes:
\begin{verbatim}
Nat
├── Zero
│   └── Addition
│       └── sum
└── Succ
    ├── predecessor (extern)
    └── Addition
        ├── _increased_addend
        ├── _recursive_addition
        └── sum
\end{verbatim}

\textbf{Runtime paths (conceptually infinite):}

However, runtime instantiation can create infinite chains:
\begin{verbatim}
Succ.Addition._increased_addend          (Level 1 Succ instance)
  .Addition._increased_addend            (Level 2 Succ instance)
    .Addition._increased_addend          (Level 3 Succ instance)
      ...
\end{verbatim}

\textbf{Why this is still total (weak totality):}
\begin{enumerate}
  \item \textbf{Same-level DAG check}: Within \texttt{Succ.Addition}, resources form a DAG:
    \[
    \texttt{addend} \leftarrow \texttt{\_increased\_addend} \leftarrow \texttt{\_recursive\_addition} \leftarrow \texttt{sum}
    \]
    No cycles at Level 0 → same-level references terminate.

  \item \textbf{Cross-level structural recursion}: \texttt{\_recursive\_addition} references \texttt{predecessor.Addition}, which is:
    \begin{itemize}
      \item Either \texttt{Zero.Addition} (base case)
      \item Or a \texttt{Succ} instance with smaller \texttt{predecessor}
      \item Structural recursion on input depth
    \end{itemize}

  \item \textbf{Lazy evaluation}: Accessing \texttt{sum} only evaluates the finite chain needed for the specific computation.
\end{enumerate}

\textbf{Overlay Language verifies this automatically} by checking that:
\begin{itemize}
  \item The symbol tree is finite (compile-time)
  \item Same-level dependencies form a DAG (compile-time)
  \item $\Rightarrow$ Every finite access terminates (runtime)
\end{itemize}

\section{Comparison with Other Languages}

\subsection{Comparison Table}

\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Language} & \textbf{Compile-time} & \textbf{Runtime} & \textbf{Circular} & \textbf{Lazy} \\
& \textbf{Turing Complete} & \textbf{Total} & \textbf{References} & \textbf{Evaluation} \\
\hline
\textbf{Overlay Language} & \checkmark & \checkmark & \checkmark & \checkmark \\
\hline
Agda & \checkmark & \checkmark & \checkmark (coind.) & $\times$ \\
\hline
Coq & \checkmark & \checkmark & \checkmark (coind.) & $\times$ \\
\hline
Idris & \checkmark & \checkmark & \checkmark (codata) & $\times$ \\
\hline
Haskell & \checkmark & $\times$ & \checkmark & \checkmark \\
\hline
\end{tabular}
\end{center}

\subsection{Haskell}

\textbf{Properties:}
\begin{itemize}
  \item[+] Lazy evaluation by default
  \item[+] Supports circular references ("tying the knot")
  \item[--] \textbf{Not total}: Allows infinite loops
\end{itemize}

\textbf{Example of non-totality:}
\begin{lstlisting}[style=haskell]
loop :: a
loop = loop  -- Infinite loop allowed!
\end{lstlisting}

\subsection{Agda and Coq}

\textbf{Properties:}
\begin{itemize}
  \item[+] Compile-time Turing complete (dependent types)
  \item[+] Runtime total (termination checker)
  \item[+] Circular references via coinductive types
  \item[--] \textbf{Strict evaluation} (not lazy by default)
  \item[--] \textbf{Manual proofs required}
\end{itemize}

\textbf{Coinductive types in Coq:}
\begin{lstlisting}[style=haskell]
CoInductive Stream : Type :=
  | Cons : nat -> Stream -> Stream.

CoFixpoint ones : Stream :=
  Cons 1 ones.  (* Guarded by Cons constructor *)
\end{lstlisting}

\textbf{Key difference:}
\begin{itemize}
  \item Agda/Coq use \textbf{guardedness checking}
  \item Programmer must ensure recursion is guarded by constructors
  \item Overlay Language uses \textbf{lazy evaluation} (automatic guards)
\end{itemize}

\subsection{Idris}

\textbf{Properties:}
\begin{itemize}
  \item[+] Compile-time Turing complete
  \item[+] Can enforce totality with \texttt{\%default total}
  \item[+] Supports codata (coinductive types)
  \item[--] \textbf{Strict evaluation} (cannot be configured to lazy)
  \item[--] \textbf{Manual proofs required}
\end{itemize}

\textbf{Explicit laziness in Idris:}
\begin{lstlisting}[style=haskell]
data Lazy : Type -> Type where
  Delay : (val : a) -> Lazy a

-- Not default! Must wrap manually
\end{lstlisting}

\section{The Key Innovation: Automatic Totality}

\subsection{Manual vs Automatic Proofs}

\textbf{Traditional total languages (Agda/Coq/Idris):}
\begin{enumerate}
  \item Programmer writes recursive function
  \item Compiler tries to prove termination/productivity
  \item If proof fails, code is \textbf{rejected}
  \item Programmer must rewrite code or provide explicit proof
\end{enumerate}

\textbf{Overlay Language:}
\begin{enumerate}
  \item Programmer writes recursive code using lowercase names
  \item Compiler checks symbol tree is finite
  \item \textbf{Automatically guaranteed total} via lazy evaluation
  \item No proofs required!
\end{enumerate}

\subsection{Example: Comparison}

\textbf{Idris (manual proof required):}
\begin{lstlisting}[style=haskell]
-- Idris may reject if it cannot prove termination
ackermann : Nat -> Nat -> Nat
ackermann Z n = S n
ackermann (S m) Z = ackermann m 1
ackermann (S m) (S n) = ackermann m (ackermann (S m) n)
-- Error: Cannot prove termination!

-- Need to use assert_total or provide proof
\end{lstlisting}

\textbf{Overlay Language (automatic):}
\begin{lstlisting}[style=yaml]
# Just use lowercase - automatically total!
Succ:
  Addition:
    sum: [predecessor, Addition, addend, ...]
    # Automatically verified to terminate
\end{lstlisting}

\subsection{Proof Burden Comparison}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Aspect} & \textbf{Idris/Agda/Coq} & \textbf{Overlay Language} \\
\hline
Structural recursion & Manual proof & \textbf{Automatic (tree)} \\
\hline
Circular references & Guardedness proof & \textbf{Automatic (lazy)} \\
\hline
User knowledge required & Type theory & \textbf{Naming convention} \\
\hline
Rejected code & Unprovable total code & Minimal \\
\hline
Learning curve & Steep & \textbf{Gentle} \\
\hline
Target audience & Type theorists & \textbf{All programmers} \\
\hline
\end{tabular}
\end{center}

\section{Why Overlay Language's Combination is Unique}

\subsection{No Other Language Has All Four Properties}

\begin{itemize}
  \item \textbf{Agda/Coq}: Total but strict, require manual proofs
  \item \textbf{Idris}: Total but strict, require manual proofs
  \item \textbf{Haskell}: Lazy but not total
  \item \textbf{Overlay Language}: \textbf{Total + Lazy + Automatic}
\end{itemize}

\subsection{The Secret: Tree Structure + Naming Convention + Level System}

Overlay Language achieves automatic totality through:

\begin{enumerate}
  \item \textbf{Tree structure} provides the foundation:
    \begin{itemize}
      \item Every symbol has exactly one parent
      \item References to fields go to subtrees
      \item Subtrees are structurally smaller
    \end{itemize}

  \item \textbf{Instantiation levels} enable infinite structures:
    \begin{itemize}
      \item Level 0: Static symbol tree
      \item Level $n+1$: Runtime instances via scope instantiation
      \item Cross-level references are structural recursion
      \item $\Rightarrow$ Infinite paths allowed, but each access terminates
    \end{itemize}

  \item \textbf{Same-level DAG check} prevents non-termination:
    \begin{itemize}
      \item Resources at the same level must form a DAG
      \item Cycles at the same level → compile error
      \item $\Rightarrow$ No infinite loops within a level
    \end{itemize}

  \item \textbf{Naming convention} determines evaluation strategy:
    \begin{itemize}
      \item PascalCase → scope → can be instantiated
      \item lowercase → resource → \textbf{lazy evaluation}
      \item $\Rightarrow$ Finite access to infinite structures is safe
    \end{itemize}

  \item \textbf{Compile-time verification}:
    \begin{itemize}
      \item Check: Symbol tree is finite
      \item Check: Same-level dependencies form DAG
      \item $\Rightarrow$ Runtime weak totality guaranteed
    \end{itemize}
\end{enumerate}

\subsection{Ergonomic Advantage}

\textbf{Traditional total languages:}
\[
\text{Write code} \to \text{Rejected!} \to \text{Learn proofs} \to \text{Rewrite} \to \text{Repeat}
\]

\textbf{Overlay Language:}
\[
\text{Write code with lowercase} \to \checkmark \text{ Automatically total!}
\]

\textbf{Impact:}
\begin{itemize}
  \item \textbf{First total language for everyday programmers}
  \item \textbf{No type theory expertise required}
  \item \textbf{Zero proof burden}
\end{itemize}

\section{Conclusion}

\subsection{Summary}

Overlay Language achieves a unique combination of properties:
\begin{enumerate}
  \item \textbf{Compile-time Turing complete}: Expressive type-level computation
  \item \textbf{Runtime weakly total}: All finite accesses terminate (productivity guarantee)
  \item \textbf{Conceptually infinite structures}: Via recursive instantiation with lazy evaluation
  \item \textbf{Automatic verification}: No manual proofs required
\end{enumerate}

This is accomplished through:
\begin{itemize}
  \item Tree-based symbol structure (provides foundation for structural recursion)
  \item Instantiation levels (enables infinite structures while maintaining safety)
  \item Same-level DAG check (prevents non-terminating cycles)
  \item Naming convention (determines evaluation strategy)
  \item Lazy evaluation (ensures finite accesses to infinite structures terminate)
\end{itemize}

\subsection{Significance}

Overlay Language is the \textbf{first total language accessible to all programmers}:
\begin{itemize}
  \item No type theory background needed
  \item No manual termination proofs
  \item Simple naming convention replaces complex type systems
  \item Combines the safety of Agda/Coq with the ergonomics of Haskell
\end{itemize}

\subsection{Future Work}

Potential extensions to explore:
\begin{itemize}
  \item \textbf{Formal verification}: Prove that instantiation levels + DAG check guarantee weak totality
  \item \textbf{Level inference}: Automatic inference of instantiation levels for better error messages
  \item \textbf{Optimization strategies}: Lazy evaluation optimization for deep instantiation chains
  \item \textbf{Integration with existing type systems}: Explore connections to universe levels in type theory
  \item \textbf{Practical applications}: Verified software development using Overlay Language's automatic totality
\end{itemize}

\section*{Acknowledgments}

This work builds on decades of research in dependent types, lazy evaluation, and termination analysis. We acknowledge the foundational work in Haskell, Agda, Coq, and Idris that inspired Overlay Language's design.

\end{document}
\AtBeginDocument{%
\providecommand\BibTeX{{Bib\TeX}}}

%% Disable ACM-specific metadata for submission
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{listings}
\usepackage{multirow}
\usepackage{graphicx}

\lstdefinestyle{scala}{
  language=Scala,
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false,
  columns=flexible,
}

\lstdefinestyle{nix}{
  language=,
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false,
  columns=flexible,
  commentstyle=\itshape,
  morecomment=[l]{\#},
}

%% Conditional citation: hide self-citations under anonymous review.
%% Use \@firstoftwo / \@secondoftwo so the unchosen branch is never
%% expanded---preventing \cite from writing to the .aux file.
\makeatletter
\if@ACM@anonymous
\newcommand{\selfcite}[2]{#2}%
\else
\newcommand{\selfcite}[2]{#1}%
\fi
\makeatother

\newcommand{\Path}{\mathtt{Path}}
\newcommand{\dom}{\mathtt{dom}}
\newcommand{\properties}{\mathtt{properties}}
\newcommand{\overrides}{\mathtt{overrides}}
\newcommand{\supers}{\mathtt{supers}}
\newcommand{\inherits}{\mathtt{inherits}}
\newcommand{\defines}{\mathtt{defines}}
\newcommand{\bases}{\mathtt{bases}}
\newcommand{\resolve}{\mathtt{resolve}}
\newcommand{\this}{\mathtt{this}}
\newcommand{\snoc}{\mathbin{\triangleright}}
\newcommand{\init}{\mathtt{init}}
\newcommand{\last}{\mathtt{last}}
\newcommand{\qualifiedthis}[1]{#1.\mathbf{this}}
\newcommand{\dbi}[1]{\uparrow^{\!#1}}

%% Semantic functions for the direct λ-calculus fixpoint semantics (Appendix E)
\newcommand{\labels}{\mathtt{labels}}
\newcommand{\children}{\mathtt{children}}
\newcommand{\refs}{\mathtt{refs}}
\newcommand{\callee}{\mathtt{callee}}
\newcommand{\scope}{\mathtt{scope}}

\begin{document}

\title{A Calculus of Inheritance}

\author{Bo Yang}
\affiliation{%
  \institution{Figure AI Inc.}
  \city{San Jose}
  \state{California}
  \country{USA}
}
\email{yang-bo@yang-bo.com}
\thanks{This work was conducted independently prior to the author's employment at Figure AI.}

\begin{abstract}
  Just as the $\lambda$-calculus uses three primitives (abstraction, application, variable) as the foundation of functional programming, inheritance-calculus uses three primitives (record, definition, inheritance) as the foundation of declarative programming. It trivially embeds the $\lambda$-calculus, although the entire semantics rests solely on set theory; as a consequence, all constructs including inheritance are inherently commutative, idempotent, and associative; the linearization problem of multiple inheritance does not arise. This induces a fully abstract semantics of the lazy $\lambda$-calculus with respect to B\"ohm tree equivalence~\cite{barendregt1984lambda}. Inheritance-calculus is distilled from MIXINv2, a practical implementation in which we observed further emergent phenomena: the same code acts as different function colors~\cite{nystrom2015color}; ordinary arithmetic yields the relational semantics of logic programming~\cite{vanemden1976semantics}; self-reference resolves to multiple targets; and programs are immune to the Expression Problem~\cite{wadler1998expression}. This makes inheritance-calculus strictly more expressive than the $\lambda$-calculus in both common sense and Felleisen's sense~\cite{felleisen1991expressive}.
\end{abstract}

\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10010124.10010131</concept_id>
  <concept_desc>Theory of computation~Program semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010128</concept_id>
  <concept_desc>Theory of computation~Object oriented constructs</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010127</concept_id>
  <concept_desc>Theory of computation~Functional constructs</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010125.10010129</concept_id>
  <concept_desc>Theory of computation~Program schemes</concept_desc>
  <concept_significance>100</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011039</concept_id>
  <concept_desc>Software and its engineering~Formal language definitions</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
  <concept_desc>Software and its engineering~Extensible languages</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
  <concept_desc>Software and its engineering~Object oriented languages</concept_desc>
  <concept_significance>100</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program semantics}
\ccsdesc[500]{Theory of computation~Object oriented constructs}
\ccsdesc[300]{Theory of computation~Functional constructs}
\ccsdesc[100]{Theory of computation~Program schemes}
\ccsdesc[500]{Software and its engineering~Formal language definitions}
\ccsdesc[500]{Software and its engineering~Extensible languages}
\ccsdesc[100]{Software and its engineering~Object oriented languages}

\keywords{declarative programming, inheritance, fixpoint semantics,
  self-referential records, expression problem,
  \texorpdfstring{$\lambda$-calculus}{lambda-calculus},
\texorpdfstring{B\"ohm trees}{Bohm trees}, configuration languages}

\maketitle

\section{Introduction}
\label{sec:introduction}

Declarative and configuration languages are ubiquitous in modern software
engineering. Systems such as NixOS modules~\cite{dolstra2010nixos,nixosmodules},
Jsonnet~\cite{jsonnet}, Hydra~\cite{hydra2023}, CUE~\cite{cue2019}, Dhall~\cite{dhall2017},
Kustomize~\cite{kustomize}, and JSON Patch~\cite{rfc6902} all provide mechanisms for composing
structured data through inheritance or merging. Among these, the NixOS
module system stands out: its recursive attribute set merging with
fixpoint semantics and deferred modules~\cite{nixosmodules} achieves
considerable expressiveness in practice, and the mechanism has been adopted well beyond NixOS itself: Home
Manager~\cite{homemanager}, nix-darwin~\cite{nixdarwin},
disko~\cite{disko}, flake-parts~\cite{flakeparts},
dream2nix~\cite{dream2nix}, devenv~\cite{devenv},
KubeNix~\cite{kubenix}, and nixidy~\cite{nixidy} use it to manage
user environments, macOS configuration, disk partitioning, flake
structure, multi-language packaging, developer environments, and
Kubernetes clusters respectively. Yet no computational
theory explains \emph{why} this mechanism is so expressive.

The $\lambda$-calculus serves as the foundational computational model for
functional programming. No analogous calculus exists for declarative
programming. This gap matters because the two paradigms differ in
fundamental ways. Configuration languages are inherently declarative:
their values are \emph{immutable} and they have \emph{no first-class
functions}. At first glance, Turing completeness appears incompatible
with these constraints. The three classical models of computation each
violate at least one of them:

\begin{center}
  \begin{tabular}{lccc}
    \textbf{Model} & \textbf{Turing complete} & \textbf{Immutable} & \textbf{No $\lambda$} \\
    \hline
    Turing Machine     & $\checkmark$ & $\times$     & $\checkmark$ \\
    $\lambda$-calculus & $\checkmark$ & $\checkmark$ & $\times$ \\
    RAM Machine        & $\checkmark$ & $\times$     & $\checkmark$ \\
  \end{tabular}
\end{center}

\noindent
The Turing Machine and RAM Machine require mutable state;
the $\lambda$-calculus requires first-class functions.
A computational model that is Turing complete, immutable, and
function-free would sit in the empty cell of this table.
The NixOS module system already suggests that such a model exists:
its inheritance-based composition over recursive records, without
explicit functions, is expressive enough to configure entire operating
systems.

Conventionally, the value domain of configuration languages is assumed
to consist of finite, well-founded structures, that is, initial algebras in the
sense of universal algebra. We challenge this assumption: configuration
values are better understood as lazily observable, possibly infinite
structures, where
semantics is determined by the observer and a finite prefix suffices
for any finite observation. This is not merely a theoretical
distinction: the \texttt{nixpkgs} package
collection~\cite{dolstra2006purely} (over 100{,}000
packages) behaves as a lazily observed structure in practice, allowing any
single package to be evaluated without materializing the entire set.
Guided by this observation, we set out to reduce the
NixOS module system to a minimal set of primitives.
The reduction produced MIXIN, an early implementation in Nix,
and subsequently
MIXINv2\selfcite{~\cite{mixin2025}}{~(included as supplementary
material)}, now implemented in Python: a declarative programming
language with only three constructs (record literals, properties,
and inheritance) and no functions or let-bindings.

In developing real programs in MIXINv2, including boolean logic and
natural number arithmetic (Section~\ref{sec:case-study}) and a web application
(Section~\ref{sec:practical-function-color}), the
linearization problem of mixin-based
systems~\cite{bracha1990mixin,c3linearization} did not arise:
because records are sets, inheritance is inherently commutative,
idempotent, and associative (Section~\ref{sec:mixin-trees}).
Self-reference naturally resolves to \emph{multiple objects} rather than
one; prior systems assume single-object resolution and reject the
multi-path situation (Scala, NixOS module system).
Self-referential records require no fixed-point combinator---the
mixin tree \emph{is} the call stack, and qualified this resolution
is a first-order set-theoretic query, not a fixed-point construction.
We also found that boolean logic and arithmetic, implemented as separate
MIXINv2 files, extend in both dimensions of the Expression
Problem~\cite{wadler1998expression} without any dedicated mechanism.
Church-encoded values automatically form trie structures, and
operations on tries automatically become Cartesian products, so that
adding $\{1,2\}$ to $\{3,4\}$ yields $\{4,5,6\}$, which
is the relational semantics of logic programming~\cite{vanemden1976semantics}
(Section~\ref{sec:case-study}); and that the same web
application MIXINv2 file runs under both Python asyncio and synchronous
execution without modification, an instance of function color
blindness~\cite{nystrom2015color}, equivalently CPS-agnostic behavior
(Section~\ref{sec:practical-function-color}).

This paper distills these observations into \textbf{inheritance-calculus},
a minimal computational model for declarative programming.
\emph{Function application translates directly into inheritance}:
a $\lambda$-abstraction corresponds to a record with an
$\mathrm{argument}$ slot and a $\mathrm{result}$ slot, and function
application corresponds to inheriting from the function record and a record
that supplies the argument. Since the $\lambda$-calculus embeds into
inheritance-calculus, inheritance-calculus is Turing complete.
The translation reveals an asymmetry: embedding the
$\lambda$-calculus into inheritance-calculus requires five local,
syntax-directed rules
(Section~\ref{sec:forward-translation}), but the reverse is
not macro-expressible.
Inheritance-calculus enables open extension that changes
operational equivalence on $\lambda$-terms, establishing that
inheritance-calculus is strictly more expressive than its
sublanguage isomorphic to the lazy $\lambda$-calculus, in
Felleisen's sense~\cite{felleisen1991expressive}
(Section~\ref{sec:asymmetry}).

Just as the $\lambda$-calculus uses three primitives (abstraction,
application, variable) to serve as the foundation of functional
programming, inheritance-calculus uses three primitives (record, definition,
inheritance) to serve as the foundation of declarative programming.

All constructions in this paper have been implemented and tested in
MIXINv2,
\selfcite{available as open source~\cite{mixin2025}}{included as supplementary material},
with a test suite covering every example.%
\footnote{MIXINv2 is statically typed and therefore
  stricter than the untyped inheritance-calculus.
  All examples in this paper are ported from MIXINv2
  and conform to both semantics.
  Elements added to satisfy the type checker are harmless
for the algorithms presented here and may aid readability.}
All tests are mechanically verified against expected output snapshots.

\paragraph{Contributions}
\begin{itemize}
  \item We present inheritance-calculus, a minimal computational model for
    declarative programming that contains three constructs (record,
    definition, inheritance) and no functions or scalar types.
  \item The mixin is a single abstraction that unifies class,
    method, object, and property.
    Method-level overriding is subsumed by deep merge of mixin
    trees; inheritance is commutative, idempotent,
    and associative, and the linearization problem of prior mixin
    and trait calculi does not arise.
  \item The semantics is \emph{observational}: there are no
    reduction rules, no evaluation order, and no notion of a result
    that a term reduces to.  The observer drives computation by
    querying paths in a lazily constructed tree.
  \item Self-referential records require no fixed-point combinator;
    the mixin tree \emph{is} the call stack.
    Self-reference resolves to \emph{multiple objects}, not one---a
    situation that prior systems reject
    (Appendix~\ref{app:scala-multi-path})---but since inheritance
    is idempotent, all objects contribute equally without
    disambiguation.
  \item The $\lambda$-calculus translates into
    inheritance-calculus in five rules (Section~\ref{sec:translation}).
    The translation is fully abstract with respect to
    B\"ohm tree equivalence under $\lambda$-definable contexts
    (Section~\ref{sec:bohm-tree}).
  \item The induced semantics is the first fully abstract
    and computable semantics of the lazy
    $\lambda$-calculus that lives entirely in naive set
    theory, requiring no separate operational semantics.
    The same technique also applies to the
    $\lambda$-calculus without passing through
    inheritance-calculus (Appendix~\ref{app:lambda-fixpoint}).
  \item Inheritance-calculus is strictly more expressive than
    the lazy $\lambda$-calculus in Felleisen's
    sense~\cite{felleisen1991expressive}
    (Section~\ref{sec:asymmetry}).
  \item We observe further properties: immunity to
    nonextensibility in the sense of the
    Expression Problem~\cite{wadler1998expression}
    (Section~\ref{sec:expression-problem}), relational semantics of logic
    programming from ordinary arithmetic
    (Section~\ref{sec:case-study}), and function color
    blindness~\cite{nystrom2015color}
    (Section~\ref{sec:practical-function-color}).
\end{itemize}

Section~\ref{sec:case-study} demonstrates these properties
through a case study of Nat arithmetic.

\section{Syntax}
\label{sec:syntax}

Let $e$ denote an expression.
Let $\ell$ denote a label (property name).
Let $k$ denote a nonnegative integer (path length).

\begin{align*}
  e \quad ::= \quad & \{c_1,\; \ldots,\; c_m\}
  && \text{(} m \ge 0 \text{)} \\
  \mid\quad & c
  && \text{(sugar for } \{c\} \text{)} \\[6pt]
  c \quad ::= \quad & \ell \mapsto e
  && \text{(definition)} \\
  \mid\quad & [\qualifiedthis{\ell_{\mathrm{up}}}. \mid \dbi{n}.]\;\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}
  && \text{(inheritance, } k \ge 0 \text{ with qualifier,} \\
  &&& k \ge 1 \text{ without)}
\end{align*}

An expression is a \emph{set} of elements enclosed in braces.
Each element is either a definition $\ell \mapsto e$ or
an inheritance source.
Because expressions are sets, element order is irrelevant and
duplicates have no effect; inheritance is inherently commutative,
idempotent, and associative.

The $\mapsto$ in $\ell \mapsto e$ defines a property, not a let-binding.
There is no variable binding in inheritance-calculus.
MIXINv2 also provides scalar types through a
foreign-function interface (FFI); inheritance-calculus is what remains
after removing the FFI.
None of the examples in this paper uses the FFI; scalars
did not arise.

\paragraph{Inheritance}
An inheritance is written as a reference
that navigates the scope hierarchy upward and then projects
properties downward. The upward navigation admits two equivalent
notations:
\begin{description}
  \item[Named form]
    $\qualifiedthis{\ell_{\mathrm{up}}}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$,
    analogous to Java's \texttt{Outer.this.field}.
    Each $\{\ldots\}$ record has a label in its enclosing scope;
    $\ell_{\mathrm{up}}$ names the target enclosing scope.
  \item[Indexed form]
    $\dbi{n}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$,
    where $n \ge 0$ is a de~Bruijn index~\cite{debruijn1972lambda}:
    $n = 0$ refers to the reference's enclosing scope,
    and each increment of $n$ moves one scope level further out.
\end{description}
Both forms retrieve the target scope, that is, the fully inherited record
after all inheritance has been applied, and then project properties
$\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$ from it.
The named form desugars to the indexed form during parsing
(Section~\ref{sec:mixin-trees}).

A new scope level is created at each $\{\ldots\}$ record literal.
The scope contains all properties of that mixin, including those
inherited via inheritance sources.
For example, $\{a \mapsto \{\},\; b \mapsto \{\}\}$ is a single mixin whose scope
contains both $a$ and $b$; so is $\{r,\; a \mapsto \{\}\}$ where $r$
is a reference to a record containing $b$.
Inheritance sources do not create additional scope levels.

\begin{itemize}
  \item $\qualifiedthis{\mathrm{Foo}}$ (equivalently, $\dbi{n}$ where
    $\mathrm{Foo}$ is $n$ steps above the enclosing scope)
    retrieves the record named $\mathrm{Foo}$.
  \item $\qualifiedthis{\mathrm{Foo}}.\ell$ (equivalently, $\dbi{n}.\ell$)
    projects property $\ell$ from $\mathrm{Foo}$.
  \item When $k = 0$, the reference inherits the entire
    enclosing scope, which may produce an infinitely deep tree.
\end{itemize}

When the qualifier is unambiguous, it may be omitted:
the shorthand
$\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}$ ($k \ge 1$)
resolves $\ell_{\mathrm{down},1}$ against the innermost enclosing
scope whose $\defines$ contains it,
and desugars to the corresponding indexed form.
Since this uses $\defines$, the shorthand can only access
properties defined in record literals, not those inherited through
inheritance; one of the two qualified forms is required for
inherited properties or to bypass variable shadowing.

\section{Mixin Trees}
\label{sec:mixin-trees}

In object-oriented programming, a
\emph{mixin}~\cite{bracha1990mixin} is a fragment of behavior
that can be composed onto a class via inheritance.
Inheritance-calculus has a single abstraction, the
\emph{deep-mergeable mixin},%
\footnote{Where no ambiguity arises, we write simply ``mixin.''
  The distinction from the Bracha--Cook
  mixin~\cite{bracha1990mixin} is detailed in
Section~\ref{sec:related-work}.}
which can simultaneously serve as field, method, class, and
object, because there are no opaque methods: every value is
a transparent record, and inheritance always performs a deep
merge of subtrees.
We call the resulting structure a \emph{mixin tree}.
Its semantics is purely \emph{observational}: given an
inheritance-calculus program, one queries whether a
label $\ell$ is a property at a given position $p$.

This section defines the semantics via
six mutually recursive set-comprehension equations over
paths~\cite{vanemden1976semantics,aczel1977inductive}.
The equations are well-defined for every query whose
recursive evaluation terminates: the reachable dependency
subgraph is necessarily finite and acyclic, so the equations
have a unique solution
(Appendix~\ref{app:well-definedness}).
The six equations map object-oriented concepts to
set-theoretic operations: $\properties$ and $\supers$
generalize member lookup and inheritance chains,
$\overrides$ and $\bases$ capture method override and
base classes, and $\resolve$ and $\this$ handle name
resolution and self-reference.

\subsection{Definitions}

\paragraph{Path}
A $\Path$ is a sequence of labels
$(\ell_1, \ell_2, \ldots, \ell_n)$ that identifies a position in
the tree.
We write $p$ for a path.
The \emph{root path} is the empty sequence $()$.
Given a path $p$ and a label $\ell$,
$p \snoc \ell$ is the sequence $p$ extended with $\ell$.
For a nonroot path, the parent path $\init(p)$ is $p$ with
its last element removed,
and the final label $\last(p)$ is the last element of $p$.
For convenience, we sometimes write $\ell$ for $\last(p)$
when the path is clear from context.
With paths in hand, we can state what the AST provides
at each path.

\paragraph{AST}
An expression $e$ (Section~\ref{sec:syntax}) is parsed into an AST.
The AST provides two primitive functions at each path $p$:
\begin{itemize}
  \item $\defines(p)$: the set of labels
    that have subtrees at $p$.
  \item $\inherits(p)$: the set of reference pairs
    $(n,\; \ell_{\mathrm{down},*})$,
    where $n$ is the de~Bruijn index
    and $\ell_{\mathrm{down},*}$ is the list of downward projections.
\end{itemize}

During parsing, all three syntactic forms are resolved to
de~Bruijn index pairs $(n,\; \ell_{\mathrm{down},*})$.
The \emph{indexed form}
$\dbi{n}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$
already carries the de~Bruijn index $n$ directly;
no resolution is needed.
A \emph{named reference}
$\qualifiedthis{\ell_{\mathrm{up}}}.\ell_{\mathrm{down},1}\ldots\ell_{\mathrm{down},k}$
at path $p$ is resolved by finding the last occurrence of
$\ell_{\mathrm{up}}$ among the labels of $p$.
Let $p_{\mathrm{target}}$ be the prefix of $p$ up to and including
that occurrence.
The de~Bruijn index is $n = |p| - |p_{\mathrm{target}}| - 1$
and the projections are
$\ell_{\mathrm{down},*} = (\ell_{\mathrm{down},1}, \ldots, \ell_{\mathrm{down},k})$.
A \emph{lexical reference} $\ell_{\mathrm{down},1}.\ell_{\mathrm{down},2}\ldots\ell_{\mathrm{down},k}$ at path $p$
is resolved by finding the nearest prefix $p'$ of $p$
such that $\ell_{\mathrm{down},1} \in \defines(p')$.
The de~Bruijn index is $n = |p| - |p'| - 1$ and the projections are
$\ell_{\mathrm{down},*} = (\ell_{\mathrm{down},1}, \ldots, \ell_{\mathrm{down},k})$.
All three forms produce the same representation; the semantic functions
below operate only on de~Bruijn index pairs.

Parsing populates $\defines$ and $\inherits$ from each
element of a record.
A definition $\ell \mapsto e$
contributes $\ell$ to $\defines(p)$.
A reference contributes $(n,\; \ell_{\mathrm{down},*})$ to $\inherits(p)$.
Since records are sets, the order of elements is irrelevant and
duplicate elements have no effect.
Both $\defines$ and $\inherits$ are pure data; they are not functions
of runtime state.
Given these two primitives, we can now answer the question
posed at the beginning of this section.

\paragraph{Properties}
The properties of a path are its own properties together with
those inherited from all supers:
\begin{equation}\label{eq:properties}
  \properties(p) =
  \bigl\{\; \ell \;\big|\;
    (\_,\; p_{\mathrm{override}}) \in \supers(p),\;
    \ell \in \defines(p_{\mathrm{override}})
  \;\bigr\}
\end{equation}
The remainder of this section defines $\supers$,
the transitive inheritance closure,
and its dependencies.

\paragraph{Supers}
Intuitively, $\supers(p)$ collects every path that $p$ inherits from:
the $\overrides$ of $p$ itself,
plus the $\overrides$ of each
direct base $\bases$ of $p$, and so on transitively.
Each result is paired with the inheritance-site context
$\init(p_{\mathrm{base}})$ through which it is reached.
This provenance is needed by qualified this resolution, i.e.\ the $\this$ function defined below,
to map a definition-site mixin back to
the inheritance-site paths that incorporate it:
\begin{equation}\label{eq:supers}
  \supers(p) =
  \bigl\{\; (\init(p_{\mathrm{base}}),\; p_{\mathrm{override}}) \;\big|\;
    p_{\mathrm{base}} \in \bases^*(p),\;
    p_{\mathrm{override}} \in \overrides(p_{\mathrm{base}})
  \;\bigr\}
\end{equation}
Here $\bases^*$ denotes the reflexive-transitive closure of $\bases$.
The $\supers$ formula depends on two functions:
$\overrides$ and the one-hop reference targets $\bases$.
We define $\overrides$ first.

\paragraph{Overrides}
Since a mixin can play the role of a method,
a child scope should be
able to find it through the parent's label even if the child
does not redefine that label---this is method override.
Concretely, inheritance can introduce multiple
definitions of the same label at the same scope level;
$\overrides(p)$ collects all such paths that share the
\emph{same identity} as $p$, so that their definitions
merge rather than shadow each other, enabling deep merge.
The overrides of $p$ include $p$ itself
and $p_{\mathrm{branch}} \snoc \last(p)$ for every
branch $p_{\mathrm{branch}}$ of $\init(p)$ that also defines $\last(p)$:
\begin{equation}\label{eq:overrides}
  \overrides(p) =
  \begin{cases}
    \{p\} & \text{if } p = ()  \\[6pt]
    \{p\}
    \;\cup\;
    \left\{\; p_{\mathrm{branch}} \snoc \last(p) \;\left|\;
      \begin{aligned}
        &(\_,\; p_{\mathrm{branch}}) \in \supers(\init(p)), \\
        &\text{s.t.}\; \last(p) \in \defines(p_{\mathrm{branch}})
      \end{aligned}
    \right.\right\}
    & \text{if } p \neq ()
  \end{cases}
\end{equation}
It remains to define $\bases$, the other dependency of $\supers$.

\paragraph{Bases}
Intuitively, $\bases(p)$ are the paths that $p$ directly
inherits from via references, analogous to the direct base
classes in object-oriented languages.
Concretely, $\bases$ resolves every reference in
$p$'s $\overrides$ one step:
\begin{equation}\label{eq:bases}
  \bases(p) =
  \left\{\; p_{\mathrm{target}} \;\left|\;
    \begin{aligned}
      &p_{\mathrm{override}} \in \overrides(p), \\
      &(n,\; \ell_{\mathrm{down},*}) \in \inherits(p_{\mathrm{override}}), \\
      &p_{\mathrm{target}} \in \resolve(\init(p),\; p_{\mathrm{override}},\; n,\; \ell_{\mathrm{down},*})
    \end{aligned}
  \right.\right\}
\end{equation}
The $\bases$ formula calls the reference resolution function $\resolve$, which we define next.

\paragraph{Reference resolution}
Intuitively, $\resolve$ turns a syntactic reference into the
set of paths it points to in the fully inherited tree.
It takes an inheritance-site path $p_{\mathrm{site}}$,
a definition-site path $p_{\mathrm{def}}$,
a de~Bruijn index $n$,
and downward projections $\ell_{\mathrm{down},*}$.
Resolution proceeds in two phases:
$\this$ performs $n$ upward steps
starting from the enclosing scope $\init(p_{\mathrm{def}})$,
mapping the definition-site path to inheritance-site paths;
then the downward projections $\ell_{\mathrm{down},*}$ are appended:
\begin{multline}\label{eq:resolve}
  \resolve(p_{\mathrm{site}},\; p_{\mathrm{def}},\; n,\; \ell_{\mathrm{down},*})
  = \\
  \bigl\{\;
    p_{\mathrm{current}} \snoc \ell_{\mathrm{down},1} \snoc \cdots \snoc \ell_{\mathrm{down},k}
    \;\big|\;
    p_{\mathrm{current}} \in
    \this(\{p_{\mathrm{site}}\},\; \init(p_{\mathrm{def}}),\; n)
  \;\bigr\}
\end{multline}
When multiple routes exist due to multi-path inheritance,
they may yield different target paths; all are collected.
We now define $\this$.

\paragraph{Qualified this resolution}
$\this$ answers the question:
``in the fully inherited tree, where does
the definition-site scope $p_{\mathrm{def}}$ actually live?''
Each step finds, among the supers of every path in the
frontier $S$, those whose override component matches
$p_{\mathrm{def}}$, and collects the corresponding
inheritance-site paths as the new frontier.
After $n$ steps the frontier contains the answer:
{\small
  \begin{equation}\label{eq:this}
    \this(S,\; p_{\mathrm{def}},\; n) =
    \begin{cases}
      S & \text{if } n = 0 \\[6pt]
      \this\!\left(
        \left\{\; p_{\mathrm{site}} \;\left|\;
          \begin{aligned}
            &p_{\mathrm{current}} \in S, \\
            &(p_{\mathrm{site}},\; p_{\mathrm{override}})
            \in \supers(p_{\mathrm{current}}), \\
            &\text{s.t.}\; p_{\mathrm{override}} = p_{\mathrm{def}}
          \end{aligned}
        \right.\right\},\;
        \init(p_{\mathrm{def}}),\;
        n - 1
      \right)
      & \text{if } n > 0
    \end{cases}
\end{equation}}%
At each step $\init$ shortens $p_{\mathrm{def}}$ by one label
and $n$ decreases by one.
Since $n$ is a nonnegative integer, the recursion terminates.

This completes the chain of definitions needed to compute $\properties(p)$.

\subsection{Recursive Evaluation}
The six equations
(\ref{eq:properties})--(\ref{eq:this}) define set membership
recursively:
$\ell \in \properties(p)$ holds if and only if it can
be established by a finite chain of applications of
these equations.
Well-definedness follows from a termination argument:
if the recursive evaluation terminates, the reachable
dependency subgraph is finite and acyclic, and the equations
have a unique solution
(Appendix~\ref{app:well-definedness}).
When no finite derivation exists for a given query, the
recursive evaluation does not terminate, analogous to
divergence in the $\lambda$-calculus.

The equations \emph{are} the interpreter: the observer
drives the computation by choosing which path to inspect,
and the equations unfold on demand.
The equations are pure and order-independent, so the
reflexive-transitive closure $\bases^*$
in~(\ref{eq:supers}) may be explored breadth-first or
depth-first without affecting the result;
paths may be \emph{interned} so that structural equality
reduces to pointer equality;
and the six equations form a memoizable
dynamic-programming recurrence keyed by paths.
No separate operational semantics is needed.

\section{Embedding the \texorpdfstring{$\lambda$}{λ}-Calculus}
\label{sec:translation}
\label{sec:forward-translation}

The following translation maps the $\lambda$-calculus in
A-normal form (ANF)~\cite{flanagan1993essence} to inheritance-calculus.
In ANF, every intermediate result is bound to a name and each
expression contains at most one application:
\[
  \begin{array}{r@{\;::=\;}l}
    M & \mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M
    \mid V_1\; V_2
    \mid V \\
    V & x \mid \lambda x.\, M
  \end{array}
\]
Every $\lambda$-term can be mechanically converted to ANF by
naming intermediate results, and every ANF term is a
$\lambda$-term, so ANF is neither a restriction nor an
extension of the $\lambda$-calculus.
The ANF structure matches inheritance-calculus naturally: each
$\mathbf{let}$-binding becomes a named record property, and
each application is wrapped and projected via
$.\mathrm{result}$.

Let $\mathcal{T}$ denote the translation function.
Each $\lambda$-abstraction introduces one scope level
in the translated mixin tree.

\medskip
\begin{center}
  \begin{tabular}{l@{\qquad$\longrightarrow$\qquad}l}
    $x$ \text{\small($\lambda$-bound, index $n'$)} &
    $\dbi{n'}.\mathrm{argument}$ \\[4pt]
    $x$ \text{\small(let-bound)} &
    $x.\mathrm{result}$ \\[4pt]
    $\lambda x.\, M$ &
    $\{\mathrm{argument} \mapsto \{\},\;
    \mathrm{result} \mapsto \mathcal{T}(M)\}$ \\[4pt]
    $\mathbf{let}\; x = V_1\; V_2
    \;\mathbf{in}\; M$ &
    $\{x \mapsto \{\mathcal{T}(V_1),\;
      \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto \mathcal{T}(M)\}$ \\[4pt]
    $V_1\; V_2$ \text{\small(tail call)} &
    $\{\mathrm{tailCall} \mapsto \{\mathcal{T}(V_1),\;
      \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto \mathrm{tailCall}.\mathrm{result}\}$
  \end{tabular}
\end{center}
\medskip

A $\lambda$-bound variable $x$ with de~Bruijn index $n$
(the number of enclosing $\lambda$s between
the reference and its binder) becomes
$\dbi{n'}.\mathrm{argument}$,
which reaches the abstraction that binds $x$ and
accesses its $\mathrm{argument}$ slot.%
\footnote{In the $\lambda$-calculus, de~Bruijn
  indices count only $\lambda$-abstractions.
  In inheritance-calculus, de~Bruijn indices count all
  enclosing scope levels, including those introduced by
  $\mathbf{let}$-bindings and tail calls.
  The translation therefore adjusts the index:
  if a $\lambda$-bound variable crosses $k$ intervening
  $\mathbf{let}$-binding or tail-call scopes in the ANF
  term, its inheritance-calculus index is $n' = n + k$,
  not~$n$.
  Let-bound variables are unaffected, as they use
  lexical references ($x.\mathrm{result}$) rather than
  de~Bruijn indices.
  We assume that the synthetic labels introduced by the
  translation ($\mathrm{argument}$, $\mathrm{result}$,
  $\mathrm{tailCall}$) and the user-defined labels
  (let-bound names such as~$x$) are drawn from disjoint
  alphabets, so no collision can arise.}
A let-bound variable $x$ becomes the lexical reference
$x.\mathrm{result}$, projecting the application result
from the sibling property $x$ in the enclosing record.

An abstraction $\lambda x.\, M$ translates to a record with own
properties $\{\mathrm{argument}, \mathrm{result}\}$; we call this
the \emph{abstraction shape}.
In the $\mathbf{let}$-binding rule, the name $x$ binds to the
inherited record $\{\mathcal{T}(V_1),\;
\mathrm{argument} \mapsto \mathcal{T}(V_2)\}$, and
$\mathcal{T}(M)$ may reference $x.\mathrm{result}$ to obtain
the value of the application.
In the tail-call rule, the fresh label $\mathrm{tailCall}$ serves
the same purpose, and $\mathrm{result}$ projects the answer.
In both cases the inheritance that performs the application is
\emph{encapsulated} behind a named property, so its internal
structure (the $\mathrm{argument}$ and $\mathrm{result}$ labels
of the callee) does not leak to the enclosing scope.

The five rules above are a complete translation from the
$\lambda$-calculus (via ANF) to inheritance-calculus: every ANF
term has an image, and the construction is compositional.
Since the $\lambda$-calculus is Turing complete, so is
inheritance-calculus.

\subsection{B\"ohm Tree Correspondence}
\label{sec:bohm-tree}

The translation $\mathcal{T}$ induces an elementary semantics on the $\lambda$-calculus
via the mixin tree equations~(\ref{eq:properties})--(\ref{eq:this}).
We show that the induced semantics corresponds precisely to the
B\"ohm tree~\cite{barendregt1984lambda} of the original $\lambda$-term.

A mixin tree $T$ \emph{converges}, written $T{\Downarrow}$,
if following finitely many $\mathrm{result}$ projections from
the root reaches a node with both $\mathrm{argument}$ and
$\mathrm{result}$ among its properties, that is, the \emph{abstraction shape}
produced by $\mathcal{T}(\lambda x.\, M)$.
We write $T{\Uparrow}$ if no such depth exists.

\begin{definition}[Inheritance-convergence]\label{def:convergence}
  A mixin tree $T$ \emph{converges}, written $T{\Downarrow}$,
  if there exists $n \ge 0$ such that:
  \[
    \{\mathrm{argument},\, \mathrm{result}\}
    \;\subseteq\;
    \properties\!\bigl(\,
      \underbrace{\text{root} \snoc \mathrm{result}
      \snoc \cdots \snoc \mathrm{result}}_{n}
    \,\bigr)
  \]
  in the semantics of
  Section~\ref{sec:mixin-trees}.
\end{definition}

\begin{theorem}[Adequacy]\label{thm:adequacy}
  A closed ANF $\lambda$-term $M$ has a head normal form if and
  only if $\mathcal{T}(M){\Downarrow}$.
\end{theorem}

\begin{theorem}[Full abstraction w.r.t.\ $\lambda$-definable contexts]%
  \label{thm:full-abstraction}
  For closed $\lambda$-terms $M$ and $N$, define
  $\mathcal{T}(M) \approx_\lambda \mathcal{T}(N)$ iff for every
  closing $\lambda$-calculus context $C[\cdot]$,
  $\mathcal{T}(C[M]){\Downarrow} \Leftrightarrow
  \mathcal{T}(C[N]){\Downarrow}$.
  Then:
  \[
    \mathcal{T}(M) \approx_\lambda \mathcal{T}(N)
    \quad\Longleftrightarrow\quad
    \mathrm{BT}(M) = \mathrm{BT}(N)
  \]
\end{theorem}

\noindent
Here $\approx_\lambda$ quantifies over $\lambda$-calculus
contexts only; inheritance-calculus contexts are strictly more
discriminating (Section~\ref{sec:asymmetry}).
Together, Adequacy and Full Abstraction establish that
the translation $\mathcal{T}$ is a fully abstract embedding of the
lazy $\lambda$-calculus into inheritance-calculus
with respect to B\"ohm tree
equivalence~\cite{barendregt1984lambda}, using only
elementary recursive evaluation on finite mixin trees,
without lattices, continuous domains, or the topological
infrastructure of domain theory.
This is stronger than Scott's denotational
semantics~\cite{scott1972continuous,wadsworth1976semantics}, which is
adequate but not fully abstract, as it identifies terms that
observational equivalence
distinguishes~\cite{plotkin1975callbyname}.
That recursive evaluation of set-comprehension equations
suffices for full abstraction---without lattices,
inverse limits, or game-theoretic machinery---is the central
semantic result of this paper.%
\footnote{Composing $\mathcal{T}$ with the equations of
  Section~\ref{sec:mixin-trees} yields an elementary semantics
  of the $\lambda$-calculus in which function application is
  record inheritance and convergence is determined by path
  queries.
  Appendix~\ref{app:lambda-fixpoint} reformulates this
  semantics directly on ANF, without passing through
inheritance-calculus.}
The full proof, including the Single-Path Lemma,
Substitution Lemma, and Convergence Preservation, is given
in Appendix~\ref{app:bohm-tree-proofs}.

The relationship between $\approx_\lambda$ and full
inheritance-contextual equivalence is clarified by the expressive
asymmetry of the next section:
inheritance-calculus contexts can separate $\lambda$-terms that are
B\"ohm-tree equivalent, so
${\approx_\lambda} \subsetneq {(\approx_{\mathrm{inh}}|_{\mathrm{im}(\mathcal{T})})}$.
This gap is precisely the source of inheritance-calculus's
additional expressiveness
(Theorem~\ref{thm:cartesian-nonexpressibility}).

\subsection{Expressive Asymmetry}
\label{sec:asymmetry}
\label{sec:formal-separation}
Two $\lambda$-terms that are B\"ohm-tree equivalent---and
therefore indistinguishable in the $\lambda$-calculus---can be
separated in inheritance-calculus by inheriting new observable
projections onto an existing definition via open extension.
By Felleisen's expressiveness
criterion~\cite{felleisen1991expressive}, inheritance-calculus is
strictly more expressive than its sublanguage $\mathscr{L}_0$
(isomorphic to the lazy $\lambda$-calculus under observational
equivalence):
the forward embedding is macro-expressible
(Theorem~\ref{thm:forward-macro}), but $\mathscr{L}_0$
cannot macro-express inheritance
(Theorem~\ref{thm:cartesian-nonexpressibility}).
The formal definitions, constructions, and proofs are given in
Appendix~\ref{app:expressiveness};
the separating construction is itself a miniature instance of
the Expression Problem, adding a new observable projection to
an existing definition without modifying it.

The underlying mechanism is open extension: mixin
definitions compose via open recursion, so existing
definitions gain new observable properties without
modification.  In the $\lambda$-calculus, a function's result
is closed---there is no way to add new observable projections
to an already-computed value without modifying the function's
definition.

\section{Case Study: Nat Arithmetic}
\label{sec:case-study}
\label{sec:expression-problem}

We implemented boolean logic and natural number arithmetic, both unary
and binary, as MIXINv2
files\selfcite{~\cite{mixin2025}}{~(supplementary material)}.
This section traces the unary Nat case in detail.
The implementation follows a declarative object-oriented style:
each concern is one file;
UpperCamelCase names are constructors and operations;
lowerCamelCase names are fields and parameters;
and since there are no methods, all names are nouns or adjectives: $\mathrm{Plus}$
is a structure, not an action.
Operations expose their result through a projection field (e.g., $\mathrm{sum}$).

\paragraph{NatData}
Following the Church-encoding
convention\selfcite{~\cite{mixin2025}}{~(supplementary material)},%
\footnote{The data representation (Zero/Successor) is a Peano
  encoding---an initial algebra of the functor $F(X) = 1 + X$.
  The Visitor pattern (NatVisitor, below) adds the
  Church-encoding behavior: a fold (catamorphism) over this
  algebra.  These two concerns are defined in separate files
  and composed via inheritance, which is itself an instance of
the Expression Problem.}
we define a factory containing the abstract product type and its two
constructors.
A $\mathrm{Zero}$ value inherits $\mathrm{Product}$;
a $\mathrm{Successor}$ value inherits $\mathrm{Product}$ and
exposes a $\mathrm{predecessor}$ field.
The file name $\mathrm{NatData}$ is itself the top-level scope:
\begin{align*}
  \mathrm{NatData} \mapsto \{\;&
    \mathrm{NatFactory} \mapsto \{
      \mathrm{Product} \mapsto \{\},\\
      &\quad
      \mathrm{Zero} \mapsto \{\mathrm{Product}\},\\
      &\quad
      \mathrm{Successor} \mapsto \{
        \mathrm{Product},\;
    \mathrm{predecessor} \mapsto \{\mathrm{Product}\}\}\},\\
    &\mathrm{Nat} \mapsto \{\mathrm{NatFactory},\;
  \mathrm{NatFactory}.\mathrm{Product}\}\}
\end{align*}

\paragraph{NatPlus}
Addition is a separate MIXINv2 file that inherits $\mathrm{NatData}$
and extends each constructor with a $\mathrm{Plus}$ operation
exposing a $\mathrm{sum}$ field.
The base case is $0 + m = m$; the recursive case reduces
$\mathrm{S}(n_0) + m$ to $n_0 + \mathrm{S}(m)$
by delegating to $n_0$'s $\mathrm{Plus}$ with an incremented addend:
\begin{align*}
  \mathrm{NatPlus} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{NatFactory} \mapsto \{\\
      &\quad \mathrm{Product} \mapsto \{\mathrm{Plus} \mapsto \{
      \mathrm{sum} \mapsto \{\mathrm{Product}\}\}\},\\[2pt]
      &\quad \mathrm{Zero} \mapsto \{\mathrm{Plus} \mapsto \{
          \mathrm{addend} \mapsto \{\mathrm{Product}\},\;
      \mathrm{sum} \mapsto \{\mathrm{addend}\}\}\},\\[2pt]
      &\quad \mathrm{Successor} \mapsto \{\mathrm{Plus} \mapsto \{
          \mathrm{addend} \mapsto \{\mathrm{Product}\},\\
          &\qquad
          \mathrm{\_increasedAddend} \mapsto \{
            \mathrm{Successor},\;
          \mathrm{predecessor} \mapsto \{\mathrm{addend}\}\},\\
          &\qquad
          \mathrm{\_recursiveAddition} \mapsto \{
            \qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}.\mathrm{Plus},\\
            &\qquad\quad
          \mathrm{addend} \mapsto \{\mathrm{\_increasedAddend}\}\},\\
          &\qquad
          \mathrm{sum} \mapsto \{
  \mathrm{\_recursiveAddition}.\mathrm{sum}\}\}\}\}\}
\end{align*}

\paragraph{NatEquality}
To test that $2 + 3 = 5$, we needed equality on Nat values.
Equality requires case analysis on the constructor; we use the
Visitor pattern.
$\mathrm{NatVisitor}$ adds a $\mathrm{Visitor}$ operation to each constructor,
with a $\mathrm{Visit}$ field that delegates to the appropriate
$\mathrm{VisitZero}$ or $\mathrm{VisitSuccessor}$ branch:
\begin{align*}
  \mathrm{NatVisitor} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{NatFactory} \mapsto \{\\
      &\quad \mathrm{Product} \mapsto \{\mathrm{Visitor} \mapsto \{
      \mathrm{Visit} \mapsto \{\}\}\},\\[2pt]
      &\quad \mathrm{Zero} \mapsto \{\mathrm{Visitor} \mapsto \{
          \mathrm{VisitZero} \mapsto \{\},\;
      \mathrm{Visit} \mapsto \{\mathrm{VisitZero}\}\}\},\\[2pt]
      &\quad \mathrm{Successor} \mapsto \{\mathrm{Visitor} \mapsto \{
          \mathrm{VisitSuccessor} \mapsto \{\},\;
  \mathrm{Visit} \mapsto \{\mathrm{VisitSuccessor}\}\}\}\}\}
\end{align*}
$\mathrm{BooleanData}$ defines the output sort:
\begin{align*}
  \mathrm{BooleanData} \mapsto \{\;&
    \mathrm{BooleanFactory} \mapsto \{
      \mathrm{Product} \mapsto \{\},\;
      \mathrm{True} \mapsto \{\mathrm{Product}\},\;
    \mathrm{False} \mapsto \{\mathrm{Product}\}\},\\
    &\mathrm{Boolean} \mapsto \{\mathrm{BooleanFactory},\;
  \mathrm{BooleanFactory}.\mathrm{Product}\}\}
\end{align*}
$\mathrm{NatEquality}$ inherits $\mathrm{NatVisitor}$ and $\mathrm{BooleanData}$,
and adds an $\mathrm{Equal}$ operation to each constructor.
$\mathrm{Zero}$ is equal only to another $\mathrm{Zero}$;
$\mathrm{Successor}$ is equal only to another $\mathrm{Successor}$
with an equal predecessor.
Case analysis on $\mathrm{other}$ is done via its $\mathrm{Visitor}$:
{\small
  \begin{align*}
    \mathrm{NatEquality} \mapsto \{\;&
      \mathrm{NatVisitor},\; \mathrm{BooleanData},\\
      &\mathrm{NatFactory} \mapsto \{\\
        &\quad \mathrm{Product} \mapsto \{\mathrm{Equal} \mapsto \{
            \mathrm{other} \mapsto \{\mathrm{Product}\},\\
            &\qquad
            \mathrm{equal} \mapsto \{
        \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\[2pt]
        &\quad \mathrm{Zero} \mapsto \{\mathrm{Equal} \mapsto \{
            \mathrm{other} \mapsto \{\mathrm{Product}\},\\
            &\qquad
            \mathrm{OtherVisitor} \mapsto \{
              \mathrm{other}.\mathrm{Visitor},\\
              &\qquad\;
              \mathrm{VisitZero} \mapsto \{
                \mathrm{equal} \mapsto \{
              \qualifiedthis{\mathrm{NatEquality}}.\mathrm{True}\}\},\\
              &\qquad\;
              \mathrm{VisitSuccessor} \mapsto \{
                \mathrm{equal} \mapsto \{
              \qualifiedthis{\mathrm{NatEquality}}.\mathrm{False}\}\},\\
              &\qquad\;
              \mathrm{Visit} \mapsto \{
                \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\
            &\qquad
            \mathrm{equal} \mapsto \{
        \mathrm{OtherVisitor}.\mathrm{Visit}.\mathrm{equal}\}\}\},\\[2pt]
        &\quad \mathrm{Successor} \mapsto \{\mathrm{Equal} \mapsto \{
            \mathrm{other} \mapsto \{
              \mathrm{Product},\;
            \mathrm{predecessor} \mapsto \{\mathrm{Product}\}\},\\
            &\qquad
            \mathrm{RecursiveEquality} \mapsto \{
              \qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}.\mathrm{Equal},\\
              &\qquad\;
              \mathrm{other} \mapsto \{
            \qualifiedthis{\mathrm{Equal}}.\mathrm{other}.\mathrm{predecessor}\}\},\\
            &\qquad
            \mathrm{OtherVisitor} \mapsto \{
              \mathrm{other}.\mathrm{Visitor},\\
              &\qquad\;
              \mathrm{VisitZero} \mapsto \{
                \mathrm{equal} \mapsto \{
              \qualifiedthis{\mathrm{NatEquality}}.\mathrm{False}\}\},\\
              &\qquad\;
              \mathrm{VisitSuccessor} \mapsto \{
                \mathrm{equal} \mapsto \{
              \mathrm{RecursiveEquality}.\mathrm{equal}\}\},\\
              &\qquad\;
              \mathrm{Visit} \mapsto \{
                \mathrm{equal} \mapsto \{
            \qualifiedthis{\mathrm{NatEquality}}.\mathrm{Boolean}\}\}\},\\
            &\qquad
            \mathrm{equal} \mapsto \{
    \mathrm{OtherVisitor}.\mathrm{Visit}.\mathrm{equal}\}\}\}\}\}
\end{align*}}
Composing $\mathrm{NatPlus}$ with $\mathrm{NatEquality}$ by
inheriting both, with no modifications to either file, gives the
resulting Nat values both $\mathrm{Plus}$ and $\mathrm{Equal}$
automatically.
The concrete numerals live in a shared file that inherits only $\mathrm{NatData}$:
\begin{align*}
  \mathrm{NatConstants} \mapsto \{\;&
    \mathrm{NatData},\\
    &\mathrm{One} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
      &\quad\quad
      \mathrm{predecessor} \mapsto \{
    \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Zero}\}\},\\
    &\mathrm{Two} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
      &\quad\quad
    \mathrm{predecessor} \mapsto \{\mathrm{One}\}\},\\
    &\mathrm{Three} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
      &\quad\quad
    \mathrm{predecessor} \mapsto \{\mathrm{Two}\}\},\\
    &\mathrm{Four} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
      &\quad\quad
    \mathrm{predecessor} \mapsto \{\mathrm{Three}\}\},\\
    &\mathrm{Five} \mapsto \{
      \qualifiedthis{\mathrm{NatConstants}}.\mathrm{NatFactory}.\mathrm{Successor},\\
      &\quad\quad
  \mathrm{predecessor} \mapsto \{\mathrm{Four}\}\}\}
\end{align*}
The arithmetic test inherits $\mathrm{NatConstants}$ together with the operations it needs:
\begin{align*}
  \mathrm{Test} \mapsto \{\;&
    \mathrm{NatConstants},\; \mathrm{NatPlus},\; \mathrm{NatEquality},\\
    &\mathrm{Addition} \mapsto \{
      \qualifiedthis{\mathrm{Test}}.\mathrm{Two}.\mathrm{Plus},\;
    \mathrm{addend} \mapsto \{\qualifiedthis{\mathrm{Test}}.\mathrm{Three}\}\},\\
    &\mathrm{Test2plus3} \mapsto \{
      \qualifiedthis{\mathrm{Test}}.\mathrm{Five}.\mathrm{Equal},\;
  \mathrm{other} \mapsto \{\mathrm{Addition}.\mathrm{sum}\}\}\}
\end{align*}
Querying $\mathrm{Test}.\mathrm{Test2plus3}.\mathrm{equal}$ via the host-language API
returns $\mathrm{True}$.
No existing file was modified.
$\mathrm{NatEquality}$, a new operation, and $\mathrm{Boolean}$,
a new data type, each required only a new file: extensibility in both
dimensions of the Expression Problem~\cite{wadler1998expression}.

\paragraph{Tree-level inheritance and return types}
\label{sec:discussion-expression-problem}
Each operation is an independent mixin that extends a factory's
subtree.
Inheritance recursively merges subtrees that share a label,
so every entity in the factory acquires all operations from all
inherited mixins.
Crucially, this applies to return types: $\mathrm{NatPlus}$ returns
values from $\mathrm{NatFactory}$, and $\mathrm{NatEquality}$
independently adds $\mathrm{Equal}$ to the same factory.
Inheriting both causes the values returned by $\mathrm{Plus}$ to
carry $\mathrm{Equal}$ automatically, without modifying either file.
In object algebras~\cite{oliveira2012extensibility} and finally
tagless interpreters~\cite{carette2009finally}, independently defined
operations do not automatically enrich each other's return types;
additional boilerplate or type-class machinery is required.

Multi-path qualified this (equation~\ref{eq:this}) is essential.
In the test file above, $\mathrm{NatPlus}.\mathrm{Successor}$ and
$\mathrm{NatEquality}.\mathrm{Successor}$ both inherit
$\mathrm{NatData}.\mathrm{Successor}$.
When the two operations are composed, the resulting
$\mathrm{Successor}$ inherits the $\mathrm{NatData}$ schema
through two independent routes.
The reference
$\qualifiedthis{\mathrm{Successor}}.\mathrm{predecessor}$
inside each operation resolves through both routes, and since
inheritance is idempotent, all routes contribute the same
properties.
In Scala, the same pattern, where two independently defined inner
classes extend the same outer class's trait, triggers a
``conflicting base types'' rejection
(Appendix~\ref{app:scala-multi-path}), because DOT's self variable
is single-valued and cannot resolve through multiple inheritance
routes simultaneously.
The Expression Problem can still be \emph{solved} in Scala using
object algebras or similar patterns, but composing independently
defined operations inherently produces multi-path inheritance to
shared schemas, which DOT's single-valued self variable cannot
accommodate.

\paragraph{Church-encoded Nats are tries}
A Church-encoded Nat is a record whose structure mirrors the
constructor path used to build it: $\mathrm{Zero}$ is a flat record;
$\mathrm{S}(\mathrm{Zero})$ is a record with a $\mathrm{predecessor}$
field pointing to a $\mathrm{Zero}$ record; and so on.
This is exactly the shape of a trie.
A scope that simultaneously inherits two Nat values is a trie union.
The following test applies $\mathrm{Plus}$ to a trie union of $\{1,2\}$
with addend a trie union of $\{3,4\}$, then compares the result to itself
with $\mathrm{Equal}$:
\begin{align*}
  \mathrm{CartesianTest} \mapsto \{\;&
    \mathrm{NatConstants},\; \mathrm{NatPlus},\; \mathrm{NatEquality},\\
    &\mathrm{OneOrTwo} \mapsto \{
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{One},\;
    \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Two}\},\\
    &\mathrm{ThreeOrFour} \mapsto \{
      \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Three},\;
    \qualifiedthis{\mathrm{CartesianTest}}.\mathrm{Four}\},\\
    &\mathrm{Result} \mapsto \{
      \mathrm{OneOrTwo}.\mathrm{Plus},\;
    \mathrm{addend} \mapsto \{\mathrm{ThreeOrFour}\}\},\\
    &\mathrm{Check} \mapsto \{
      \mathrm{Result}.\mathrm{sum}.\mathrm{Equal},\;
  \mathrm{other} \mapsto \{\mathrm{Result}.\mathrm{sum}\}\}\}
\end{align*}
$\mathrm{Result}.\mathrm{sum}$ evaluates to the trie $\{4,5,6\}$, the set of all pairwise sums.
$\mathrm{Equal}$ then applies to every pair drawn from $\{4,5,6\} \times \{4,5,6\}$;
querying $\mathrm{CartesianTest}.\mathrm{Check}.\mathrm{equal}$ via the host-language API
returns $\{\mathrm{True}, \mathrm{False}\}$.
The Cartesian product arises directly from the semantic equations.
$\mathrm{OneOrTwo}$ inherits both $\mathrm{One}$ and $\mathrm{Two}$,
so $\bases(\mathrm{OneOrTwo})$ contains two paths.
When $\mathrm{Result}$ inherits
$\mathrm{OneOrTwo}.\mathrm{Plus}$, the $\bases$ of
$\mathrm{Result}$ include the $\mathrm{Plus}$ of both
$\mathrm{One}$ and $\mathrm{Two}$.
Each $\mathrm{Plus}$ resolves its $\mathrm{addend}$ via
$\this$, reaching $\mathrm{ThreeOrFour}$, which is itself a
trie union of $\mathrm{Three}$ and $\mathrm{Four}$:
the $\supers$ of the $\mathrm{addend}$ path contain both values.
Since $\mathrm{Successor}.\mathrm{Plus}$ recursively delegates to
$\mathrm{predecessor}.\mathrm{Plus}$ with an incremented addend,
and $\mathrm{predecessor}$ also resolves through the trie union,
the recursion branches at every trie node.
The result $\mathrm{sum}$ therefore collects all paths reachable
through any combination of the two operands, which is the
Cartesian product.

The same $\mathrm{Plus}$ and $\mathrm{Equal}$ files that operate on
single values thus produce, without modification, the relational
semantics of logic programming:
$\overrides$ and $\supers$ collect all inheritance paths, and
every operation distributes over them.

\section{Discussion}

\subsection{Emergent Phenomena}
\label{sec:reverse-translation}
\label{sec:emergent-phenomena}

In developing real programs in MIXINv2, we encountered three
phenomena that we did not design for.  They can be seen in the
source code\selfcite{~\cite{mixin2025}}{~(supplementary material)}
and the Case Study (Section~\ref{sec:case-study}); below we
explain why they arise from the three primitives.

\begin{description}
  \item[Relational semantics]
    Single-valued computation and set-valued computation are
    the same mechanism.
    The semantic equations of Section~\ref{sec:mixin-trees}
    resolve every property to a set of paths, so operations
    defined on single values automatically distribute over
    all combinations of set-valued inputs
    (Section~\ref{sec:case-study}).
    When a mixin tree is viewed as a trie, the correspondence
    with relational algebra becomes precise.%
    \footnote{Inheritance-calculus to relational algebra:
      path from root to leaf $=$ tuple;
      trie union $=$ relation (set of tuples);
      $\bases$ (equation~\ref{eq:bases}) $=$ cross-join;
      $\supers$ (equation~\ref{eq:supers}) $=$ union;
    $\properties$ (equation~\ref{eq:properties}) $=$ projection.}
    The carrier is a trie rather than a flat relation, and
    observation is coinductive---the observer drives computation
    by querying progressively deeper paths---rather than
    Datalog's bottom-up materialization, but the relational
    structure of the computation is the same.

  \item[Immunity to nonextensibility]
    It is structurally impossible to write a nonextensible program.
    Every construct of inheritance-calculus
    (Section~\ref{sec:syntax}) is extensible via deep merge
    (equation~\ref{eq:overrides}); there is no nonextensible
    construct.
    The Case Study (Section~\ref{sec:case-study}) and the
    Expressive Asymmetry (Section~\ref{sec:asymmetry};
    Theorem~\ref{thm:cartesian-nonexpressibility}) demonstrate
    and formalize this: new operations and data types are added,
    and new observable projections are introduced, without
    modifying existing definitions.
    This is the extensibility that the
    Expression Problem~\cite{wadler1998expression} demands.%
    \footnote{As an untyped calculus, inheritance-calculus cannot violate
      the extensibility requirement of the Expression Problem but does
      not encounter its type-safety requirement.
      A typed language built on
      inheritance-calculus\selfcite{~\cite{mixin2025}}{~(supplementary
      material)} inherits the immunity to nonextensibility and need
      only ensure that its type system does not introduce
    nonextensible constructs.}
    Programming languages typically provide a mix of extensible and
    nonextensible constructs, where extensibility is opt-in:
    frameworks must encode nonextensible constructs into extensible
    constructs using sophisticated
    mechanisms~\cite{liang1995monad, lammel2003scrap, loh2006open,
      swierstra2008data, carette2009finally, oliveira2012extensibility,
      kiselyov2013extensible, wu2014effect, kiselyov2015freer,
    wang2016trivially, leijen2017type, poulsen2023hefty},
    and code that uses nonextensible constructs
    cannot be extended unless rewritten in the framework.
    Section~\ref{sec:semantic-variants} analyzes why deep merge

  \item[Function color blindness]
    \label{sec:practical-function-color}
    Structured effects require no dedicated mechanism.
    Business logic in MIXINv2 declares abstract property slots;
    different assemblies fill them with synchronous or
    asynchronous implementations via inheritance.
    Because the slot's color varies at assembly time without
    affecting the code that uses it, the same MIXINv2 file runs
    under both synchronous and asynchronous
    runtimes\selfcite{~\cite{mixin2025}}{~(supplementary
    material)}, an instance of function color
    blindness~\cite{nystrom2015color}.
    The mechanism is dependency injection via inheritance:
    business logic declares empty slots, and the assembly
    inherits an FFI module that fills them, so the same
    business logic accepts implementations of any color.%
    \footnote{Function color~\cite{nystrom2015color} arises when
      effectful functions have signatures $a \to f\,b$ (Kleisli
      arrows), requiring monadic bind to compose and making the
      effect $f$ visible at every call site.
      Because inheritance-calculus composes program structure
      rather than executing effects, this type distinction does
      not arise at the calculus level.
      The color is determined at assembly time by the choice of
      inherited implementation, and effect execution is delegated
      to the host language.
      Unstructured control flow, such as capturing and resuming
      continuations as in \texttt{call/cc}, cannot be abstracted
      this way, as it requires a global CPS transformation that
    inheritance-calculus does not express.}
    is the only composition mechanism that achieves this.
\end{description}

\subsection{Semantic Alternatives}
\label{sec:semantic-variants}

The preceding item established that inheritance-calculus is immune
to nonextensibility.
We now ask whether an alternative design could share this property
by surveying every candidate known to us.

\paragraph{Degrees of freedom}
The analysis below assumes that the AST is a \emph{named tree}:%
\footnote{This excludes combinator-based languages such as
  SKI~\cite{schonfinkel1924,curry1958combinatory},
  APL~\cite{iverson1962programming}, and
  J~\cite{hui1991tacit}, whose programs are not
definition trees but point-free combinator expressions.}
every edge from parent to child carries a label, so that every
node is uniquely identified by the path from the root.
For configuration languages this is naturally the case: every
key in a JSON, YAML, or Nix attribute set is a label, and nesting
produces paths.%
\footnote{Nix is a functional language with first-class functions;
  its attribute sets alone do not form a named-tree DSL.
  The NixOS module system~\cite{nixosmodules}, however,
  restricts the user-facing interface to nested attribute sets
  composed by recursive merging, and it is this DSL-level
structure that naturally forms a named tree.}
For mainstream programming languages the AST is not directly a
named tree---anonymous expression positions and implicit
scopes lack labels---but after ANF
transformation~\cite{flanagan1993essence} every intermediate
result is bound to a name, and the remaining anonymous positions
(e.g., the body of a $\mathbf{let}$) can be assigned synthetic
fresh labels (such as $\mathrm{result}$ and $\mathrm{tailCall}$
in Section~\ref{sec:forward-translation}), yielding a named
tree.

Under this premise, every language whose programs are such
named trees with references can be characterized by two finite sets:
a set~$\mathcal{N}$ of \emph{node types}, each determining how a
subtree organizes its children, and a set~$\mathcal{R}$ of
\emph{reference types}, each determining how one position in the
tree refers to another.
The syntax is fixed by the choice of $\mathcal{N}$ and
$\mathcal{R}$; the semantics is determined by how each node type
structures composition and how each reference type resolves its
target.

{\small
  \begin{center}
    \begin{tabular}{lp{0.38\columnwidth}p{0.33\columnwidth}}
      \textbf{Language}
      & \textbf{Node types $\mathcal{N}$}
      & \textbf{Reference types $\mathcal{R}$} \\
      \hline
      Java (OOP)
      & class, interface, method,
      block, conditional, loop,
      \texttt{throw}, lambda, \ldots
      & variable, field access, method call,
      \texttt{extends}/\texttt{implements},
      \texttt{import}, \ldots \\[3pt]
      Haskell (FP)
      & $\lambda$, application, \texttt{let},
      \texttt{case}, \texttt{data},
      type class, instance, \ldots
      & variable, constructor,
      type class dispatch,
      \texttt{import}, \ldots \\[3pt]
      Scala (multi-paradigm)
      & class, trait, object, method,
      block, conditional, \texttt{match},
      \texttt{while}, \texttt{throw}, \ldots
      & variable, member access,
      \texttt{extends}, \texttt{with},
      implicits, \texttt{import}, \ldots \\
      \hline
      $\lambda$-calculus
      & abstraction, application
      & variable \\
      Inheritance-calculus
      & record
      & inheritance \\
    \end{tabular}
  \end{center}
}

\paragraph{Immunity to nonextensibility}
A path~$p$ in a program~$P$ is \emph{extensible} if there exists
a program~$Q$ such that composing $P$ with~$Q$ through a reference
makes new properties observable at~$p$ without modifying~$P$.
A language is \emph{immune to nonextensibility} if every path in
every well-formed program is extensible.

We now classify the design space to explain why we chose the
semantics of Section~\ref{sec:mixin-trees}.
Two axes remain free:
the \emph{composition mechanism}---how the single reference
type incorporates definitions;
and the \emph{reference resolution}---how the single reference
type finds its target.

\subsubsection*{The composition mechanism}

Every composition mechanism determines how the definitions of one
abstraction are incorporated into another.
The following table classifies the known candidates by whether
they satisfy commutativity~(C), idempotence~(I), and
associativity~(A), and by their extensibility model.

\begin{center}
  \begin{tabular}{lcccll}
    \textbf{Candidate} & \textbf{C} & \textbf{I} & \textbf{A}
    & \textbf{Extensibility} & \textbf{Representative} \\
    \hline
    Deep merge
    & $\checkmark$ & $\checkmark$ & $\checkmark$
    & universal & this paper \\
    Shallow merge
    & $\times$ & $\checkmark$ & $\checkmark$
    & top-level only & JS spread \\
    Conflict rejection
    & $\checkmark$ & $\checkmark$ & $\checkmark$
    & none on overlap
    & Harper--Pierce~\cite{harper1991record} \\
    Priority merge
    & $\times$ & $\times$ & $\checkmark$
    & universal & Jsonnet~\texttt{+}, Nix~\texttt{//} \\
    $\beta$-reduction
    & $\times$ & $\times$ & $\times$
    & opt-in & Java, Haskell, Scala, \ldots \\
    Conditional
    & \multicolumn{3}{c}{causes divergence}
    & --- & --- \\
  \end{tabular}
\end{center}

\begin{description}
  \item[Deep merge]
    Merging same-label definitions recurses into their subtrees
    ($\overrides$, equation~\ref{eq:overrides}).
    Every label is an extension point, whether or not the
    original author anticipated extension.

  \item[Shallow merge]
    Nested labels cannot be independently extended.

  \item[Conflict rejection]
    Same-label definitions are rejected as errors.
    All three identities hold---but vacuously:
    the identities are satisfied because the compositions that
    would test them are refused.
    Conflict rejection prevents extending existing
    labels~\cite{harper1991record}---the composability that the
    Expression Problem~\cite{wadler1998expression} requires.

  \item[Priority merge]
    $A + B \neq B + A$: one source takes
    precedence~\cite{jsonnet,dolstra2010nixos}, introducing
    an ordering dependency.

  \item[$\beta$-reduction]
    Only the parameters placed by the author are extension
    points; the function body is closed.
    To make a new aspect extensible, the original function must
    be rewritten to accept an additional parameter.
    This applies to every language whose composition mechanism
    is function application---functional, object-oriented, and
    multi-paradigm alike---because method calls, virtual
    dispatch, and type-class resolution all reduce to
    $\beta$-reduction.
    The Expression Problem~\cite{wadler1998expression} is hard
    in all of them for the same reason:
    extensibility is opt-in.
    The frameworks that simulate immunity to nonextensibility
    (visitor pattern,
      object algebras~\cite{oliveira2012extensibility},
    finally tagless interpreters~\cite{carette2009finally})
    are the machinery needed to work around this limitation.

  \item[Conditional incorporation]
    Removing or conditionally including definitions can
    introduce cycles in the dependency graph, causing the
    recursive evaluation
    (Appendix~\ref{app:well-definedness}) to diverge.
\end{description}

\noindent
Among the candidates above, deep merge is the only one we found
that is commutative, idempotent, associative, and
immune to nonextensibility.
The other candidates each introduce a vulnerability to
nonextensibility or cause divergence.

\subsubsection*{The reference resolution}

Once deep merge over records is fixed as the composition
mechanism, four of the six semantic equations are determined
by the syntax:
$\properties$~(\ref{eq:properties}) reads the labels of a
record, $\bases$~(\ref{eq:bases}) reads its inheritance
sources, $\supers$~(\ref{eq:supers}) takes the transitive
closure, and $\overrides$~(\ref{eq:overrides}) implements
the merge.
The only remaining degree of freedom is how references
resolve: the $\resolve$~(\ref{eq:resolve}) and
$\this$~(\ref{eq:this}) equations.
We examine the three known candidates.

\begin{description}
  \item[Early binding]
    With early binding, references resolve at definition time to a
    fixed path, independently of how the record is later inherited.
    CUE~\cite{cue2019} exemplifies this: field references are
    statically resolved, and a nested field cannot refer to
    properties of its enclosing context contributed by later
    composition.
    This prevents the mixin from serving as a call stack for the
    $\lambda$-calculus: $\beta$-reduction requires the callee to
    observe the argument supplied at the call site, which is a
    later composition.
    With early binding, references are frozen before this
    composition occurs.
    In the equations,
    $\resolve$~(\ref{eq:resolve}) calls
    $\this$~(\ref{eq:this}), which walks the \emph{inherited}
    tree structure; late binding is what allows
    $\this$ to see properties contributed by later-composed
    mixins.
    Without a Turing-complete mixin, functions must be
    reintroduced as the composition mechanism, re-exposing
    the opt-in extensibility problem above.

  \item[Dynamic scope]
    With dynamic scope, references resolve at the point of use
    rather than the definition site.
    Jsonnet~\cite{jsonnet} follows this approach: \texttt{self}
    always refers to the final merged object, not the object at
    the definition site.
    Union file systems exhibit the same property at the
    file-system level: a symbolic link's relative path resolves
    against the mount context at dereference time, not against the
    layer that defined the link.
    Dynamic scope breaks the $\lambda$-calculus embedding
    (Section~\ref{sec:forward-translation}).
    The Substitution Lemma (Lemma~\ref{lem:substitution})
    relies on the base case $M = y$ ($y \neq x$):
    the de~Bruijn index $m$ of~$y$ walks up from the
    definition-site path $\init(p_{\mathrm{def}})$ to a scope
    level different from~$x$'s binder, so the substitution
    $\mathrm{argument} \mapsto \mathcal{T}(V)$ at~$x$'s scope
    has no effect.
    With dynamic scope this separation fails.%
    \footnote{Counterexample:
      $(\lambda x.\, \lambda y.\, x)\; V_1\; V_2$.
      The reference to~$x$ inside $\lambda y.\, x$ translates to
      $\dbi{1}.\mathrm{argument}$ (de~Bruijn index~$1$).
      With late binding, $\this$ starts from the definition-site
      scope (the inner $\lambda$) and walks up one level to the
      outer $\lambda$, reaching the slot
      $\mathrm{argument} \mapsto \mathcal{T}(V_1)$.
      With dynamic scope, the reference resolves from the
      use-site context, where the innermost enclosing scope is
      the application $\{C_1.\mathrm{result},\;
      \mathrm{argument} \mapsto \mathcal{T}(V_2)\}$;
      walking up one level reaches this scope's
      $\mathrm{argument}$ slot, returning $\mathcal{T}(V_2)$
      instead of $\mathcal{T}(V_1)$.
      This is the classical variable-capture failure of dynamic
    scoping.}
    As with early binding, the mixin cannot serve as a complete
    replacement for functions.

  \item[Single-target $\this$]
    Single-target $\this$ is a promising candidate:
    the Single-Path Lemma~(\ref{lem:single-path}) shows that
    for translated $\lambda$-terms, the frontier set~$S$ in
    $\this$~(\ref{eq:this}) always contains exactly one path,
    so the $\lambda$-calculus embedding does not require
    multi-target resolution.
    However, single-target $\this$ is vulnerable to
    nonextensibility for a different reason.
    When multiple inheritance routes reach the same scope,
    single-target resolution must reject the situation or select
    one route.
    The NixOS module system~\cite{nixosmodules} raises a
    duplicate-declaration error
    (Appendix~\ref{app:scala-multi-path}).
    This rejects nested extensions where two independently authored
    modules define the same option---a composition that arises
    when solving the Expression
    Problem~\cite{wadler1998expression}
    (Section~\ref{sec:expression-problem}).

    Our first three implementations of MIXINv2 used
    standard techniques for self-reference resolution: closure-based
    fixed points following Cook~\cite{cook1989denotational}, and
    stack-based environment lookup using de~Bruijn
    indices~\cite{debruijn1972lambda}.
    All three produced subtle bugs when inheritance introduced
    multiple routes to the same enclosing scope.
    The difficulty was structural:
    a closure captures a single environment, so a fixed-point
    combinator solves for a single self-reference; a stack-based
    environment is a linear chain where each scope level has one
    parent.
    Both data structures embed a single-valued assumption
    incompatible with the multi-path situation that multiple
    inheritance naturally produces
    (Appendix~\ref{app:scala-multi-path}).
    Equation~(\ref{eq:this}) emerged from abandoning this
    assumption: it tracks a \emph{frontier set}~$S$ rather than a
    single current scope.
\end{description}

\noindent
The following table summarizes the vulnerabilities of all
alternatives at both levels.

\begin{center}
  \begin{tabular}{llll}
    & \textbf{Candidate} & \textbf{Vulnerability}
    & \textbf{Representative} \\
    \hline
    \multirow{5}{*}{\rotatebox[origin=c]{90}{\scriptsize composition}}
    & Shallow merge
    & nested extensions not composable
    & JS spread \\
    & Conflict rejection
    & same-label extensions rejected
    & Harper--Pierce~\cite{harper1991record} \\
    & Priority merge
    & ordering dependency
    & Jsonnet~\texttt{+}~\cite{jsonnet},
    Nix~\texttt{//}~\cite{dolstra2010nixos} \\
    & $\beta$-reduction
    & opt-in extensibility
    & Java, Haskell, Scala, \ldots \\
    & Conditional
    & causes divergence
    & --- \\
    \hline
    \multirow{3}{*}{\rotatebox[origin=c]{90}{\scriptsize resolution}}
    & Early binding
    & mixin cannot replace function
    & CUE~\cite{cue2019} \\
    & Dynamic scope
    & mixin cannot replace function
    & Jsonnet~\cite{jsonnet}, union FS \\
    & Single-target $\this$
    & nested extensions rejected
    & NixOS modules~\cite{nixosmodules} \\
  \end{tabular}
\end{center}

\noindent
No alternative we examined at either level is immune to
nonextensibility.

The semantics of inheritance-calculus was not chosen from a menu.
We arrived at it by trying each alternative in this section
and finding that it failed:
shallow merge could not compose nested extensions;
priority merge introduced ordering dependencies;
early binding froze references before composition could
supply them;
dynamic scope broke the substitution that the
$\lambda$-calculus embedding relies on;
single-target $\this$ rejected the multi-path compositions
that the Expression Problem demands
(three successive implementations confirmed this---see above).
Deep merge with multi-target late-binding $\this$ is what
remained.

\section{Related Work}
\label{sec:related-work}

\subsection{Computational Models and $\lambda$-Calculus Semantics}

\paragraph{Minimal Turing-complete models}
Sch\"onfinkel~\cite{schonfinkel1924} and
Curry~\cite{curry1958combinatory} showed that the
$\lambda$-calculus reduces to three combinators $S$, $K$, $I$
($I$ is redundant: $I = SKK$).
The bracket abstraction that compiles $\lambda$-terms to SKI
is mechanical but incurs exponential blow-up in term size;
no new computational patterns emerge beyond those already
present in the $\lambda$-calculus.
Dolan~\cite{dolan2013mov} showed that the x86 \texttt{mov}
instruction alone is Turing complete by exploiting
addressing modes as implicit arithmetic on mutable memory;
the resulting programs are correct but provide no
abstraction mechanisms beyond those of the RAM Machine.
The Turing Machine itself, while universal, lacks random
access: reading a cell at distance~$d$ requires $d$
sequential tape movements.
Each of these models achieves Turing completeness by
\emph{removing} structure from an existing model:
fewer abstractions, worse ergonomics, no new expressiveness.
None of these reductions exhibits emergent phenomena
absent from the model it reduces.

\paragraph{Semantic descriptions of the $\lambda$-calculus}
The semantics of the $\lambda$-calculus can be defined in
several fundamentally different ways.
\emph{Operational semantics} takes $\beta$-reduction
$(\lambda x.\,M)\,N \to M[N/x]$ as the primitive notion of
computation~\cite{church1936unsolvable,church1941calculi,barendregt1984lambda}.
This requires capture-avoiding substitution, a mechanism whose
subtleties motivated de~Bruijn
indices~\cite{debruijn1972lambda} and explicit substitution
calculi~\cite{abadi1991explicit}, and a choice of evaluation
strategy: call-by-name versus
call-by-value~\cite{plotkin1975callbyname} or the lazy
strategy of Abramsky~\cite{abramsky1990lazy}.
\emph{Denotational semantics}~\cite{scott1970outline,scott1976data}
interprets terms in a mathematical domain, but giving meaning
to $\beta$-reduction requires a reflexive domain
$D \cong [D \to D]$, which has no set-theoretic solution by
Cantor's theorem; Scott's $D_\infty$ resolves this by
constructing $D$ as an inverse limit of continuous
lattices~\cite{scott1972continuous}.
The resulting semantics is adequate but not fully
abstract~\cite{plotkin1977lcf,milner1977fully}:
it identifies terms that observational equivalence
distinguishes~\cite{plotkin1975callbyname}.
\emph{Game semantics}~\cite{abramsky2000full,hyland2000full,nickau1994hereditarily}
achieves full abstraction for PCF and for the lazy
$\lambda$-calculus~\cite{abramsky1993lazy,abramsky1995games}
at the cost of considerably more intricate mathematical
machinery (arenas, strategies, innocence conditions).
In each of these approaches, the function space $[D \to D]$
is the central obstacle: operational semantics needs it
implicitly (via substitution), denotational semantics
constructs it explicitly, and game semantics refines it via
strategies.
None of these approaches yields a semantics of the lazy
$\lambda$-calculus that simultaneously lives in naive set
theory and is fully abstract: Scott's $D_\infty$ is adequate
but not fully abstract, and game semantics is fully abstract
but requires machinery (arenas, strategies, innocence
conditions) far beyond set theory.
In all three approaches the semantic objects are not directly
computable: Scott's denotations are elements of an uncountable
continuous lattice, game-semantic strategies are infinite trees
over move sequences, and the function space $[D \to D]$ has no
effective enumeration.
Each framework therefore requires a separate operational
semantics to define how computation proceeds; the denotational or
game-semantic model then serves as a mathematical proxy whose
adequacy with respect to the operational semantics must be proved
separately.
None of them eliminates the function space from the semantic
domain; none avoids capture-avoiding substitution; and none
dispenses with reduction rules or evaluation strategies.

\paragraph{Set-theoretic models of the $\lambda$-calculus}
Several families of $\lambda$-calculus models avoid the
inverse-limit construction of Scott's $D_\infty$ by working
in set-theoretic rather than domain-theoretic settings.
\emph{Graph models}~\cite{engeler1981algebras,plotkin1993set}
take a \emph{web}~$A$ equipped with an injection
$\iota : \mathcal{P}_{\mathrm{fin}}(A) \times A
\hookrightarrow A$
and set $D = \mathcal{P}(A)$.
Application is
$f \cdot x = \{\, b \mid \exists\, S \subseteq x,\;
\iota(S, b) \in f \,\}$:
the function space $[D \to D]$ is not constructed
explicitly but encoded inside $D$ via~$\iota$.
The construction uses only powerset lattices, no Scott
topology or continuity conditions.
Graph models are sensible (they equate all unsolvable terms):
Bucciarelli and Salibra~\cite{bucciarelli2008graph}
proved that the greatest sensible graph theory equals the
B\"ohm tree theory~$\mathcal{B}$.
\emph{Filter models}~\cite{barendregt1983filter,coppo1978type}
interpret a term as the filter (upward-closed,
intersection-closed set) of all intersection types derivable
for it.
The collection of all such filters forms an $\omega$-algebraic
lattice.
Barendregt, Coppo, and Dezani-Ciancaglini proved that type
assignment is sound and complete with respect to the filter
$\lambda$-model.
Dezani-Ciancaglini et al.~\cite{dezani1998intersection}
showed that the $\lambda$-theory of the BCD filter model
coincides exactly with B\"ohm tree equality: two terms
receive the same set of types if and only if they have the
same B\"ohm tree.
Filter models are more discriminating than graph models
in that every filter model's theory lies between
$\lambda\beta$ and~$\mathcal{B}$, with the BCD model
attaining~$\mathcal{B}$ exactly; they require the
additional machinery of intersection type theory and
algebraic lattices.
\emph{Relational models}~\cite{ehrhard2005finiteness,bucciarelli2001phase}
arise from the relational semantics of linear logic: the
exponential modality~$!$ is interpreted via finite
multisets~$\mathcal{M}_{\mathrm{fin}}(A)$, giving a
co-Kleisli category whose morphisms are relations from
$\mathcal{M}_{\mathrm{fin}}(A)$ to~$B$.
The multiset structure corresponds to nonidempotent
intersection types~\cite{decarvalho2018execution}, which
carry quantitative information (bounds on reduction length)
that idempotent systems lack.
Ehrhard~\cite{ehrhard2005finiteness} showed that in the
finiteness-space refinement of this model, standard
fixed-point operators are not finitary, and a standard
reflexive object for the pure $\lambda$-calculus cannot
exist in this category.
As \emph{denotational semantics} of the lazy
$\lambda$-calculus, full abstraction has been achieved
only through game
semantics~\cite{abramsky1993lazy,abramsky1995games}:
game semantics provides a compositional, fully abstract
model, whereas graph and filter models, although their
equational theories coincide with B\"ohm tree
equivalence, are formulated as models of the standard
$\lambda$-calculus and do not directly constitute a
denotational semantics of the lazy calculus.
In each family the denotation of a term is a set-theoretic
object whose membership is not effectively decidable in general:
graph-model application quantifies over all finite subsets of an
argument, filter-model denotations require enumerating all
derivable intersection types, and relational-model morphisms are
infinite relations.
None of these denotations can be computed from the term alone;
all three families presuppose an operational semantics
($\beta$-reduction) whose behavior the model validates after the
fact.
All three families are semantic \emph{models} of the
$\lambda$-calculus: they interpret $\lambda$-terms in an
external mathematical structure and validate
$\beta$-reduction as an equation in that structure.
None of them is a self-contained calculus with its own
primitives into which the $\lambda$-calculus embeds.
Moreover, graph and filter models' equational theories
coincide with B\"ohm tree equality---which equals
observational equivalence in the lazy $\lambda$-calculus
but is strictly coarser in the standard
calculus---while relational models cannot even host a
standard reflexive
object~\cite{ehrhard2005finiteness};
and none provides a fully abstract \emph{denotational
semantics} of the lazy $\lambda$-calculus without
game-theoretic machinery.

\paragraph{Recursive equations and fixpoint semantics}
Van~Emden and Kowalski~\cite{vanemden1976semantics} showed that
the semantics of predicate logic as a programming language admits
three equivalent characterizations:
operational (SLD resolution), model-theoretic (least Herbrand
model), and fixed-point (least fixed point of the immediate
consequence operator~$T_P$ on the powerset of ground atoms).
The $T_P$ operator is monotone on a complete lattice, but
the fixpoint definition and its execution are not isomorphic:
answering a single query requires a search strategy (SLD
resolution), and different strategies (depth-first,
breadth-first, tabling) yield different completeness properties.
The gap between the declarative fixpoint and the procedural
execution is non-trivial.
Aczel~\cite{aczel1977inductive} gave a systematic treatment of
inductive definitions via monotone operators on powerset lattices,
providing the logical foundations that Datalog-style semantics
rests on.
Cousot and Cousot~\cite{cousot1977abstract} independently
developed abstract interpretation, a framework for program
analysis that computes fixed points on abstract lattices connected
to concrete semantics by Galois connections.
Abstract interpretation \emph{approximates} the behavior of
programs rather than defining it exactly;
the lattice-theoretic technique, however, is shared.
Leroy and Grall~\cite{leroy2006coinductive} addressed the
treatment of divergence in big-step operational semantics by
passing from inductive to \emph{coinductive} definitions;
when divergence already emerges as
non-termination of recursive evaluation, no separate coinductive
formulation is needed.
Each of these prior frameworks operates on its own domain
(Herbrand models, abstract domains, evaluation judgments);
none has been applied to a tree-structured domain of paths
to obtain a fully abstract semantics of the lazy
$\lambda$-calculus without function spaces, substitution, or
reduction rules.

\subsection{Inheritance, Objects, and Records}

\paragraph{Denotational semantics of inheritance}
Cook~\cite{cook1989denotational} gave the first denotational
semantics of inheritance, modeling objects as recursive records and
inheritance as composition of \emph{generators}, which are functions from self
to complete object, and \emph{wrappers}, which are functions that modify
generators, solved by a fixed-point construction.
Cook's key insight, that inheritance is a general mechanism
applicable to any form of recursive definition and not only
object-oriented methods, is one of the starting points of the
present work.
The model has four primitives---records, functions, generators, and
wrappers---and requires a fixed-point combinator; composition is
asymmetric, as a wrapper modifies a generator but not vice versa.
The fixed-point construction relies on Scott continuity in a
domain of functions; the resulting denotations are not directly
executable, so a separate operational semantics is needed to
define method dispatch and object construction at runtime.

\paragraph{Mixin-based inheritance}
Bracha and Cook~\cite{bracha1990mixin} formalized mixins as
abstract subclasses, that is, functions from a superclass parameter to a
subclass, unifying the inheritance mechanisms of Smalltalk, Beta,
and CLOS under a single model.
Because mixin application is function composition, it is
\emph{neither commutative nor idempotent}: applying the same
mixin twice may produce different results, and applying two
mixins in different orders may yield different linearizations.
The C3 linearization algorithm~\cite{c3linearization} was later
developed to impose a deterministic order;
whether linearization is inherent to inheritance or an artifact of
noncommutativity had not been established.
Mixin composition operates at the \emph{method level}: applying a
mixin replaces or extends individual methods in a flat namespace.
There is no recursive merging of nested structure: composing two
mixins that define the same method name results in an override, not
deep merge.
Finally, mixins presuppose the $\lambda$-calculus as their
computational foundation: method bodies are functions, and mixin
application is function composition.
Mixins organize and compose functions but cannot replace
them; without the underlying $\lambda$-calculus, there is nothing
to compose.  The mixin mechanism itself is not Turing complete.
Bracha--Cook mixins are therefore not deep-mergeable.

\paragraph{Traits}
Sch\"arli et al.~\cite{scharli2003traits} introduced traits as
composable units of behavior. Trait composition is symmetric and
commutative: the sum of two traits is order-independent, which is
a departure from mixin ordering.
However, when two traits provide methods with the
same name, a \emph{conflict} arises and must be explicitly resolved
by the programmer through exclusion or aliasing.
Ducasse et al.~\cite{ducasse2006traits} extended the model with a
\emph{flattening property}: the semantics of a class is independent
of whether its methods originate from traits or are defined directly.
Like mixins, trait composition is \emph{flat}: it operates on
individual method names, not on nested structures, so same-name
definitions are conflicts rather than recursive merges.
And like mixins, traits presuppose the $\lambda$-calculus: trait
methods are functions, and the computational power resides in those
functions, not in the trait mechanism itself.
Traits are therefore not deep-mergeable mixins either.

\paragraph{Family polymorphism and virtual classes}
Ernst~\cite{ernst2001family} introduced family polymorphism, where
families of mutually dependent classes can be refined together in
subclasses. Ernst, Ostermann, and Cook~\cite{ernst2006virtual}
formalized this in the virtual class calculus, where classes are
class-valued attributes of objects, accessed via path expressions of
the form \texttt{this.out.C}.
The path \texttt{this.out} navigates to an enclosing scope.
A notable restriction is that each such path resolves to a
\emph{single} class in a \emph{single} enclosing object.
When multiple inheritance routes lead to the same scope, a common
situation under inheritance, single-valued resolution must choose
one route and discard the others, losing information.
The framework provides no mechanism for set-valued resolution.

\paragraph{Object calculi}
Abadi and Cardelli~\cite{abadi1996theory} developed a comprehensive
theory of objects, treating objects rather than classes as the
primitive notion. Their calculi include method update and
self-referential objects, but methods are fundamentally functions
that take self as a parameter, and object extension is asymmetric
since method override replaces the previous definition.
Boudol~\cite{boudol2004recursive} studied the recursive record
semantics of objects in a call-by-value setting, showing that
self-referential records require an unsafe fixed-point operator.
The unsafe fixed-point operator produces denotations in a domain
where well-definedness depends on the evaluation strategy; the
semantics is therefore inseparable from the operational reduction
rules.
Whether self-reference can be handled without a fixed-point operator
in the object language, for instance through coalgebraic
observation rather than reduction, was not explored in these calculi.

\paragraph{Record calculi}
Harper and Pierce~\cite{harper1991record} presented a record
calculus based on symmetric concatenation with a type system that
tracks the absence of fields.
When two records define the same label, concatenation
is undefined and raises a type error; the calculus leaves same-label
composition undefined.
Cardelli~\cite{cardelli1992extensible}
studied extensible records with subtyping;
R\'emy~\cite{remy1989type} gave a type system for records and
variants in ML.
These calculi operate on \emph{flat} records with no nesting and
treat records as \emph{data}, that is, initial algebras: a record is a
finite map from labels to values, fully determined at construction
time.  Nested records, self-reference, and lazy observation, which are the
properties needed for records to serve as a computational
substrate, are outside their scope.

\paragraph{DOT calculus}
Amin et al.~\cite{amin2016dot} formalized path-dependent types in
the DOT calculus, the theoretical foundation of Scala's type system.
DOT paths navigate through objects to reach nested type members,
providing a rich dependent type structure.
DOT includes the $\lambda$-calculus as a sub-language.
DOT stratifies its syntax into terms and types, with types further
divided into abstract type members bounded by $L..U$ and concrete
definitions; each stratum requires its own subtyping rules.
Whether these three roles could be unified under a single construct
remains an open question in the DOT line of work.
DOT's self variable in the object constructor $\nu(x : T)\, d$
binds $x$ to a single object; when multiple inheritance routes
lead to the same enclosing scope, the resulting intersection type
is unrealizable and Scala rejects it at compile time
(Appendix~\ref{app:scala-multi-path}).
When the path structure is simple enough that no multi-target
$\this$ resolution is needed, Scala programmers can approximate
deep merge manually: the cake pattern layers traits with
\texttt{self:} annotations, and object
algebras~\cite{oliveira2012extensibility} compose operations via
trait intersection, both requiring the programmer to write the
merge logic by hand for each level of nesting.

\subsection{Configuration Languages and Module Systems}

\paragraph{Configuration languages}
CUE~\cite{cue2019} unifies types and values in a single lattice
where unification (\texttt{\&}) is commutative, associative, and
idempotent.
CUE's design was motivated by Google's Borg Configuration
Language (GCL), which used graph unification.
CUE's lattice includes scalar types with a conflict
semantics where unifying incompatible scalars yields $\bot$; whether
scalars are necessary for a configuration language, or whether
tree structure alone suffices, is an interesting design question.
Jsonnet~\cite{jsonnet} provides object inheritance via the
\texttt{+} operator with mixin semantics: composition is
\emph{not} commutative since the right-hand side wins on scalar
conflicts, and deep merging requires explicit opt-in via the \texttt{+:}
syntax) on a per-field basis, so deep merge is
available but not the default.
Dhall~\cite{dhall2017} takes a functional approach: it is a typed
$\lambda$-calculus with records, where composition is a record merge
operator, not an inheritance mechanism.

\paragraph{Module systems and deep merge}
The NixOS module system~\cite{dolstra2010nixos,nixosmodules}
composes modules by \emph{recursively merging nested attribute sets},
not by linearization or method-level override, which is the same deep-merge
semantics that distinguishes tree-level inheritance from method-level
composition in prior mixin and trait calculi.
When two modules define the same nested path, their subtrees are
merged rather than overridden.
The NixOS module system incorporates deep merge,
recursive self-reference, deferred evaluation of modules, and a
rich type-checking layer on top.
The same mechanism powers
NixOS system configuration, Home
Manager~\cite{homemanager}, nix-darwin~\cite{nixdarwin},
flake-parts~\cite{flakeparts}, and dozens of other ecosystems,
collectively managing configurations of arbitrary complexity.
The one aspect that appears not to have been fully addressed is the
semantics of self-reference under multiple inheritance.
When two independent modules that inherit from the same
deferred module are composed, each import introduces its own
declaration of the shared options; the module system's
\texttt{merge\-Option\-Decls} rejects duplicate declarations
with a static error (Appendix~\ref{app:scala-multi-path}).
The module system cannot express that both routes contribute
equally to the same option, that is, the multi-path situation that
recursive merging naturally gives rise to, which motivated the
observational semantics of Section~\ref{sec:mixin-trees}.

\subsection{Our Companion Work}

\paragraph{Modular software architectures}
\label{sec:practical-modular}
Plugin systems, component frameworks, and dependency injection frameworks
enable software extensibility through declarative inheritance. The
symmetric, associative nature of inheritance (Section~\ref{sec:mixin-trees}) explains why such
systems work: components can be inherited in any order without changing
behavior.
MIXINv2\selfcite{~\cite{mixin2025}}{~(supplementary material)}
is itself a dependency injection framework:
each scope declares its dependencies as named slots, and
composition resolves them by name across scope boundaries,
making the inheritance-calculus patterns explicit rather than ad~hoc.

\paragraph{Union file systems}
\label{sec:practical-union-fs}
Union file systems (UnionFS, OverlayFS, AUFS) layer multiple directory
hierarchies to present a unified view. Their semantics resembles
inheritance-calculus in that later layers override earlier layers and files from all
layers remain accessible, but without a formal foundation these systems
resort to ad-hoc choices: asymmetric inheritance, noncommutative
conflict resolution for scalar files, and no late-binding or dynamic
dispatch across layers.
We implemented inheritance-calculus directly as a union file
system\selfcite{~\cite{ratarmount2025}}{~(included as supplementary material)},
obtaining late-binding semantics and dynamic dispatch for file lookups
with no additional mechanism beyond the three primitives.
In package managers, build systems, and OS distributions,
external toolchains transform configuration into file trees;
here, the file system serves as configuration to itself,
and the transformation is inheritance: a
\emph{file-system-as-compiler} in which the directory tree is
both the source program and the compilation target.

\section{Future Work}
\label{sec:future-work}

\selfcite{MIXINv2~\cite{mixin2025}}{The supplementary
implementation} is an executable implementation of inheritance-calculus
that already goes beyond the untyped calculus presented here:
it includes compile-time checking that all references resolve to
valid paths in the mixin tree, and a foreign-function interface (FFI)
that introduces scalar values from the host language.
The future work described below concerns the distance between this
implementation and a fully practical language, spanning both
theoretical foundations and library-level encodings.

\subsection{Type System}
MIXINv2's existing compile-time checks verify that every
reference path resolves to a property that exists in the inherited
result. Formalizing the soundness of these checks, that is, proving that
well-typed programs do not produce dangling references at
runtime, is one direction of future work.
Such a formalization would relate to the DOT
calculus~\cite{amin2016dot} in a manner analogous to how
inheritance-calculus relates to the $\lambda$-calculus: a Typed
inheritance-calculus can be viewed as DOT without $\lambda$, retaining
path-dependent types while replacing functions with
mixin inheritance.
A formal type system would be amenable to mechanization in proof
assistants (Coq, Agda) for verifying type safety, progress, and
preservation properties.

Beyond soundness of the existing checks, additional type system
features would strengthen the language.
A key example is \emph{totality checking}: verifying that an
inheritance provides implementations for all required slots, not
merely that references resolve.
In untyped inheritance-calculus, writing $\mathrm{magnitude} \mapsto \{\}$
is purely documentary: it defines a structural slot but imposes no
constraint on what must fill it.
Totality checking would enforce such declarations statically,
rejecting inheritances that leave required slots unfilled.

\subsection{Embedding Datalog}
Section~\ref{sec:emergent-phenomena} observed that ordinary
arithmetic on Church-encoded values produces the relational
semantics of logic programming as an emergent phenomenon:
trie union is a relation, $\bases$ is cross-join, $\supers$ is
union, and $\properties$ is projection.
Formalizing this observation as an embedding of Datalog
into inheritance-calculus, analogous to the $\lambda$-calculus
embedding of Section~\ref{sec:forward-translation}, is future
work.
Such an embedding would be structurally notable: the
$\lambda$-calculus is inherently lazy, Datalog is inherently
eager, and inheritance-calculus is neither, suggesting that
the two models are projections of the same observational
fixed-point semantics.

\subsection{Standard Library}
The remaining items concern the \emph{standard library}: they require
no extensions to the calculus or type system, but involve nontrivial
encodings within the existing framework.

Inheritance-calculus is \emph{open by default}: inheritance
can freely merge any two mixins, and a value may simultaneously
inhabit multiple constructors (e.g.,
$\{\mathrm{Zero},\; \mathrm{Odd},\; \mathrm{half} \mapsto \mathrm{Zero}\}$).
This is not a defect; it is the natural trie semantics of the
calculus, and the basis for solving the expression problem
(Section~\ref{sec:expression-problem}).
However, many operations (e.g., equality testing) assume that values
are \emph{linear}, inhabiting exactly one constructor.
The observer pattern (Section~\ref{sec:case-study}) does not enforce
this: applied to a multi-constructor value, all callbacks fire and
their results are inherited.

\emph{Schema validation} can be implemented at the library level
using existing primitives.
An observer can test whether a particular constructor is present,
returning a Boolean; a second Boolean dispatch then branches on the
result.
By chaining such tests, a factory can validate that a value matches
exactly one constructor and carries the required fields.
This does not restrict inheritance itself, which remains
unconstrained, but provides a way to detect invariant violations
before they propagate.

The same technique, an observer returning Boolean followed by Boolean
dispatch, yields \emph{closed pattern matching}.
The observer pattern of Section~\ref{sec:case-study} is inherently
\emph{open}: new constructor cases can be added through inheritance.
Closed matching, where exactly one branch is taken, can be encoded as
a \emph{visitor chain}: a linked list of if-then-else nodes, each
testing one constructor and falling through on mismatch.
This is analogous to GHC.Generics' $\mathrm{(:+:)}$ sum
representation~\cite{magalhaes2010generic}, where each link
corresponds to one summand.
An important consequence is that such chains do \emph{not}
commute, as they have a fixed order, and therefore cannot be extended
through open inheritance, which is the correct semantics for closed
dispatch.

\section{Conclusion}

Immunity to nonextensibility guided the design of
inheritance-calculus.
The emergent phenomena exhibit an expressive asymmetry
between inheritance-calculus and the $\lambda$-calculus.
Inheritance is not a mechanism for organizing functions;
functions are syntactic sugar for inheritance.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\appendix

\section{Expressive Asymmetry: Proofs}
\label{app:expressiveness}

\begin{definition}[Macro-expressibility, after Felleisen~\cite{felleisen1991expressive}]
\label{def:macro-expressibility}
A construct $C$ of language $\mathscr{L}_1$ is \emph{macro-expressible}
in language $\mathscr{L}_0$ if there exists a translation $\mathcal{E}$
such that for every program $P$ containing occurrences of $C$,
the translation $\mathcal{E}(P)$ is obtained by replacing each
occurrence of $C$ with an $\mathscr{L}_0$ expression that depends only
on $C$'s subexpressions, leaving all other constructs of $P$
unchanged.
\end{definition}

\begin{theorem}[Forward macro-expressibility]
\label{thm:forward-macro}
The translation $\mathcal{T}$
(Section~\ref{sec:forward-translation}) is a macro-expressible
embedding of the $\lambda$-calculus into inheritance-calculus.
\end{theorem}

\begin{proof}
Each of the five rules of $\mathcal{T}$ replaces one
$\lambda$-calculus construct with an inheritance-calculus expression
that depends only on the construct's immediate subexpressions.
No rule inspects the surrounding context.
\end{proof}

\begin{theorem}[Nonexpressibility of inheritance]
\label{thm:cartesian-nonexpressibility}
Let $\mathscr{L}_0$ be the sublanguage of
inheritance-calculus isomorphic to the lazy
$\lambda$-calculus under Full Abstraction
(Theorem~\ref{thm:full-abstraction}).
Then $\mathscr{L}_0$ cannot macro-express the
inheritance facilities of inheritance-calculus.
\end{theorem}

\begin{proof}
Let $\mathscr{L}_1$ be the inheritance-calculus and let
$\mathscr{L}_0$ be the sublanguage consisting of mixin
trees in the image of the translation $\mathcal{T}$
(Section~\ref{sec:forward-translation}), so that
$\mathscr{L}_0 \subset \mathscr{L}_1$.
Define the operational equivalence $\cong_0$ on
$\mathscr{L}_0$ via B\"ohm trees:
$\mathcal{T}(M) \cong_0 \mathcal{T}(N)$ iff
$\mathrm{BT}(M) = \mathrm{BT}(N)$.
By Full Abstraction (Theorem~\ref{thm:full-abstraction}),
$\cong_0$ coincides with the contextual equivalence of
$\mathscr{L}_0$ under $\lambda$-definable contexts;
$\mathscr{L}_0$ is therefore the lazy $\lambda$-calculus
as a programming language in the sense of
Felleisen~\cite{felleisen1991expressive} (Definition~3.1),
and $\mathscr{L}_1$ is its conservative extension.
Define $\cong_1$ on $\mathscr{L}_1$ as inheritance-contextual
equivalence:
$S \cong_1 S'$ iff for every inheritance-calculus context $C[\cdot]$,
$C[S]{\Downarrow} \Leftrightarrow C[S']{\Downarrow}$.

Define Church booleans via the translation $\mathcal{T}$
(Section~\ref{sec:forward-translation}):
$\mathrm{true} = \lambda t.\,\lambda f.\, t$ and
$\mathrm{false} = \lambda t.\,\lambda f.\, f$.
In de~Bruijn notation:
\begin{align*}
  \mathrm{true}  &\mapsto \{\mathrm{argument} \mapsto \{\},\;
    \mathrm{result} \mapsto \{\mathrm{argument} \mapsto \{\},\;
  \mathrm{result} \mapsto \dbi{1}.\mathrm{argument}\}\} \\
  \mathrm{false} &\mapsto \{\mathrm{argument} \mapsto \{\},\;
    \mathrm{result} \mapsto \{\mathrm{argument} \mapsto \{\},\;
  \mathrm{result} \mapsto \dbi{0}.\mathrm{argument}\}\}
\end{align*}
Define Church boolean equality
$\mathrm{eq} = \lambda a.\,\lambda b.\,
(a\;b)\;(b\;\mathrm{false}\;\mathrm{true})$.
In ANF:
\[
  \mathrm{eq} = \lambda a.\,\lambda b.\,
  \mathbf{let}\; x_1 = b\;\mathrm{false} \;\mathbf{in}\;
  \mathbf{let}\; x_2 = x_1\;\mathrm{true} \;\mathbf{in}\;
  \mathbf{let}\; x_3 = a\;b \;\mathbf{in}\;
  x_3\; x_2
\]
Applying $\mathcal{T}$ (Section~\ref{sec:forward-translation}):
\begin{align*}
  \mathrm{eq} &\mapsto \{\mathrm{argument} \mapsto \{\},\;
    \mathrm{result} \mapsto \{
      \mathrm{argument} \mapsto \{\}, \\
      & \quad
      x_1 \mapsto \{\dbi{0}.\mathrm{argument},\;
      \mathrm{argument} \mapsto \mathrm{false}\}, \\
      & \quad
      x_2 \mapsto \{x_1.\mathrm{result},\;
      \mathrm{argument} \mapsto \mathrm{true}\}, \\
      & \quad
      x_3 \mapsto \{\dbi{1}.\mathrm{argument},\;
        \mathrm{argument} \mapsto
      \dbi{0}.\mathrm{argument}\}, \\
      & \quad
      \mathrm{tailCall} \mapsto \{x_3.\mathrm{result},\;
      \mathrm{argument} \mapsto x_2.\mathrm{result}\}, \\
      & \quad
      \mathrm{result} \mapsto
      \mathrm{tailCall}.\mathrm{result}
  \}\}
\end{align*}
Here $\dbi{1}.\mathrm{argument}$ in $x_3$ reaches the outer
$\lambda a$ scope (one $\lambda$ up from $\lambda b$), and
$\dbi{0}.\mathrm{argument}$ reaches $\lambda b$ itself.

In inheritance-calculus, applying a function record to an argument
is: inherit the function, override its $\mathrm{argument}$
slot, and project $\mathrm{result}$.
Define mixin trees $e_1$ and $e_2$ that apply
$\mathrm{eq}$ to its two arguments via this mechanism:
\begin{align*}
  e_1 \;=\; \{&
    \mathrm{eqFalse} \mapsto
    \{\mathrm{eq},\;
    \mathrm{argument} \mapsto \mathrm{false}\}, \\
    & \mathrm{tailCall} \mapsto
    \{\mathrm{eqFalse}.\mathrm{result},\;
    \mathrm{argument} \mapsto \mathrm{false}\}, \\
    & \mathrm{result} \mapsto
    \mathrm{tailCall}.\mathrm{result}
  \;\} \\[6pt]
  e_2 \;=\; \{&
    \mathrm{eqTrue} \mapsto
    \{\mathrm{eq},\;
    \mathrm{argument} \mapsto \mathrm{true}\}, \\
    & \mathrm{tailCall} \mapsto
    \{\mathrm{eqTrue}.\mathrm{result},\;
    \mathrm{argument} \mapsto \mathrm{true}\}, \\
    & \mathrm{result} \mapsto
    \mathrm{tailCall}.\mathrm{result}
  \;\}
\end{align*}
That is,
$e_1 = \mathcal{T}(\mathrm{ANF}(
\mathrm{eq}\;\mathrm{false}\;\mathrm{false}))$
and
$e_2 = \mathcal{T}(\mathrm{ANF}(
\mathrm{eq}\;\mathrm{true}\;\mathrm{true}))$,
where $\mathrm{ANF}$ converts a $\lambda$-term to A-normal
form by naming every intermediate application
(Section~\ref{sec:forward-translation}).
Since $e_1$ and $e_2$ are images of $\lambda$-terms
under $\mathcal{T}$, they lie in $\mathscr{L}_0$
by definition.
Both $e_1.\mathrm{result}$ and $e_2.\mathrm{result}$
evaluate to Church $\mathrm{true}$.
By Full Abstraction (Theorem~\ref{thm:full-abstraction}),
$\mathrm{BT}(e_1) = \mathrm{BT}(e_2)$,
so $e_1 \cong_0 e_2$.

All the definitions above---$\mathrm{true}$,
$\mathrm{false}$, $\mathrm{eq}$, $e_1$, $e_2$---are
siblings in a common enclosing scope $S$.
Now define a mixin $C$ on $S$ that extends $\mathrm{eq}$
with a $\mathrm{repr}$ scope.
The mixin targets the inner $\lambda b$ scope (the
$\mathrm{result}$ of $\mathrm{eq}$) and adds
a sibling record $\mathrm{repr}$:
\begin{align*}
  C ={} & \{\mathrm{eq} \mapsto \{
      \mathrm{result} \mapsto \{
        \mathrm{repr} \mapsto \{ \\
          & \qquad
          \mathrm{firstOperand}
          \mapsto \dbi{2}.\mathrm{argument},\;
          \mathrm{secondOperand}
          \mapsto \dbi{1}.\mathrm{argument}
  \}\}\}\}
\end{align*}
The de~Bruijn indices count scope levels from
$\mathrm{repr}$: $\dbi{0}$ is $\mathrm{repr}$ itself,
$\dbi{1}$ is the $\lambda b$ scope, and
$\dbi{2}$ is the $\lambda a$ scope.
Thus $\mathrm{firstOperand}$ projects $\lambda a$'s argument
and $\mathrm{secondOperand}$ projects $\lambda b$'s argument.

In the composite scope $\{S,\, C\}$, the definition of
$\mathrm{eq}$ gains $\mathrm{repr}$ as a new sibling of
$x_1, x_2, x_3$ inside the $\lambda b$ scope.
By open recursion, the de~Bruijn references
$\dbi{2}.\mathrm{argument}$ and
$\dbi{1}.\mathrm{argument}$ resolve through the same scope
chain as the existing let-bindings.
Since $e_1$ and $e_2$ inherit $\mathrm{eq}$, they also
inherit the newly added $\mathrm{repr}$:
$e_1.\mathrm{tailCall}.\mathrm{repr}.\mathrm{firstOperand} = \mathrm{false}$
and
$e_2.\mathrm{tailCall}.\mathrm{repr}.\mathrm{firstOperand} = \mathrm{true}$.
These produce structurally distinct mixin trees
(one converges to an abstraction selecting its first argument,
the other to an abstraction selecting its second),
so $e_1 \not\cong_1 e_2$.

Since $e_1 \cong_0 e_2$ but $e_1 \not\cong_1 e_2$,
we have ${\cong_0} \neq {(\cong_1|_{\mathscr{L}_0})}$.
By Theorem~3.14(i) of
Felleisen~\cite{felleisen1991expressive},
$\mathscr{L}_0$ cannot macro-express the inheritance facilities of $\mathscr{L}_1$.
\end{proof}

\begin{corollary}
\label{cor:expressive-asymmetry}
Inheritance-calculus is strictly more expressive than its
sublanguage $\mathscr{L}_0$ in the sense of
Felleisen~\cite{felleisen1991expressive}: the forward
embedding is macro-expressible
(Theorem~\ref{thm:forward-macro}), but $\mathscr{L}_0$
cannot macro-express inheritance
(Theorem~\ref{thm:cartesian-nonexpressibility}).
By Full Abstraction (Theorem~\ref{thm:full-abstraction}),
$\mathscr{L}_0$ is isomorphic to the lazy
$\lambda$-calculus under observational equivalence.
\end{corollary}

\section{Multi-Path Self-Reference in Other Systems}
\label{app:scala-multi-path}

This appendix demonstrates that two representative systems, Scala~3
and the NixOS module system, reject the multi-path self-reference
pattern that inheritance-calculus handles naturally.

\subsection*{Scala~3}

Consider two objects that independently extend an outer class,
each providing its own copy of an inner trait:

\begin{lstlisting}[style=scala]
class MyOuter:
  trait MyInner:
    def outer = MyOuter.this

object Object1 extends MyOuter
object Object2 extends MyOuter
object HasMultipleOuters extends Object1.MyInner
                     with Object2.MyInner
\end{lstlisting}

\noindent
Scala~3 rejects \texttt{HasMultipleOuters} with the error:

\begin{lstlisting}
trait MyInner is extended twice
object HasMultipleOuters cannot be instantiated since
  it has conflicting base types
  Object1.MyInner and Object2.MyInner
\end{lstlisting}

\noindent
The rejection is not a surface-level restriction but a consequence
of DOT's type-theoretic foundations~\cite{amin2016dot}.
In DOT, an object is constructed as $\nu(x : T)\, d$, where the
self variable~$x$ binds to a \emph{single} object.
\texttt{Object1.MyInner} and \texttt{Object2.MyInner} are distinct
path-dependent types, each constraining the outer self-reference
to a different object.
Their intersection requires \texttt{outer} to simultaneously
return \texttt{Object1} and \texttt{Object2}, but DOT's self
variable is single-valued, making this intersection unrealizable.

The equivalent inheritance-calculus definition is:
\begin{align*}
\{ \quad \mathrm{MyOuter} &\mapsto \{
    \mathrm{MyInner} \mapsto \{
  \mathrm{outer} \mapsto \qualifiedthis{\mathrm{MyOuter}}\}\}, \\
  \mathrm{Object1} &\mapsto \{\mathrm{MyOuter}\}, \\
  \mathrm{Object2} &\mapsto \{\mathrm{MyOuter}\}, \\
  \mathrm{HasMultipleOuters} &\mapsto \{
    \mathrm{Object1}.\mathrm{MyInner},\;
  \mathrm{Object2}.\mathrm{MyInner}\}
\quad \}
\end{align*}
This is well-defined in inheritance-calculus.
The reference
$\qualifiedthis{\mathrm{MyOuter}}$ inside $\mathrm{outer}$
has de~Bruijn index $n = 1$:
starting from $\mathrm{outer}$'s enclosing scope
$\mathrm{MyInner}$, one $\this$ step reaches
$\mathrm{MyOuter}$.
When $\mathrm{HasMultipleOuters}$ inherits from both
$\mathrm{Object1}.\mathrm{MyInner}$ and
$\mathrm{Object2}.\mathrm{MyInner}$,
the $\this$ function (equation~\ref{eq:this}) resolves
$\qualifiedthis{\mathrm{MyOuter}}$ by searching through
$\supers(\mathrm{HasMultipleOuters})$ for override paths matching
$\mathrm{MyInner}$'s definition site.
It finds two inheritance-site paths, one through
$\mathrm{Object1}$ and one through $\mathrm{Object2}$, and
returns both.
Both paths lead to records that inherit from the same
$\mathrm{MyOuter}$, so querying
$\mathrm{HasMultipleOuters}.\mathrm{outer}$ yields the
$\properties$ of $\mathrm{MyOuter}$ regardless of which
route is taken.
Since inheritance is idempotent, the two routes contribute the
same properties in this semantics, so no route-priority
disambiguation rule is introduced.

\subsection*{NixOS Module System}

The NixOS module system rejects the same pattern with a static error.
The translation uses the module system's own abstractions:
\texttt{deferredModule} for traits, which are unevaluated module values imported
into other fixpoints, and \texttt{submoduleWith} for objects, which are evaluated
in their own fixpoints.

\begin{lstlisting}[style=nix]
let
  lib = (import <nixpkgs> { }).lib;
  result = lib.evalModules {
    modules = [
      (toplevel@{ config, ... }: {
        # class MyOuter { trait MyInner {
        #   def outer = MyOuter.this } }
        options.MyOuter = lib.mkOption {
          default = { };
          type = lib.types.deferredModuleWith {
            staticModules = [
              (MyOuter: {
                options.MyInner = lib.mkOption {
                  default = { };
                  type = lib.types.deferredModuleWith {
                    staticModules = [
                      (MyInner: {
                        options.outer = lib.mkOption {
                          default = { };
                          type =
                            lib.types.deferredModuleWith {
                              staticModules =
                                [ toplevel.config.MyOuter ];
                            };
                        };
                      })
                    ];
                  };
                };
              })
            ];
          };
        };
        # object Object1 extends MyOuter
        options.Object1 = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [ toplevel.config.MyOuter ];
          };
        };
        # object Object2 extends MyOuter
        options.Object2 = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [ toplevel.config.MyOuter ];
          };
        };
        # object HasMultipleOuters extends
        #   Object1.MyInner with Object2.MyInner
        options.HasMultipleOuters = lib.mkOption {
          default = { };
          type = lib.types.submoduleWith {
            modules = [
            toplevel.config.Object1.MyInner
            toplevel.config.Object2.MyInner
          ];
          };
        };
      })
    ];
  };
in
  builtins.attrNames result.config.HasMultipleOuters.outer
\end{lstlisting}

\noindent
The NixOS module system rejects this with:

\begin{lstlisting}
error: The option `HasMultipleOuters.outer'
  in `<unknown-file>'
  is already declared
  in `<unknown-file>'.
\end{lstlisting}

\noindent
The rejection occurs because
\texttt{Object1.\allowbreak{}My\-Inner} and
\texttt{Object2.\allowbreak{}My\-Inner} each carry the full
\texttt{static\-Modules} of the \texttt{My\-Inner} deferred
module, including the declaration
\texttt{options.\allowbreak{}outer}.
When \texttt{My\-ObjectA} imports both, the module system's
\texttt{merge\-Option\-Decls} encounters two declarations of the
same option and raises a static error; it cannot express that
both declarations originate from the same trait and should be
unified.

The rejection is analogous to Scala's ``conflicting base types''
error above: both systems assume that each option or type member
has a single declaration site, and reject the multi-path situation
where two inheritance routes introduce the same declaration
independently.
In inheritance-calculus, the same pattern is well-defined because
$\overrides$ (equation~\ref{eq:overrides}) recognizes that both
routes lead to the same definition, and $\supers$
(equation~\ref{eq:supers}) collects both inheritance-site
contexts without duplication.

\section{Well-Definedness of the Semantic Functions}
\label{app:well-definedness}

This appendix proves that the mutually recursive equations
(\ref{eq:properties})--(\ref{eq:this}) are well-defined:
for every query whose recursive evaluation terminates, the
result is uniquely determined.
The proof proceeds by contrapositive: both a cycle and an
infinite acyclic chain in the dependency graph force
divergence, so termination implies that the reachable
subgraph is finite and acyclic, which in turn implies
uniqueness.

\begin{definition}[Dependency graph]\label{def:dependency-graph}
Fix an AST with its primitive functions $\defines$ and
$\inherits$.
The \emph{dependency graph} $G$ has as vertices all
semantic-function applications
($\properties(p)$, $\supers(p)$, $\overrides(p)$,
$\bases(p)$, $\resolve(\ldots)$, $\this(\ldots)$)
that arise from the AST\@.
There is a directed edge from vertex $u$ to vertex $v$
whenever computing $u$ via
equations~(\ref{eq:properties})--(\ref{eq:this})
requires the value of $v$.
\end{definition}

\begin{lemma}[Termination implies finite acyclic subgraph]%
\label{lem:termination-acyclicity}
If the memoized recursive evaluation of a query $q$
terminates, then the subgraph of $G$ reachable from $q$
is finite and acyclic.
\end{lemma}

\begin{proof}
Contrapositive.  A terminating computation visits finitely
many vertices, so the reachable subgraph is finite.
For acyclicity, suppose the reachable subgraph contains a
cycle $v_0 \to v_1 \to \cdots \to v_k = v_0$.
In a recursive evaluation, computing $v_0$ eventually
requires the value of $v_0$ before it has been determined.
Without a pre-assigned default value, this is infinite
recursion; hence the evaluation does not terminate.
\end{proof}

\begin{lemma}[Unique solution on acyclic graphs]%
\label{lem:unique-solution-dag}
If the subgraph of $G$ reachable from a query $q$ is a
finite directed acyclic graph, then the six equations
determine a unique value for every vertex in this subgraph.
\end{lemma}

\begin{proof}
By induction on the DAG in reverse topological order.
Leaves---vertices with no outgoing edges---have their
values determined directly by the AST primitives
$\defines$ and $\inherits$.
Each non-leaf vertex's value is uniquely determined by its
children's values via the corresponding equation.
\end{proof}

\begin{theorem}[Well-definedness]\label{thm:well-defined}
The semantic functions
$\properties$, $\supers$, $\overrides$, $\bases$, $\resolve$,
$\this$ are well-defined: for every query whose recursive
evaluation terminates, the result is the unique solution of
equations~(\ref{eq:properties})--(\ref{eq:this}) on the
reachable dependency subgraph.
\end{theorem}

\begin{proof}
By Lemma~\ref{lem:termination-acyclicity}, termination
implies that the reachable subgraph is a finite DAG\@.
By Lemma~\ref{lem:unique-solution-dag}, the equations have
a unique solution on this finite DAG\@.
Memoized recursive evaluation computes exactly this solution,
visiting each vertex at most once in reverse topological
order.
\end{proof}

\paragraph{Divergence}
The recursive evaluation diverges in two cases:
(1)~the dependency graph contains a cycle (circular
inheritance), causing infinite recursion; or
(2)~the reachable subgraph is an infinite acyclic chain
(an infinite inheritance hierarchy whose paths grow without
bound).
This is the analogue of divergence in the $\lambda$-calculus.
No separate treatment of divergence is needed; it emerges
from the recursive evaluation itself.

\section{B\"ohm Tree Correspondence: Proofs}
\label{app:bohm-tree-proofs}

This appendix contains the full proofs of Adequacy
(Theorem~\ref{thm:adequacy}) and Full Abstraction
(Theorem~\ref{thm:full-abstraction}) stated in
Section~\ref{sec:bohm-tree}.

\subsection{B\"ohm Trees}

We briefly recall the definition of B\"ohm
trees~\cite{barendregt1984lambda}.
A \emph{head reduction} $M \to_h M'$ contracts
the outermost $\beta$-redex only: if $M$ has the form
$(\lambda x.\, e)\; v\; M_1 \cdots M_k$, then
$M \to_h e[v/x]\; M_1 \cdots M_k$.
A term $M$ is in \emph{head normal form} (HNF) if it has no
head redex, i.e., $M = \lambda x_1 \ldots x_m.\;
y\; M_1 \cdots M_k$ where $y$ is a variable.

The \emph{B\"ohm tree} $\mathrm{BT}(M)$ of a $\lambda$-term $M$
is an infinite labeled tree defined by:
\[
\mathrm{BT}(M) =
\begin{cases}
  \bot & \text{if } M \text{ has no HNF} \\[6pt]
  \lambda x_1 \ldots x_m.\;
  y\bigl(\mathrm{BT}(M_1),\; \ldots,\; \mathrm{BT}(M_k)\bigr)
  &
  \begin{aligned}[t]
    &\text{if } M \to^*_h \\[-2pt]
    &\lambda x_1 \ldots x_m.\; y\; M_1 \cdots M_k
  \end{aligned}
\end{cases}
\]
B\"ohm tree equivalence $\mathrm{BT}(M) = \mathrm{BT}(N)$ is the
standard observational equivalence of the lazy
$\lambda$-calculus~\cite{abramsky1993lazy}.

\subsection{Path Encoding}

We define a correspondence between positions in the B\"ohm tree
and paths in the mixin tree.
When the translation $\mathcal{T}$ is applied to an ANF
$\lambda$-term, the resulting mixin tree has a specific shape:
\begin{itemize}
\item An abstraction $\lambda x.\, M$ translates to a record
  with own properties $\{\mathrm{argument}, \mathrm{result}\}$
  (the \emph{abstraction shape}).
\item A $\mathbf{let}$-binding
  $\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M$ translates
  to a record with own properties $\{x, \mathrm{result}\}$,
  where $x$ holds the encapsulated application
  $\{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
  \mathcal{T}(V_2)\}$.
\item A tail call $V_1\; V_2$ translates to a record with own
  properties $\{\mathrm{tailCall}, \mathrm{result}\}$, where
  $\mathrm{tailCall}$ holds the encapsulated application and
  $\mathrm{result}$ projects
  $\mathrm{tailCall}.\mathrm{result}$.
\item A variable $x$ with de~Bruijn index $n$ translates to
  an indexed reference $\dbi{n}.\mathrm{argument}$.
\end{itemize}

\noindent
Each B\"ohm tree position is a sequence of navigation steps from
the root.
In the B\"ohm tree, the possible steps at a node
$\lambda x_1 \ldots x_m.\; y\; M_1 \cdots M_k$ are:
entering the body (peeling off one abstraction layer) and
entering the $i$-th argument $M_i$ of the head variable.
In the mixin tree, these correspond to following the
$\mathrm{result}$ label (for entering the body) and the
$\mathrm{argument}$ label after $\this$ resolution (for
entering an argument position).

Rather than comparing absolute paths across different mixin
trees (which would be sensitive to internal structure), we
observe only the \emph{convergence} behavior accessible via
the $\mathrm{result}$ projection.
Recall the definition of inheritance-convergence
(Definition~\ref{def:convergence}).
Each $\mathrm{result}$-following step corresponds to one head
reduction step in the $\lambda$-calculus: a tail call's
$\mathrm{result}$ projects through the encapsulated
application, and a $\mathbf{let}$-binding's $\mathrm{result}$
enters the continuation.
The abstraction shape at the end signals that a weak head
normal form has been reached.

\subsection{Single-Path Lemma}

The $\this$ function (equation~\ref{eq:this}) is designed for the
general case of multi-path mixin inheritance.
For translated $\lambda$-terms, we show it degenerates to
single-path resolution.

\begin{lemma}[Single Path]\label{lem:single-path}
For any closed ANF $\lambda$-term $M$, at every invocation of
$\this(S,\; p_{\mathrm{def}},\; n)$ during evaluation of
$\mathcal{T}(M)$, the frontier set $S$ contains exactly one
path.
\end{lemma}

\begin{proof}
By induction on the structure of the ANF term.

\paragraph{Case $\mathcal{T}(\lambda x.\, M)
  = \{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M)\}$}
This is a record literal with
$\defines = \{\mathrm{argument}, \mathrm{result}\}$ and
no inheritance sources, so $\inherits = \varnothing$.
At the root path $p$, we have $\overrides(p) = \{p\}$ (a single
path) since there are no inheritance sources to introduce
additional branches.
Inside $\mathcal{T}(M)$, any reference to $x$ is
$\dbi{n}.\mathrm{argument}$ where $n$ is the de~Bruijn index
pointing to this scope level.
Since $\mathcal{T}(\lambda x.\, M)$ introduces exactly one
scope level, there is exactly one
mixin at that level, hence $\this$ finds exactly one matching
pair $(p_{\mathrm{site}},\; p_{\mathrm{override}})$ in $\supers$.

\paragraph{Case
  $\mathcal{T}(\mathbf{let}\; x = V_1\; V_2
  \;\mathbf{in}\; M)
  = \{x \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
\mathrm{result} \mapsto \mathcal{T}(M)\}$}
The outer record has own properties $\{x, \mathrm{result}\}$
and no inheritance sources at the outer level
($\inherits = \varnothing$), so $\overrides(\text{root})
= \{\text{root}\}$.
Inside the $x$ subtree, the inheritance
$\{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
\mathcal{T}(V_2)\}$ has exactly one inheritance source
($\mathcal{T}(V_1)$), creating exactly one $\bases$ entry.
By induction on $V_1$, the single-path property holds inside
$\mathcal{T}(V_1)$.
Inside $\mathcal{T}(M)$, the induction hypothesis applies
directly.

\paragraph{Case $\mathcal{T}(V_1\; V_2) =
  \{\mathrm{tailCall} \mapsto
    \{\mathcal{T}(V_1),\; \mathrm{argument} \mapsto
    \mathcal{T}(V_2)\},\;
    \mathrm{result} \mapsto
\mathrm{tailCall}.\mathrm{result}\}$}
Identical to the $\mathbf{let}$-binding case: the outer record
has own properties $\{\mathrm{tailCall}, \mathrm{result}\}$
with no inheritance sources at the outer level, and the
$\mathrm{tailCall}$ subtree contains exactly one inheritance
source.

\paragraph{Case $\mathcal{T}(x)
= \dbi{n}.\mathrm{argument}$}
This is a reference, not a record.
The $\this$ function walks up $n$ steps from the enclosing scope.
By the inductive hypothesis on the enclosing translations,
each step of $\this$ encounters exactly one matching pair in
$\supers$.

\medskip\noindent
The key structural invariant is that the translation
$\mathcal{T}$ never produces two independent inheritance sources
at the same scope level that both define the same label.
In every case, application inheritances are \emph{encapsulated}
inside a named property ($x$ or $\mathrm{tailCall}$), and each
such encapsulated inheritance has exactly one inheritance
source.
This prevents diamond inheritance and ensures single-path
resolution throughout.
\end{proof}

\subsection{Substitution Lemma}

The core mechanism of the translation is that inheritance with
$\mathrm{argument} \mapsto \mathcal{T}(V)$ plays the role of
substitution.  We make this precise.

\begin{lemma}[Substitution]\label{lem:substitution}
Let $M$ be an ANF term in which $x$ may occur free,
and let $V$ be a closed value.
Define the \emph{inherited tree}
$C = \{\mathcal{T}(\lambda x.\, M),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$.
Then for every path $p$ under $C \snoc \mathrm{result}$ and
every label $\ell$:
\[
  \ell \in \properties(p)
  \text{ in } C \snoc \mathrm{result}
  \quad\Longleftrightarrow\quad
  \ell \in \properties(p)
  \text{ in } \mathcal{T}(M[V/x])
\]
where $M[V/x]$ is the usual capture-avoiding substitution.
\end{lemma}

\begin{proof}
By structural induction on $M$.

\paragraph{Base case: $M = x$}
Then $\mathcal{T}(x) =
\dbi{n}.\mathrm{argument}$ (where $n$ is the de~Bruijn index
of $x$), and
$C \snoc \mathrm{result}$ contains this reference.
In the inherited tree $C$, $\resolve$ and $\this$ resolve the reference by
navigating from the reference's enclosing scope up $n$ steps
to the binding $\lambda$, where the inheritance
$\{\mathcal{T}(\lambda x.\, x),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$ inherits into the
$\mathrm{argument}$ slot, providing $\mathcal{T}(V)$.
Since $C$ is the $\mathrm{tailCall}$ subtree of
$\mathcal{T}\bigl((\lambda x.\, M)\; V\bigr)$, which is a
closed ANF term, Lemma~\ref{lem:single-path} applies and
$\this$ finds exactly one path,
so $\resolve$ returns $\mathcal{T}(V)$'s subtree.
Since $M[V/x] = V$, we have
$\mathcal{T}(M[V/x]) = \mathcal{T}(V)$, and the properties
coincide.

\paragraph{Base case: $M = y$ where $y \neq x$}
Then $\dbi{m}.\mathrm{argument}$ (where $m$ is the de~Bruijn
index of $y$, $m \neq n$) walks up to a different scope level,
so the inheritance with
$\mathrm{argument} \mapsto \mathcal{T}(V)$ at the
binding scope of $x$ has no effect.
Since $M[V/x] = y$, the properties are identical.

\paragraph{Inductive case: $M = \lambda y.\, M'$}
Then $\mathcal{T}(M) =
\{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M')\}$.
The subtree at $C \snoc \mathrm{result}$ is another
abstraction-shaped record.
References to $x$ inside $\mathcal{T}(M')$ resolve through
$\this$ in exactly the same way (with one additional scope
level from the inner $\lambda$), and by induction on $M'$, the
properties under
$C \snoc \mathrm{result} \snoc \mathrm{result}$
coincide with those of
$\mathcal{T}(M'[V/x])$.
Since
$(\lambda y.\, M')[V/x] = \lambda y.\, (M'[V/x])$
(assuming $y$ is fresh), the result follows.

\paragraph{Inductive case:
  $M = \mathbf{let}\; z = V_1\; V_2$
$\mathbf{in}\; M'$}
Then
\[
  \mathcal{T}(M) =
  \{z \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
  \mathrm{result} \mapsto \mathcal{T}(M')\}.
\]
The substitution distributes:
$M[V/x] =
\mathbf{let}\; z = V_1[V/x]\; V_2[V/x]
\;\mathbf{in}\; M'[V/x]$.
By induction on $V_1$, $V_2$, and $M'$, the properties under
each subtree ($z$ and $\mathrm{result}$) coincide,
since references to $x$ inside each subtree resolve to
$\mathcal{T}(V)$ via the same $\this$ mechanism.

\paragraph{Inductive case: $M = V_1\; V_2$ (tail call)}
Analogous to the $\mathbf{let}$-binding case with
$\mathrm{tailCall}$ in place of $z$.
\end{proof}

\subsection{Convergence Preservation}

The convergence criterion (Definition~\ref{def:convergence})
follows the $\mathrm{result}$ chain from the root.
Each step in this chain corresponds to one head reduction step
in the $\lambda$-calculus.
We make this precise.

\begin{lemma}[Result-step]\label{lem:result-step}
Let $(\lambda x.\, M)\; V$ be a tail call (a $\beta$-redex).
Then for every path $p$ and label $\ell$:
\[
  \ell \in \properties\!\bigl(\,
  \text{root} \snoc \mathrm{result} \snoc p\,\bigr)
  \text{ in } \mathcal{T}\bigl((\lambda x.\, M)\; V\bigr)
  \;\Longleftrightarrow\;
  \ell \in \properties\!\bigl(\,
  \text{root} \snoc p\,\bigr)
  \text{ in } \mathcal{T}(M[V/x])
\]
That is, following one $\mathrm{result}$ projection in the
tail call's mixin tree yields the same properties as the
root of the reduct's mixin tree.
\end{lemma}

\begin{proof}
The translation gives:
\[
  \mathcal{T}\bigl((\lambda x.\, M)\; V\bigr) =
  \{\mathrm{tailCall} \mapsto
    \{\mathcal{T}(\lambda x.\, M),\;
    \mathrm{argument} \mapsto \mathcal{T}(V)\},\;
    \mathrm{result} \mapsto
  \mathrm{tailCall}.\mathrm{result}\}
\]
The $\mathrm{result}$ label at the root is defined as
$\mathrm{tailCall}.\mathrm{result}$, so
$\text{root} \snoc \mathrm{result}$ resolves to the
$\mathrm{result}$ path inside the inheritance
$\mathrm{tailCall} = \{\mathcal{T}(\lambda x.\, M),\;
\mathrm{argument} \mapsto \mathcal{T}(V)\}$.
This inheritance is exactly the inherited tree $C$ of
Lemma~\ref{lem:substitution}, and
$\mathrm{tailCall} \snoc \mathrm{result}$ is
$C \snoc \mathrm{result}$.
By Lemma~\ref{lem:substitution}, the properties under
$C \snoc \mathrm{result}$ coincide with those of
$\mathcal{T}(M[V/x])$.

\medskip\noindent
\emph{Let-binding variant.}
An analogous result holds for
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'$
where $V_1 = \lambda y.\, M''$.
The translation gives:
\[
  \mathcal{T}\bigl(\mathbf{let}\; x = V_1\; V_2
  \;\mathbf{in}\; M'\bigr) =
  \{x \mapsto \{\mathcal{T}(V_1),\;
    \mathrm{argument} \mapsto \mathcal{T}(V_2)\},\;
  \mathrm{result} \mapsto \mathcal{T}(M')\}
\]
Since $\mathrm{result} \mapsto \mathcal{T}(M')$ is a property
definition, the subtree at
$\text{root} \snoc \mathrm{result}$ is $\mathcal{T}(M')$.
Inside $\mathcal{T}(M')$, each reference to $x$ is
$x.\mathrm{result}$, which resolves to the $\mathrm{result}$
path inside the $x$ subtree
$\{\mathcal{T}(\lambda y.\, M''),\;
\mathrm{argument} \mapsto \mathcal{T}(V_2)\}$.
This is the inherited tree $C$ of
Lemma~\ref{lem:substitution}, so
$x.\mathrm{result}$ has the same properties as
$\mathcal{T}(M''[V_2/y])$.
In the $\lambda$-calculus,
$M = (\lambda x.\, M')(V_1\; V_2)$, and the head reduct is
$N = M'[(V_1\; V_2)/x]$.
In $\mathcal{T}(N)$, each occurrence of $x$ is replaced by
$(V_1\; V_2)$, whose result, by the tail-call variant above,
also yields $\mathcal{T}(M''[V_2/y])$.
Therefore the properties at
$\text{root} \snoc \mathrm{result} \snoc p$ in
$\mathcal{T}(M)$ coincide with those at
$\text{root} \snoc p$ in $\mathcal{T}(N)$ for all $p$.
\end{proof}

\begin{theorem}[Convergence preservation]%
\label{thm:convergence-preservation}
If $M \to_h N$ (head reduction), then
$\mathcal{T}(M){\Downarrow}$ if and only if
$\mathcal{T}(N){\Downarrow}$.
\end{theorem}

\begin{proof}
A head reduction step in ANF takes one of two forms:
a tail call $(\lambda x.\, M')\; V \to_h M'[V/x]$,
or a $\mathbf{let}$-binding
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'
\to_h M'[(V_1\; V_2)/x]$
(since $\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M' =
(\lambda x.\, M')(V_1\; V_2)$ in the $\lambda$-calculus).
In both cases, Lemma~\ref{lem:result-step} (tail-call and
let-binding variants respectively) shows that
the properties at $\text{root} \snoc \mathrm{result}^n$ in
$\mathcal{T}(M)$ coincide with the properties at
$\text{root} \snoc \mathrm{result}^{n-1}$ in
$\mathcal{T}(N)$ for all $n \ge 1$, where $N$ is the
head reduct.
Hence the abstraction shape appears at depth $n$ in the
pre-reduct if and only if it appears at depth $n - 1$ in
the post-reduct.
\end{proof}

\subsection{Adequacy}

A closed ANF term at the top level is either an abstraction
(a value) or a computation (a $\mathbf{let}$-binding or tail
call).
An abstraction translates to a record whose root immediately
has the abstraction shape; a computation's root has the form
$\{x, \mathrm{result}\}$ or
$\{\mathrm{tailCall}, \mathrm{result}\}$, and one must follow
the $\mathrm{result}$ chain to find the eventual value.

\begin{proof}[Proof of Theorem~\ref{thm:adequacy}]
($\Rightarrow$)
Suppose $M \to^*_h \lambda x.\, M'$ in $k$ head reduction
steps.
We show $\mathcal{T}(M)$ converges at depth $\le k$ by
induction on $k$.

\emph{Base case} ($k = 0$): $M$ is already an abstraction
$\lambda x.\, M'$.
Then $\mathcal{T}(M) =
\{\mathrm{argument} \mapsto \{\},\;
\mathrm{result} \mapsto \mathcal{T}(M')\}$,
whose root has
$\defines = \{\mathrm{argument}, \mathrm{result}\}$.
These labels are directly in $\defines$ of the root, so
the recursive evaluation returns them without further
recursion, and $\mathcal{T}(M)$ converges at depth $n = 0$.

\emph{Inductive step} ($k \ge 1$): $M$ is not an abstraction,
so $M$ is either a tail call or a $\mathbf{let}$-binding,
both of which are $\beta$-redexes.
Let $N$ be the head reduct, so
$M \to_h N \to^{k-1}_h \lambda x.\, M'$.
By Lemma~\ref{lem:result-step} (tail-call or
let-binding variant), the properties at
$\text{root} \snoc \mathrm{result} \snoc p$
in $\mathcal{T}(M)$ coincide with those at
$\text{root} \snoc p$ in $\mathcal{T}(N)$.
By the induction hypothesis, $\mathcal{T}(N)$
converges at depth $\le k - 1$, so $\mathcal{T}(M)$
converges at depth $\le k$.

\medskip\noindent
($\Leftarrow$)
Suppose $\mathcal{T}(M){\Downarrow}$ at depth $n$.
We show $M$ has a head normal form by induction on $n$.

\emph{Base case} ($n = 0$): the root of $\mathcal{T}(M)$ has
abstraction shape
$\{\mathrm{argument}, \mathrm{result}\}$.
Only the abstraction rule $\mathcal{T}(\lambda x.\, M')$
produces a root with own property $\mathrm{argument}$.
(For tail calls and $\mathbf{let}$-bindings, the root has
  $\defines = \{\mathrm{tailCall}, \mathrm{result}\}$
  or $\{x, \mathrm{result}\}$, and $\mathrm{argument}$ cannot
  appear via $\supers$ because
  $\inherits = \varnothing$ at the root, giving
$\bases(\text{root}) = \varnothing$.)
Therefore $M$ is an abstraction, hence already in head normal
form.

\emph{Inductive step} ($n \ge 1$): the abstraction shape
appears at depth $n$ but not at depth $0$.
By the base case argument, $M$ is not an abstraction, so $M$
is either a tail call $V_1\; V_2$ or a $\mathbf{let}$-binding
$\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M'$.
In both cases, $M$ is a $\beta$-redex
(since $V_1 = \lambda x.\, M'$ or
  $V_1 = \lambda y.\, M''$ respectively, the only closed
ANF value).
By Lemma~\ref{lem:result-step} (tail-call or
let-binding variant respectively), the properties at depth
$n - 1$ in $\mathcal{T}(N)$ match those at depth $n$
in $\mathcal{T}(M)$, where $N$ is the head reduct.
So $\mathcal{T}(N)$ converges at depth $n - 1$.
By the induction hypothesis, $N$ has a head normal
form, and since $M \to_h N$, so does $M$.
\end{proof}

\subsection{Full Abstraction}

Adequacy relates a single term's head normal form to its
inheritance-convergence.
Full abstraction lifts this to an equivalence between terms:
the translation $\mathcal{T}$ preserves and reflects
observational equivalence.

\begin{definition}[$\lambda$-contextual equivalence under $\mathcal{T}$]%
\label{def:ctx-equiv}
For closed $\lambda$-terms $M$ and $N$, write
$\mathcal{T}(M) \approx_\lambda \mathcal{T}(N)$ if for every
closing $\lambda$-calculus context $C[\cdot]$:
\[
  \mathcal{T}(C[M]){\Downarrow}
  \;\Longleftrightarrow\;
  \mathcal{T}(C[N]){\Downarrow}
\]
\end{definition}

\noindent
The subscript $\lambda$ emphasizes that the quantification ranges
over $\lambda$-calculus contexts, not over all inheritance-calculus contexts.
This definition observes only convergence (a single bit), but
quantifying over all $\lambda$-contexts makes it a fine-grained
equivalence: different contexts can supply different arguments
and project different results, probing every aspect of the
term's behavior within the $\lambda$-definable fragment.

\begin{proof}[Proof of Theorem~\ref{thm:full-abstraction}]
The translation $\mathcal{T}$ is compositional: for every
$\lambda$-calculus context $C[\cdot]$, the mixin tree
$\mathcal{T}(C[M])$ is determined by the mixin tree
$\mathcal{T}(M)$ and the translation of the context.
This means $\mathcal{T}$ preserves the context structure
needed for the argument.

\medskip\noindent
($\Leftarrow$)
Suppose $\mathrm{BT}(M) = \mathrm{BT}(N)$.
B\"ohm tree equivalence is a congruence~\cite{barendregt1984lambda},
so for every context $C[\cdot]$,
$\mathrm{BT}(C[M]) = \mathrm{BT}(C[N])$.
In particular, $C[M]$ has a head normal form iff $C[N]$ does.
By Theorem~\ref{thm:adequacy},
$\mathcal{T}(C[M]){\Downarrow}$ iff
$\mathcal{T}(C[N]){\Downarrow}$.
Hence $\mathcal{T}(M) \approx_\lambda \mathcal{T}(N)$.

\medskip\noindent
($\Rightarrow$)
Suppose $\mathrm{BT}(M) \neq \mathrm{BT}(N)$.
B\"ohm tree equivalence coincides with observational
equivalence for the lazy
$\lambda$-calculus~\cite{abramsky1993lazy}:
there exists a context $C[\cdot]$ such that $C[M]$ converges
and $C[N]$ diverges (or vice versa).
By Theorem~\ref{thm:adequacy},
$\mathcal{T}(C[M]){\Downarrow}$ and
$\mathcal{T}(C[N]){\Uparrow}$.
Hence $\mathcal{T}(M) \not\approx_\lambda \mathcal{T}(N)$.
\end{proof}

\noindent
The proof rests on two pillars: Adequacy
(Theorem~\ref{thm:adequacy}), which is our contribution, and
the classical result that B\"ohm tree equivalence equals
observational equivalence for the lazy
$\lambda$-calculus~\cite{abramsky1993lazy}.
The mixin tree semantics inherits full abstraction from the
$\lambda$-calculus without needing to define or compare
absolute paths inside mixin trees.

\section{Set-Theoretic Semantics of the ANF Lazy
\texorpdfstring{$\lambda$}{λ}-Calculus}
\label{app:lambda-fixpoint}

This appendix presents a semantics of the lazy
$\lambda$-calculus in A-normal form (ANF) that lives entirely
in set theory.
The semantics is given by mutually recursive set-comprehension
equations whose well-definedness follows from the same
termination argument as in
Appendix~\ref{app:well-definedness}.
No function spaces, no substitution, no reduction rules,
no evaluation order, and no domain theory are needed.
The central idea is that function application is modeled as
\emph{tree grafting}: applying a function record to an argument
splices the function's subtree into the call site, and variable
references navigate the resulting tree structure.

ANF is essential.
Traditional $\lambda$-calculus syntax allows anonymous
subexpressions such as $(f\; x)$ in $(f\; x)\; y$ that
have no label and cannot form paths.
ANF restores path-addressability by binding every
intermediate result to a name, so that every node in the
evaluation tree has a unique path address.

\paragraph{Syntax}
Let $M$ denote a computation and $V$ a value.
\[
\begin{array}{r@{\;::=\;}l}
  M & \mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M
  \mid V_1\; V_2
  \mid V \\
  V & x \mid \lambda x.\, M
\end{array}
\]
Every $\lambda$-term can be mechanically converted to ANF by
naming intermediate results; ANF is neither a restriction nor
an extension of the $\lambda$-calculus.
Variables use de~Bruijn indices: $\dbi{n}$ counts the number
of enclosing \emph{scope levels} (record braces) between the
reference and its binder, following the same convention as
inheritance-calculus.
In particular, a $\lambda$-bound variable that crosses $k$
intervening $\mathbf{let}$-binding scopes and $n$ intervening
$\lambda$-abstraction scopes is written $\dbi{n + k}$, not
$\dbi{n}$.
Let-bound variables are referenced by their binding name $x$.

\paragraph{Evaluation tree}
An evaluation tree has a single abstraction: every node can
serve as function, argument, binding, and result at the same time.
A $\Path$ is a sequence of labels $(\ell_1, \ldots, \ell_k)$
identifying a position in the mixin tree.
We write $p$ for a path, $()$ for the root,
$p \snoc \ell$ for extension,
$\init(p)$ for the parent path, and $\last(p)$ for the final label.

\paragraph{AST}
An ANF term is parsed into an AST that provides two
functions at each path~$p$:
\begin{itemize}
\item $\children(p)$: the set of labels locally defined at~$p$.
\item $\refs(p)$: the set of reference pairs
  $(n,\; \ell_*)$, where $n$ is a de~Bruijn index
  and $\ell_*$ is a list of downward projections.
\end{itemize}

\noindent
Each ANF construct populates these as follows.

\smallskip\noindent
An abstraction $\lambda x.\, M$ at path $p$:
\begin{align*}
\children(p) &= \{\mathrm{argument},\; \mathrm{result}\},
&\refs(p) &= \varnothing.
\end{align*}
The subtree at $p \snoc \mathrm{result}$ is determined by $M$;
the subtree at $p \snoc \mathrm{argument}$ is empty
($\children = \varnothing$, $\refs = \varnothing$).

\smallskip\noindent
A let-binding $\mathbf{let}\; x = V_1\; V_2 \;\mathbf{in}\; M$
at path $p$:
\begin{align*}
\children(p) &= \{x,\; \mathrm{result}\},
&\refs(p) &= \varnothing.
\end{align*}
The subtree at $p \snoc \mathrm{result}$ is determined by $M$.
The subtree at $p \snoc x$ represents the application
$V_1\; V_2$ and is determined by the form of $V_1$:
\begin{itemize}
\item If $V_1$ is a variable (either $\dbi{m}$ or a
  let-bound name), then
  \begin{align*}
    \children(p \snoc x) &= \{\mathrm{argument}\},
    &\refs(p \snoc x) &= \{(n_1,\; \ell_*)\},
  \end{align*}
  where the reference $(n_1,\; \ell_*)$ encodes
  the translation of $V_1$ (see below).
\item If $V_1 = \lambda y.\, M'$, the $\lambda$-literal is
  inlined:
  \begin{align*}
    \children(p \snoc x)
    &= \{\mathrm{argument},\; \mathrm{result}\},
    &\refs(p \snoc x) &= \varnothing,
  \end{align*}
  and the subtree at $p \snoc x \snoc \mathrm{result}$ is
  determined by $M'$.
\end{itemize}
In both cases the subtree at $p \snoc x \snoc \mathrm{argument}$
is determined by $V_2$.

\smallskip\noindent
A tail call $V_1\; V_2$ at path $p$:
\begin{align*}
\children(p) &= \{\mathrm{tailCall},\; \mathrm{result}\},
&\refs(p) &= \varnothing.
\end{align*}
The subtree at $p \snoc \mathrm{tailCall}$ is analogous to
the application node $p \snoc x$ above: if $V_1$ is a variable,
$\children = \{\mathrm{argument}\}$ with
$\refs = \{(n_1,\; \ell_*)\}$; if $V_1$ is a $\lambda$-literal,
$\children = \{\mathrm{argument},\; \mathrm{result}\}$ with
$\refs = \varnothing$ and the $\lambda$-body inlined.
The subtree at $p \snoc \mathrm{result}$ is a forwarding
reference:
\begin{align*}
\children(p \snoc \mathrm{result})
&= \varnothing,
&\refs(p \snoc \mathrm{result})
&= \{(0,\; (\mathrm{tailCall},\; \mathrm{result}))\}.
\end{align*}
Here $(0,\; (\mathrm{tailCall},\; \mathrm{result}))$ navigates to
the enclosing scope ($p$ itself, since $n = 0$ from
$p \snoc \mathrm{result}$'s perspective), then projects
$\mathrm{tailCall}.\mathrm{result}$.

\smallskip\noindent
A $\lambda$-bound variable $\dbi{n}$ used as an inheritance
source at an application node $p$ contributes
$(n,\; (\mathrm{argument}))$ to $\refs(p)$:
navigate up $n$ scope levels, then project
$\mathrm{argument}$.
The same applies when $\dbi{n}$ occurs as a bare value in tail
position or as an argument value, contributing the reference to
$\refs$ at the corresponding path.

A let-bound variable $x$ at path $p$ is resolved lexically:
find the nearest ancestor $p'$ of $p$ such that
$x \in \children(p')$, let $n = |p| - |p'| - 1$,
and contribute $(n,\; (x,\; \mathrm{result}))$ to
$\refs(p)$, projecting
$x.\mathrm{result}$ from the enclosing scope.

Note that since the de~Bruijn index $n$ counts \emph{all}
scope levels (not just $\lambda$-abstractions), it accounts
for intervening $\mathbf{let}$-binding and tail-call scopes.
For example, in $\lambda.\,\lambda.\,\mathbf{let}\; r =
\dbi{2}\;\dbi{0}\;\mathbf{in}\;r$, the outer-$\lambda$ variable
has de~Bruijn index $2$ (crossing the $\mathbf{let}$-scope and
the inner-$\lambda$ scope), not $1$.

Both $\children$ and $\refs$ are pure data extracted from the AST;
they are not functions of runtime state.

\paragraph{Labels}
The labels observable at a path are those locally
defined at any graft of any transitive callee:
\begin{equation}\label{eq:lambda-labels}
\labels(p) =
\bigl\{\; \ell \;\big|\;
  p_{\mathrm{step}} \in \callee^*(p),\;
  p_{\mathrm{graft}} \in \mathtt{grafts}(p_{\mathrm{step}}),\;
  \ell \in \children(p_{\mathrm{graft}})
\;\bigr\}
\end{equation}

\paragraph{Grafts}
When a function is applied, its subtree is \emph{grafted}
at the call site.
A child label $\ell$ of the callee also becomes a
child of the caller; the child at the callee's
$\ell$ position and the child at the caller's $\ell$
position (if any) share the same identity.
The grafts of $p$ collect all such identity-sharing
positions:
\begin{equation}\label{eq:lambda-grafts}
\mathtt{grafts}(p) =
\begin{cases}
  \{p\} & \text{if } p = ()  \\[6pt]
  \{p\}
  \;\cup\;
  \left\{\; p_{\mathrm{callee}} \snoc \last(p) \;\left|\;
    \begin{aligned}
      &p_{\mathrm{callee}} \in \callee^*(\init(p)), \\
      &\text{s.t.}\; \last(p) \in \children(p_{\mathrm{callee}})
    \end{aligned}
  \right.\right\}
  & \text{if } p \neq ()
\end{cases}
\end{equation}
Here $\callee^*$ denotes the reflexive-transitive closure of
$\callee$, defined next.

\paragraph{Callee}
The callee of a path $p$ is the set of paths that $p$ is
grafted from.
Concretely, $\callee$ resolves every reference in
$p$'s grafts one step:
\begin{equation}\label{eq:lambda-callee}
\callee(p) =
\left\{\; p_{\mathrm{target}} \;\left|\;
  \begin{aligned}
    &p_{\mathrm{graft}} \in \mathtt{grafts}(p), \\
    &(n,\; \ell_*) \in \refs(p_{\mathrm{graft}}), \\
    &p_{\mathrm{target}} = \scope(\init(p),\;
    \init(p_{\mathrm{graft}}),\; n) \snoc
    \ell_1 \snoc \cdots \snoc \ell_k
  \end{aligned}
\right.\right\}
\end{equation}
where $\ell_* = (\ell_1, \ldots, \ell_k)$.
The $\init(p_{\mathrm{graft}})$ passes the reference's
\emph{enclosing scope} to $\scope$, matching the convention of
$\resolve$~(\ref{eq:resolve}), which calls
$\this(\{p_{\mathrm{site}}\},\; \init(p_{\mathrm{def}}),\; n)$.

\paragraph{Scope resolution}
$\scope$ navigates upward through the evaluation tree
to find the binding site of a de~Bruijn reference.
Each ANF construct ($\lambda$-abstraction, $\mathbf{let}$-binding,
or tail call) introduces one scope level;
crossing a scope boundary means finding the call site
that grafted the current subtree.

$\scope$ takes three arguments: an evaluation-site path
$p_{\mathrm{site}}$ (where the grafted subtree lives),
a definition-site path $p_{\mathrm{def}}$
(the position in the original AST),
and a de~Bruijn index $n$.
\begin{equation}\label{eq:lambda-scope}
\scope(p_{\mathrm{site}},\; p_{\mathrm{def}},\; n) =
\begin{cases}
  p_{\mathrm{site}} & \text{if } n = 0 \\[6pt]
  \scope\!\left(
    p_{\mathrm{caller}},\;
    \init(p_{\mathrm{def}}),\;
    n - 1
  \right)
  & \text{if } n > 0
\end{cases}
\end{equation}
where $p_{\mathrm{caller}}$ is the unique path satisfying
$(p_{\mathrm{caller}},\; p_{\mathrm{def}})
\in \callee^{\mathrm{ctx}}(p_{\mathrm{site}})$,
and $\callee^{\mathrm{ctx}}$ pairs each element of
$\callee^*(p_{\mathrm{site}})$ with its provenance:
\begin{equation}\label{eq:lambda-callee-ctx}
\callee^{\mathrm{ctx}}(p) =
\bigl\{\; (\init(p_{\mathrm{step}}),\;
  p_{\mathrm{graft}}) \;\big|\;
  p_{\mathrm{step}} \in \callee^*(p),\;
  p_{\mathrm{graft}} \in \mathtt{grafts}(p_{\mathrm{step}})
\;\bigr\}
\end{equation}
At each step, $\init$ shortens $p_{\mathrm{def}}$ by one label
and $n$ decreases by one.
Since $n$ is a nonnegative integer, the recursion terminates.

This completes the chain of definitions needed to compute
$\labels(p)$.

\paragraph{Observational fixpoint semantics}
The definitions above constitute the complete semantics.
There are no reduction rules, no evaluation contexts, no
substitution.
Computation arises from querying progressively deeper paths
in a lazily constructed tree: the observer drives computation
by choosing which path to inspect, and the mutually recursive
definitions unfold on demand.

Formally, the mutually recursive
equations~(\ref{eq:lambda-labels})--(\ref{eq:lambda-callee-ctx})
define set membership recursively:
$\ell \in \labels(p)$ holds if and only if it can be
established by a finite chain of applications of these
equations.
Well-definedness follows from the same termination argument
as for the mixin tree equations
(Appendix~\ref{app:well-definedness}): if the recursive
evaluation terminates, the reachable dependency subgraph is
finite and acyclic, and the equations have a unique solution.
When no finite derivation exists for a given query, the
recursive evaluation does not terminate, analogous to
divergence.

\paragraph{Convergence}
An ANF term $M$ \emph{converges}, written $M{\Downarrow}$,
if there exists $n \ge 0$ such that
$\{\mathrm{argument},\, \mathrm{result}\}
\subseteq
\labels(\underbrace{
  \mathrm{result} \snoc \cdots \snoc \mathrm{result}
}_{n})$
in the semantics defined by the equations above.
This corresponds exactly to the B\"ohm
tree~\cite{barendregt1984lambda} of the original term:
$M$ converges iff it has a head normal form
(Theorem~\ref{thm:adequacy}), and two terms are equivalent
under this semantics iff they have the same B\"ohm tree
(Theorem~\ref{thm:full-abstraction}).
The proofs, given in Appendix~\ref{app:bohm-tree-proofs},
apply verbatim: each equation above is the specialization
of the corresponding mixin tree equation
(Section~\ref{sec:mixin-trees}) to terms in the image of
the translation $\mathcal{T}$
(Section~\ref{sec:forward-translation}), where the
Single-Path Lemma (Lemma~\ref{lem:single-path}) ensures
that the set-valued $\this$ function
(equation~\ref{eq:this}) degenerates to the single-valued
$\scope$ (equation~\ref{eq:lambda-scope}).

\end{document}

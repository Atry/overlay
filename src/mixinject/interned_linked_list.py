import weakref
from abc import ABC, abstractmethod
from collections.abc import Iterable, Iterator
from dataclasses import dataclass, field
from typing import (
    Final,
    Generic,
    Never,
    Type,
    TypeVar,
    final,
)


T = TypeVar("T")
T_co = TypeVar("T_co", covariant=True)


@dataclass(kw_only=True, slots=True, frozen=True, weakref_slot=False, eq=False)
class MixinMapping(ABC, Generic[T]):
    """Base class for dependency graphs supporting O(1) equality comparison.

    Equal graphs are interned to the same object instance within the same root,
    making equality comparison a simple identity check (O(1) instead of O(n)).

    This class is immutable and hashable, suitable for use as dictionary keys.

    Example::

        >>> root = RootMixinMapping()
        >>> graph1 = ChildMixinMapping(head=1, outer=root)
        >>> graph2 = ChildMixinMapping(head=1, outer=root)
        >>> graph1 is graph2  # Same object due to interning within same root
        True

        >>> # O(1) equality comparison via identity
        >>> graph1 == graph2
        True

        >>> # Suitable as dict key
        >>> cache = {graph1: "cached_value"}
        >>> cache[graph2]  # Same key due to interning
        'cached_value'
    """

    intern_pool: Final[weakref.WeakValueDictionary[T, "ChildMixinMapping[T]"]] = (
        field(default_factory=weakref.WeakValueDictionary)
    )


@final
@dataclass(kw_only=True, slots=True, frozen=True, weakref_slot=False, eq=False)
class RootMixinMapping(MixinMapping[T]):
    """
    Root of a dependency graph, representing an empty dependency chain.

    Each RootMixinMapping instance has its own intern pool for interning
    ChildMixinMapping nodes within that dependency graph.
    """


@final
@dataclass(kw_only=True, slots=True, frozen=True, weakref_slot=True, eq=False)
class ChildMixinMapping(MixinMapping[T]):
    """Non-empty dependency graph node.

    Uses object.__eq__ and object.__hash__ (identity-based) for O(1) comparison.
    This works because interned graphs with equal head within the same outer
    are the same object.
    """

    head: Final[T]
    """
    .. todo:: Remove this field. It's legacy and useless now.
    """
    outer: Final[MixinMapping[T]]
    """
    .. todo:: Remove this todo since this field has been renamed to ``outer``.
    """


def _replace_init():
    """
    Replace dataclass-generated ``__init__`` with a custom ``__new__`` for interning.

    This function patches :class:`ChildMixinMapping` to support the
    flyweight/interning pattern with a frozen dataclass.

    Why delete ``__init__``?
    ------------------------

    Python's object creation follows this sequence:

    1. Call ``__new__(cls, ...)`` to create or retrieve an instance
    2. Call ``__init__(instance, ...)`` on the returned object

    For frozen dataclasses, ``__init__`` uses ``object.__setattr__`` to set
    attributes. The problem arises when returning a cached instance:

    .. code-block:: python

        # In __new__:
        existing = pool.get(key)
        if existing is not None:
            return existing  # Return already-initialized frozen instance

        # Python then automatically calls:
        # existing.__init__(head=..., outer=...)
        # This raises FrozenInstanceError because frozen instances
        # cannot have their attributes set again!

    Solution
    --------

    1. Save the original ``__init__`` generated by ``@dataclass``
    2. Delete ``__init__`` from the class (prevents automatic invocation)
    3. Define custom ``__new__`` that:

       - Returns existing instance from pool if found (no init needed)
       - For new instances: create via ``super().__new__``, manually call
         ``original_init``, then cache in pool

    This ensures ``__init__`` is only called once per unique instance.
    """
    original_init = ChildMixinMapping.__init__
    ChildMixinMapping.__init__ = lambda self, *args, **kwargs: None

    def __new__(
        cls: Type[ChildMixinMapping[T]],
        *,
        head: T,
        outer: MixinMapping[T],
    ) -> ChildMixinMapping[T]:
        intern_pool = outer.intern_pool
        existing = intern_pool.get(head)
        if existing is not None:
            return existing
        else:
            instance = super(ChildMixinMapping, cls).__new__(cls)
            original_init(instance, head=head, outer=outer)
            intern_pool[head] = instance
            return instance

    ChildMixinMapping.__new__ = __new__


_replace_init()

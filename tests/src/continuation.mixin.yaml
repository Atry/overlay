# First-Class Continuations via Empty API Injection
#
# Demonstration: Empty API slots + dependency injection = CPS
# This shows that MixinCalculus programs in ANF automatically
# have continuation-passing style semantics.

# Example 1: Escape Continuation (call/cc style)

# Schema with an escape continuation
Escapable:
  value: {}
  escape: {}      # Empty API - this is a continuation!
  result: {}

# Normal computation: returns the value
ComputeNormal:
  - [Escapable]
  - value:
      normal: {}
    result:
      output:
        - [ComputeNormal, ~, value]

# Test: normal path (escape not invoked)
# Expected: {output: {normal: {}}}
test_normal_path:
  - [ComputeNormal]
  - escape:
      result: {}

# Computation that uses the escape continuation
ComputeEscape:
  - [Escapable]
  - value:
      early: {}
    result:
      - [ComputeEscape, ~, escape]
      - output:
          - [ComputeEscape, ~, value]

# Test: escape path (bypass normal result)
# Expected: {escaped: {early: {}}}
test_escape_path:
  - [ComputeEscape]
  - escape:
      result:
        escaped:
          - [test_escape_path, ~, result, output]

# Example 2: Success/Failure Continuations

Choice:
  on_success: {}
  on_failure: {}
  result: {}

# Succeeds: invokes on_success
ChoiceSucceed:
  - [Choice]
  - value:
      ok: {}
    result:
      - [ChoiceSucceed, ~, on_success]
      - payload:
          - [ChoiceSucceed, ~, value]

# Fails: invokes on_failure
ChoiceFail:
  - [Choice]
  - value:
      error: {}
    result:
      - [ChoiceFail, ~, on_failure]
      - payload:
          - [ChoiceFail, ~, value]

# Test: success continuation invoked
# Expected: {success_handler: {ok: {}}}
test_success:
  - [ChoiceSucceed]
  - on_success:
      result:
        success_handler:
          - [test_success, ~, result, payload]
    on_failure:
      result:
        failure_handler: {}

# Test: failure continuation invoked
# Expected: {failure_handler: {error: {}}}
test_failure:
  - [ChoiceFail]
  - on_success:
      result:
        success_handler: {}
    on_failure:
      result:
        failure_handler:
          - [test_failure, ~, result, payload]

# Example 3: Multiple Continuations (like exception handlers)

Protected:
  normal_exit: {}
  exception_exit: {}
  result: {}

# Takes the normal exit
NormalExit:
  - [Protected]
  - data:
      completed: {}
    result:
      - [NormalExit, ~, normal_exit]
      - value:
          - [NormalExit, ~, data]

# Takes the exception exit
ExceptionExit:
  - [Protected]
  - data:
      failed: {}
    result:
      - [ExceptionExit, ~, exception_exit]
      - value:
          - [ExceptionExit, ~, data]

# Test: normal exit taken
# Expected: {normal: {completed: {}}}
test_normal_exit:
  - [NormalExit]
  - normal_exit:
      result:
        normal:
          - [test_normal_exit, ~, result, value]
    exception_exit:
      result:
        exceptional: {}

# Test: exception exit taken
# Expected: {exceptional: {failed: {}}}
test_exception_exit:
  - [ExceptionExit]
  - normal_exit:
      result:
        normal: {}
    exception_exit:
      result:
        exceptional:
          - [test_exception_exit, ~, result, value]

# Analysis:
#
# This demonstrates that:
#
# 1. Empty API slots (escape, on_success, on_failure, etc.)
#    act as continuation parameters in CPS.
#
# 2. MixinCalculus is automatically in ANF:
#    - Every intermediate value has a name (field)
#    - Evaluation order is explicit
#
# 3. Dependency injection = CPS transformation:
#    - "The rest of the computation" is reified as fields
#    - Multiple continuations can coexist
#    - Continuations are composable via composition
#
# 4. Connection to "polymorphic delimited continuations":
#    - That paper uses ANF for CPS transformation
#    - MixinCalculus programs are already in ANF
#    - Therefore, first-class continuations come "for free"
#
# 5. Unlike lambda calculus CPS:
#    - No distinguished continuation parameter
#    - Symmetric (commutative composition)
#    - Multiple exit points without special operators

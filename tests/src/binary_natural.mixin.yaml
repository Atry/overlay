# Binary Natural Numbers
#
# Representation (following Agda cubical / alba-lang):
#   Zero         = 0
#   Odd(n)       = 2n + 1
#   Even(n)      = 2(n + 1)
#
# This ensures unique representations: every natural number has exactly
# one encoding. A BinNat is observed by providing three operations:
#   on_zero            → value for 0
#   on_odd(result)     → value for 2n + 1, given the result for n
#   on_even(result)    → value for 2(n + 1), given the result for n

BinNat:
  on_odd:
    argument: {}
    result: {}
  on_even:
    argument: {}
    result: {}
  on_zero: {}
  result: {}

# Zero = 0
Zero:
  - [BinNat]
  - result:
      - [Zero, ~, on_zero]

# Odd(n) = 2n + 1
Odd:
  - [BinNat]
  - operand:
      - [BinNat]
    applied_operand:
      - [operand]
      - on_odd:
          - [Odd, ~, on_odd]
        on_even:
          - [Odd, ~, on_even]
        on_zero:
          - [Odd, ~, on_zero]
    applied_on_odd:
      - [Odd, ~, on_odd]
      - argument:
          - [applied_operand, result]
    result:
      - [applied_on_odd, result]

# Even(n) = 2(n + 1) = 2n + 2
Even:
  - [BinNat]
  - operand:
      - [BinNat]
    applied_operand:
      - [operand]
      - on_odd:
          - [Even, ~, on_odd]
        on_even:
          - [Even, ~, on_even]
        on_zero:
          - [Even, ~, on_zero]
    applied_on_even:
      - [Even, ~, on_even]
      - argument:
          - [applied_operand, result]
    result:
      - [applied_on_even, result]

# Observer: produces a tree representation
#   odd(x)  for 2n + 1
#   even(x) for 2(n + 1)
#   z       for 0
binary_on_odd:
  argument: {}
  result:
    odd:
      - [argument]

binary_on_even:
  argument: {}
  result:
    even:
      - [argument]

binary_on_zero:
  z: {}

# Test: 0 = Zero → {z: {}}
test_zero:
  - [Zero]
  - on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 1 = Odd(Zero) → {odd: {z: {}}}
test_one:
  - [Odd]
  - operand:
      - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 2 = Even(Zero) → {even: {z: {}}}
test_two:
  - [Even]
  - operand:
      - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 3 = Odd(Odd(Zero)) = 2(2·0+1)+1 = 3 → {odd: {odd: {z: {}}}}
test_three:
  - [Odd]
  - operand:
      - [Odd]
      - operand:
          - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 4 = Even(Odd(Zero)) = 2(1+1) = 4 → {even: {odd: {z: {}}}}
test_four:
  - [Even]
  - operand:
      - [Odd]
      - operand:
          - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 5 = Odd(Even(Zero)) = 2·2+1 = 5 → {odd: {even: {z: {}}}}
test_five:
  - [Odd]
  - operand:
      - [Even]
      - operand:
          - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# Test: 7 = Odd(Odd(Odd(Zero))) = 2(2(2·0+1)+1)+1 = 7 → {odd: {odd: {odd: {z: {}}}}}
test_seven:
  - [Odd]
  - operand:
      - [Odd]
      - operand:
          - [Odd]
          - operand:
              - [Zero]
    on_odd:
      - [binary_on_odd]
    on_even:
      - [binary_on_even]
    on_zero:
      - [binary_on_zero]

# ============================================================
# Dynamic Trie Lookup
# ============================================================
#
# A trie is a nested record indexed by BinNat keys:
#   value   — stored entry at this node (key = Zero)
#   at_odd  — subtrie for keys of the form Odd(n)
#   at_even — subtrie for keys of the form Even(n)
#
# Write (insertion) = composition with a singleton trie.
# Read (lookup) = fold the BinNat key into a trie Selector.
#
# A Selector is a mixin with {trie, result}: given a trie,
# it produces the looked-up value. The BinNat fold builds
# the Selector bottom-up:
#   Zero        → select .value from the trie
#   Odd(sel)    → navigate to .at_odd, then apply sel
#   Even(sel)   → navigate to .at_even, then apply sel

# A Selector: given a trie, produces a result.
# The trie declares its shape (value, at_odd, at_even) so the compiler
# can resolve property paths statically.
Selector:
  trie:
    value: {}
    at_odd: {}
    at_even: {}
  result: {}

# on_zero callback: a Selector that returns trie.value
lookup_on_zero:
  - [Selector]
  - result:
      - [lookup_on_zero, ~, trie, value]

LookupOddSelector:
  - [Selector]
  - argument:
      - [Selector]
  - applied_argument:
      - [argument]
      - trie:
          - [LookupOddSelector, ~, trie, at_odd]
  - result:
      - [applied_argument, result]

# on_odd callback: takes a Selector (argument), returns a new Selector
# that navigates to .at_odd then delegates to the argument Selector
lookup_on_odd:
  argument:
    - [Selector]
  result:
    - [LookupOddSelector]
    - argument:
        - [lookup_on_odd, ~, argument]

LookupEvenSelector:
  - [Selector]
  - argument:
      - [Selector]
  - applied_argument:
      - [argument]
      - trie:
          - [LookupEvenSelector, ~, trie, at_even]
  - result:
      - [applied_argument, result]

# on_even callback: same pattern, navigates to .at_even
lookup_on_even:
  argument:
    - [Selector]
  result:
    - [LookupEvenSelector]
    - argument:
        - [lookup_on_even, ~, argument]

# Lookup: composes a BinNat key with the trie observers,
# then applies the resulting Selector to the trie.
Lookup:
  key:
    - [BinNat]
  trie_input: {}
  applied_key:
    - [key]
    - on_zero:
        - [lookup_on_zero]
      on_odd:
        - [lookup_on_odd]
      on_even:
        - [lookup_on_even]
  selector:
    - [Selector]
    - [applied_key, result]
  applied_selector:
    - [selector]
    - trie:
        - [trie_input]
  result:
    - [applied_selector, result]

# === Dynamic Lookup Tests ===

# Test: look up key 0 = Zero in trie {value: {a: {}}}
# Expected result: {a: {}}
test_dynamic_lookup_zero:
  - [Lookup]
  - key:
      - [Zero]
    trie_input:
      - value:
          a: {}

# Test: look up key 1 = Odd(Zero) in trie {at_odd: {value: {b: {}}}}
# Expected result: {b: {}}
test_dynamic_lookup_one:
  - [Lookup]
  - key:
      - [Odd]
      - operand:
          - [Zero]
    trie_input:
      - at_odd:
          value:
            b: {}

# Test: look up key 5 = Odd(Even(Zero)) in a trie with multiple entries
# Expected result: {c: {}}
test_dynamic_lookup_five:
  - [Lookup]
  - key:
      - [Odd]
      - operand:
          - [Even]
          - operand:
              - [Zero]
    trie_input:
      - value:
          x: {}
      - at_odd:
          at_even:
            value:
              c: {}

# ============================================================
# Dynamic Trie Delete
# ============================================================
#
# Delete produces a new trie without the entry at a given BinNat key.
# Like Lookup, it folds the key into a combinator — here a "Rebuilder"
# that reconstructs the trie, omitting the targeted entry.
#
# A Rebuilder: given a trie, produces a new trie (result).
Rebuilder:
  trie:
    value: {}
    at_odd: {}
    at_even: {}
  result:
    value: {}
    at_odd: {}
    at_even: {}

# on_zero callback: a Rebuilder that drops value, keeps subtries
delete_on_zero:
  - [Rebuilder]
  - result:
      at_odd:
        - [delete_on_zero, ~, trie, at_odd]
      at_even:
        - [delete_on_zero, ~, trie, at_even]

# Helper: a Rebuilder that navigates into at_odd,
# applies the argument Rebuilder, and reassembles.
DeleteOddRebuilder:
  - [Rebuilder]
  - argument:
      - [Rebuilder]
  - applied_argument:
      - [argument]
      - trie:
          - [DeleteOddRebuilder, ~, trie, at_odd]
  - result:
      value:
        - [DeleteOddRebuilder, ~, trie, value]
      at_odd:
        - [applied_argument, result]
      at_even:
        - [DeleteOddRebuilder, ~, trie, at_even]

# on_odd callback: takes a Rebuilder (argument), returns a new Rebuilder
# that navigates into at_odd and delegates to the argument Rebuilder
delete_on_odd:
  argument:
    - [Rebuilder]
  result:
    - [DeleteOddRebuilder]
    - argument:
        - [delete_on_odd, ~, argument]

# Helper: symmetric to DeleteOddRebuilder, navigates into at_even
DeleteEvenRebuilder:
  - [Rebuilder]
  - argument:
      - [Rebuilder]
  - applied_argument:
      - [argument]
      - trie:
          - [DeleteEvenRebuilder, ~, trie, at_even]
  - result:
      value:
        - [DeleteEvenRebuilder, ~, trie, value]
      at_odd:
        - [DeleteEvenRebuilder, ~, trie, at_odd]
      at_even:
        - [applied_argument, result]

# on_even callback: takes a Rebuilder (argument), returns a new Rebuilder
# that navigates into at_even and delegates to the argument Rebuilder
delete_on_even:
  argument:
    - [Rebuilder]
  result:
    - [DeleteEvenRebuilder]
    - argument:
        - [delete_on_even, ~, argument]

# Delete: folds a BinNat key with delete callbacks to obtain a Rebuilder,
# then applies it to the trie.
Delete:
  key:
    - [BinNat]
  trie_input: {}
  applied_key:
    - [key]
    - on_zero:
        - [delete_on_zero]
      on_odd:
        - [delete_on_odd]
      on_even:
        - [delete_on_even]
  rebuilder:
    - [Rebuilder]
    - [applied_key, result]
  applied_rebuilder:
    - [rebuilder]
    - trie:
        - [trie_input]
  result:
    - [applied_rebuilder, result]

# === Dynamic Delete Tests ===

# Test: delete key 0 from trie {value: {a}, at_odd: {value: {b}}}
# Expected result: at_odd.value contains {b}, value is empty
test_delete_zero:
  - [Delete]
  - key:
      - [Zero]
    trie_input:
      - value:
          a: {}
        at_odd:
          value:
            b: {}

# Test: delete key 1 = Odd(Zero) from trie {value: {a}, at_odd: {value: {b}}}
# Expected result: value contains {a}, at_odd.value is empty
test_delete_one:
  - [Delete]
  - key:
      - [Odd]
      - operand:
          - [Zero]
    trie_input:
      - value:
          a: {}
        at_odd:
          value:
            b: {}

# Test: delete key 5 = Odd(Even(Zero)) from trie with entries at 0 and 5
# Expected result: value contains {a}, at_odd.at_even.value is empty
test_delete_five:
  - [Delete]
  - key:
      - [Odd]
      - operand:
          - [Even]
          - operand:
              - [Zero]
    trie_input:
      - value:
          a: {}
        at_odd:
          at_even:
            value:
              e: {}

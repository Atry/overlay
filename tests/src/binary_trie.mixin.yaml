# Immutable Binary Trie keyed by BinNat
#
# A trie IS a nested record, and MIXIN's composition (⊕) IS trie union.
# No special data structure is needed — records are tries.
#
# Trie node structure:
#   value   — stored value at this key
#   at_odd  — subtrie for keys of the form Odd(n)
#   at_even — subtrie for keys of the form Even(n)
#
# BinNat key → record path:
#   Zero         → value
#   Odd(n)       → at_odd, then path for n
#   Even(n)      → at_even, then path for n
#
# Inserting an entry is just composing a singleton record.
# Each composition creates a NEW immutable trie; the original is unchanged.

# === Singleton entries at specific BinNat keys ===

# Key 0 = Zero → path: value
entry_at_zero:
  value:
    a: {}

# Key 1 = Odd(Zero) → path: at_odd / value
entry_at_one:
  at_odd:
    value:
      b: {}

# Key 2 = Even(Zero) → path: at_even / value
entry_at_two:
  at_even:
    value:
      c: {}

# Key 3 = Odd(Odd(Zero)) → path: at_odd / at_odd / value
entry_at_three:
  at_odd:
    at_odd:
      value:
        d: {}

# Key 5 = Odd(Even(Zero)) → path: at_odd / at_even / value
entry_at_five:
  at_odd:
    at_even:
      value:
        e: {}

# === Immutable trie construction via chained composition ===
# Each step creates a new trie; prior versions remain unchanged.

trie_0:
  - [entry_at_zero]

trie_1:
  - [trie_0]
  - [entry_at_one]

trie_2:
  - [trie_1]
  - [entry_at_two]

trie_3:
  - [trie_2]
  - [entry_at_three]

trie_final:
  - [trie_3]
  - [entry_at_five]

# === Lookup tests: navigate the record path for each key ===

# Key 0 → value → should contain {a}
test_lookup_zero:
  - [trie_final, value]

# Key 1 → at_odd / value → should contain {b}
test_lookup_one:
  - [trie_final, at_odd, value]

# Key 2 → at_even / value → should contain {c}
test_lookup_two:
  - [trie_final, at_even, value]

# Key 3 → at_odd / at_odd / value → should contain {d}
test_lookup_three:
  - [trie_final, at_odd, at_odd, value]

# Key 5 → at_odd / at_even / value → should contain {e}
test_lookup_five:
  - [trie_final, at_odd, at_even, value]

# === Immutability: earlier tries are unchanged ===

# trie_0 has only key 0
test_immutable_trie_0:
  - [trie_0, value]

# trie_1 has keys 0 and 1
test_immutable_trie_1_at_one:
  - [trie_1, at_odd, value]

# === Trie union: compose two independent tries ===

left_trie:
  - [entry_at_zero]
  - [entry_at_one]

right_trie:
  - [entry_at_two]
  - [entry_at_five]

# Union = left ⊕ right → new trie with all four entries
union_trie:
  - [left_trie]
  - [right_trie]

test_union_zero:
  - [union_trie, value]

test_union_one:
  - [union_trie, at_odd, value]

test_union_two:
  - [union_trie, at_even, value]

test_union_five:
  - [union_trie, at_odd, at_even, value]

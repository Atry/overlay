# Church Booleans

Boolean:
  on_true: {}
  on_false: {}
  result: {}

# Approach 1: selfName path — ["True", ~, on_true] navigates via selfName to
# access inherited properties through self.allProperties.
"True":
  - [Boolean]
  - result:
      - ["True", ~, on_true]

# Approach 2: extern-style declaration — redeclaring on_false: {} as an own
# property makes [on_false] resolve via isOwnProperty, avoiding the need for
# a selfName path. The empty {} merges harmlessly with the inherited one.
"False":
  - [Boolean]
  - on_false: {}
    result:
      - [on_false]

Not:
  - [Boolean]
  - operand:
      - [Boolean]
    applied_operand:
      - [operand]
      - on_true:
          - [Not, ~, on_false]
        on_false:
          - [Not, ~, on_true]
    result:
      - [applied_operand, result]

And:
  - [Boolean]
  - left:
      - [Boolean]
    right:
      - [Boolean]
    applied_left:
      - [left]
      - on_true:
          - [And, ~, right]
        on_false:
          - ["False"]
    result:
      - [applied_left, result]

Or:
  - [Boolean]
  - left:
      - [Boolean]
    right:
      - [Boolean]
    applied_left:
      - [left]
      - on_true:
          - ["True"]
        on_false:
          - [Or, ~, right]
    result:
      - [applied_left, result]

# Test: Not(True) should have result with on_false's structure
test_not_true:
  - [Not]
  - operand:
      - ["True"]
    on_true:
      a: {}
    on_false:
      b: {}

# Test: And(True, True) = True, observed via on_true/on_false
test_and_true_true:
  - [And]
  - left:
      - ["True"]
    right:
      - ["True"]
    observed:
      - [test_and_true_true, ~, result]
      - on_true:
          a: {}
        on_false:
          b: {}

# Test: Or(False, True) = True, observed via on_true/on_false
test_or_false_true:
  - [Or]
  - left:
      - ["False"]
    right:
      - ["True"]
    observed:
      - [test_or_false_true, ~, result]
      - on_true:
          a: {}
        on_false:
          b: {}

# Church Naturals

Nat:
  successor:
    argument: {}
    result: {}
  zero: {}
  result: {}

Zero:
  - [Nat]
  - result:
      - [Zero, ~, zero]

Succ:
  - [Nat]
  - predecessor:
      - [Nat]
    applied_predecessor:
      - [predecessor]
      - successor:
          - [Succ, ~, successor]
        zero:
          - [Succ, ~, zero]
    applied_successor:
      - [Succ, ~, successor]
      - argument:
          - [applied_predecessor, result]
    result:
      - [applied_successor, result]

Add:
  - [Nat]
  - augend:
      - [Nat]
    addend:
      - [Nat]
    applied_addend:
      - [addend]
      - successor:
          - [Add, ~, successor]
        zero:
          - [Add, ~, zero]
    applied_augend:
      - [augend]
      - successor:
          - [Add, ~, successor]
        zero:
          - [applied_addend, result]
    result:
      - [applied_augend, result]

# Peano-style successor and zero for testing
peano_successor:
  argument: {}
  result:
    s:
      - [argument]

peano_zero:
  result:
    z: {}

# Test: Zero applied with Peano should give result containing z
test_zero:
  - [Zero]
  - successor:
      - [peano_successor]
    zero:
      - [peano_zero]

# Test: Succ(Zero) = one, applied with Peano should give {s: {z: {}}}
test_one:
  - [Succ]
  - predecessor:
      - [Zero]
    successor:
      - [peano_successor]
    zero:
      - [peano_zero]

# Test: Add(one, one) = two, applied with Peano should give {s: {s: {z: {}}}}
test_one_plus_one:
  - [Add]
  - augend:
      - [Succ]
      - predecessor:
          - [Zero]
    addend:
      - [Succ]
      - predecessor:
          - [Zero]
    successor:
      - [peano_successor]
    zero:
      - [peano_zero]
